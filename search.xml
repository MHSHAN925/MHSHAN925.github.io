<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java复习集合</title>
      <link href="2021/08/18/java%E5%A4%8D%E4%B9%A0%E9%9B%86%E5%90%88/"/>
      <url>2021/08/18/java%E5%A4%8D%E4%B9%A0%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="2021/08/18/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2021/08/18/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法（复盘代码随想录的回溯专题）"><a href="#回溯算法（复盘代码随想录的回溯专题）" class="headerlink" title="回溯算法（复盘代码随想录的回溯专题）"></a>回溯算法（复盘代码随想录的回溯专题）</h1><p>​        回溯算法：是一种搜索的算法。</p><p>​        回溯算法和递归是密不可分的。</p><p>​        回溯法的本质是穷举，穷举所有的可能，然后选出我们想要的答案。（有剪枝优化操作，但是本质还是穷举）。</p><p><strong>回溯法，⼀般可以解决如下⼏种问题：</strong><br><strong>组合问题：N个数⾥⾯按⼀定规则找出k个数的集合</strong><br><strong>切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式</strong><br><strong>⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集</strong><br><strong>排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式</strong><br><strong>棋盘问题：N皇后，解数独等等</strong></p><p>​        回溯法解决的问题都可以抽象为树形结构。回溯法解决的是在集合中递归查找子集，集合的大小构成了树的宽度，递归的深度构成了树的深度。递归要有终止条件，所以必然是一颗高度有限的树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//返回值以及参数</span><br><span class="line">void backtracking(参数) &#123;</span><br><span class="line">//终止条件</span><br><span class="line">if (终⽌条件) &#123;</span><br><span class="line">存放结果;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//遍历过程</span><br><span class="line">for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) &#123;</span><br><span class="line">处理节点;</span><br><span class="line">backtracking(路径，选择列表); // 递归</span><br><span class="line">回溯，撤销处理结果</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p>示例 1：</p><p>输入：n = 4, k = 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>示例 2：</p><p>输入：n = 1, k = 1<br>输出：[[1]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; backTracking(int n, int k)&#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">       Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">       if (k &lt;= 0 || n &lt; k)&#123;</span><br><span class="line">           return ans;</span><br><span class="line">       &#125;</span><br><span class="line">       dfs(n, k, 1, deque, ans);</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void dfs(int n, int k, int begin, Deque&lt;Integer&gt; deque, List&lt;List&lt;Integer&gt;&gt; ans)&#123;</span><br><span class="line">       if (deque.size() == k)&#123;</span><br><span class="line">           ans.add(new ArrayList&lt;&gt;(deque));</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = begin; i &lt; n; i++)&#123;</span><br><span class="line">           deque.addLast(i);</span><br><span class="line">           dfs(n, k, i + 1, deque, ans);</span><br><span class="line">           deque.removeLast();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>构建树的方式不一样，针对当前数，选择或者不选择，构成一个二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (k &lt;= 0 || n &lt; k) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 为了防止底层动态数组扩容，初始化的时候传入最大长度</span><br><span class="line">        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k);</span><br><span class="line">        dfs(1, n, k, path, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int begin, int n, int k, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 基础版本的递归终止条件：if (begin == n + 1) &#123;</span><br><span class="line">        if (begin &gt; n - k + 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 不选当前考虑的数 begin，直接递归到下一层</span><br><span class="line">        dfs(begin + 1, n, k, path, res);</span><br><span class="line"></span><br><span class="line">        // 不选当前考虑的数 begin，递归到下一层的时候 k - 1，这里 k 表示还需要选多少个数</span><br><span class="line">        path.addLast(begin);</span><br><span class="line">        dfs(begin + 1, n, k - 1, path, res);</span><br><span class="line">        // 深度优先遍历有回头的过程，因此需要撤销选择</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="宫水三叶：DFS-回溯"><a href="#宫水三叶：DFS-回溯" class="headerlink" title="宫水三叶：DFS+回溯"></a>宫水三叶：DFS+回溯</h1><p>如何快速判断一道题是否应该使用 DFS + 回溯算法来爆搜。</p><p>总的来说，你可以从两个方面来考虑：</p><ol><li>求的是所有的方案，而不是方案数。 由于求的是所有方案，不可能有什么特别的优化，我们只能进行枚举。这时候可能的解法有动态规划、记忆化搜索、DFS + 回溯算法。</li><li>通常数据范围不会太大，只有几十。 如果是动态规划或是记忆化搜索的题的话，由于它们的特点在于低重复/不重复枚举，所以一般数据范围可以出到 10^5到 10^7 ，而 DFS + 回溯的话，通常会限制在 30 以内。</li></ol><p>要枚举所有方案的题目，我们都应该先想到「回溯算法」。</p><p>「回溯算法」从算法定义上来说，不一定要用 DFS 实现，但通常结合 DFS 来做，难度是最低的。</p><p>「回溯算法」根据当前决策有多少种选择，对应了两套模板。</p><p><strong>每一次独立的决策只对应 选择 和 不选 两种情况：</strong><br>确定结束回溯过程的 base case<br>遍历每个位置，对每个位置进行决策（做选择 -&gt; 递归 -&gt; 撤销选择）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dfs(当前位置, 路径(当前结果), 结果集) &#123;</span><br><span class="line">    if (当前位置 == 结束位置) &#123;</span><br><span class="line">        结果集.add(路径);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    选择当前位置;    </span><br><span class="line">    dfs(下一位置, 路径(当前结果), 结果集);</span><br><span class="line">    撤销选择当前位置;</span><br><span class="line">    dfs(下一位置, 路径(当前结果), 结果集);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每一次独立的决策都对应了多种选择（通常对应了每次决策能选择什么，或者每次决策能选择多少个 …）:</strong><br>确定结束回溯过程的 base case<br>遍历所有的「选择」<br>对选择进行决策 (做选择 -&gt; 递归 -&gt; 撤销选择)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void dfs(选择列表, 路径(当前结果), 结果集) &#123;</span><br><span class="line">    if (满足结束条件) &#123;</span><br><span class="line">        结果集.add(路径);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    for (选择 in 选择列表) &#123;</span><br><span class="line">        做选择;</span><br><span class="line">        dfs(路径’, 选择列表, 结果集);</span><br><span class="line">        撤销选择;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39组合总和："><a href="#39组合总和：" class="headerlink" title="39组合总和："></a>39组合总和：</h2><p>​        给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p><p>​        candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p><p>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p><p>示例 1：</p><p>输入: candidates = [2,3,6,7], target = 7<br>输出: [[7],[2,2,3]]<br>示例 2：</p><p>输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br>示例 3：</p><p>输入: candidates = [2], target = 1<br>输出: []</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">思路一：二叉树</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,0,path,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int[] candidates, int target, int start, List path, int currSum)&#123;</span><br><span class="line">        if(target==currSum)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(target&lt;currSum)</span><br><span class="line">            return;</span><br><span class="line">        if(start==candidates.length)</span><br><span class="line">            return;</span><br><span class="line">            </span><br><span class="line">        path.add(candidates[start]);</span><br><span class="line">        dfs(candidates,target,start,path,currSum+candidates[start]);</span><br><span class="line">        path.remove(path.size()-1);</span><br><span class="line"></span><br><span class="line">        dfs(candidates,target,start+1,path,currSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">思路二：多叉树</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,0,path,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int[] candidates, int target, int start, List path, int currSum)&#123;</span><br><span class="line">        if(target==currSum)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(target&lt;currSum)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        for(int i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            dfs(candidates,target,i,path,currSum+candidates[i]);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-18</title>
      <link href="2021/08/18/8-18/"/>
      <url>2021/08/18/8-18/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-17</title>
      <link href="2021/08/17/8-17/"/>
      <url>2021/08/17/8-17/</url>
      
        <content type="html"><![CDATA[<h1 id="学生出勤记录一："><a href="#学生出勤记录一：" class="headerlink" title="学生出勤记录一："></a>学生出勤记录一：</h1><p>首先这是个放假题，直接上代码了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static boolean checkRecord(String s)&#123;</span><br><span class="line">        int absentDay = 0;</span><br><span class="line">        boolean lateNums = false;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if (s.charAt(i) == &#x27;A&#x27;)&#123;</span><br><span class="line">                absentDay++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0, right = left + 2;</span><br><span class="line">        while (right &lt; s.length())&#123;</span><br><span class="line">            if (s.charAt(left) == &#x27;L&#x27; &amp;&amp; s.charAt(left + 1) == &#x27;L&#x27; &amp;&amp; s.charAt(left + 2) == &#x27;L&#x27;)&#123;</span><br><span class="line">                lateNums = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (absentDay &lt; 2 &amp;&amp; !lateNums)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h1><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/*public static String convert(String s, int numRows)&#123;</span><br><span class="line">        char[] string = s.toCharArray();</span><br><span class="line">        char[] stringOut = new char[s.length()];</span><br><span class="line">        if (numRows == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        //rows中存储的是总共有多少行</span><br><span class="line">        List&lt;StringBuilder&gt; rows= new ArrayList&lt;&gt;();</span><br><span class="line">        //循环创建stringBuilder</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            rows.add(new StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, flag = -1;</span><br><span class="line">        for (char c : s.toCharArray())&#123;</span><br><span class="line">            rows.get(i).append(c);</span><br><span class="line">            if (i == 0 || i == numRows - 1)&#123;</span><br><span class="line">                flag = -flag;</span><br><span class="line">            &#125;</span><br><span class="line">            i += flag;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for (StringBuilder row : rows)&#123;</span><br><span class="line">            res.append(row);</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;*/</span><br><span class="line">    //官方题解中，选择StringBuilder的个数有一套，min(numRows，s.length)</span><br><span class="line">    public static String convert(String s, int numRows)&#123;</span><br><span class="line">        if (numRows == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        int rowNum = Math.min(numRows, s.length());</span><br><span class="line">        List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(rowNum);</span><br><span class="line">        for (int i = 0; i &lt; rowNum; i++)&#123;</span><br><span class="line">            rows.add(new StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = -1, i = 0;</span><br><span class="line">        for (char c : s.toCharArray())&#123;</span><br><span class="line">            rows.get(i).append(c);</span><br><span class="line">            if (i == 0 || i == rowNum - 1)&#123;</span><br><span class="line">                flag = -flag;</span><br><span class="line">            &#125;</span><br><span class="line">            i += flag;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for (StringBuilder row : rows)&#123;</span><br><span class="line">            res.append(row);</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-16</title>
      <link href="2021/08/16/8-16/"/>
      <url>2021/08/16/8-16/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-15</title>
      <link href="2021/08/15/8-15/"/>
      <url>2021/08/15/8-15/</url>
      
        <content type="html"><![CDATA[<h1 id="576-出界的路径数"><a href="#576-出界的路径数" class="headerlink" title="576.出界的路径数"></a>576.出界的路径数</h1><p>给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。</p><p>给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-14</title>
      <link href="2021/08/14/8-14/"/>
      <url>2021/08/14/8-14/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划-路径问题</title>
      <link href="2021/08/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/08/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode62-不同路径"><a href="#leetcode62-不同路径" class="headerlink" title="leetcode62.不同路径"></a>leetcode62.不同路径</h1><p>动态规划解法：定义f【i】【j】为达到位置【ij】的不同路径数量。</p><p>那么f【n- 1】【m-1】是最终答案，f【0】【0】=1，是一个起始条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//确定dp数组以及下标含义</span><br><span class="line">    //递推公式</span><br><span class="line">    //初始化</span><br><span class="line">    //遍历顺序</span><br><span class="line">    public static int uniquePaths(int m, int n)&#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if (i &gt; 0 &amp;&amp; j &gt; 0)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">                &#125;else if (i &gt; 0)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;else if (j &gt; 0)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：if和else if的关系和区别。</strong></p><p>总结：</p><p>​        如何确定是动态规划：从有无后效性入手，对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的，就是一个无后效性的问题。</p><p>​        状态定义：相当一部分的状态定义是和结尾、答案相关的</p><p>​        状态转移方程：对最后一步的分情况讨论。</p><p>​        对状态转移的要求：求最值要保证不漏、方案数确保不重不漏。</p><h1 id="leetcode64-最小路径和"><a href="#leetcode64-最小路径和" class="headerlink" title="leetcode64.最小路径和"></a>leetcode64.最小路径和</h1><p>给定一个包含非负整数的mn网格grid，请找出一条从左上角到右下角的路径，使得路径上的数字总和最小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        int m = grid.length, n = grid[0].length;</span><br><span class="line">        int[][] dp = new int[grid.length][grid[0].length];</span><br><span class="line">        dp[0][0] = grid[0][0];</span><br><span class="line">        for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for (int j = 0; j&lt; n; j++)&#123;</span><br><span class="line">                if (i &gt; 0 &amp;&amp; j &gt; 0)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j] + grid[i][j], dp[i][j - 1] + grid[i][j]);</span><br><span class="line">                &#125;else if (i &gt; 0)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] + grid[i][j];</span><br><span class="line">                &#125;else if (j &gt; 0)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 1] + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出总和最低的路径：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划-背包问题</title>
      <link href="2021/08/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>2021/08/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><p>​        有N件物品和一个最多能装重量为W的背包。第i件物品的重量是weight【i】，所对应的价值是value【i】。每件物品只能用一次，求解将这些物品装入背包里物品价值总和最大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-13</title>
      <link href="2021/08/13/8-13/"/>
      <url>2021/08/13/8-13/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-12</title>
      <link href="2021/08/12/8-12/"/>
      <url>2021/08/12/8-12/</url>
      
        <content type="html"><![CDATA[<h1 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h1><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例 1：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序的基石：硬件</title>
      <link href="2021/08/11/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%9F%B3%EF%BC%9A%E7%A1%AC%E4%BB%B6/"/>
      <url>2021/08/11/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E7%9F%B3%EF%BC%9A%E7%A1%AC%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU工作模式：执行程序的三种模式"><a href="#CPU工作模式：执行程序的三种模式" class="headerlink" title="CPU工作模式：执行程序的三种模式"></a>CPU工作模式：执行程序的三种模式</h1><p>CPU的工作模式：实模式、保护模式、长模式</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-11</title>
      <link href="2021/08/11/8-11/"/>
      <url>2021/08/11/8-11/</url>
      
        <content type="html"><![CDATA[<h1 id="446-等差数列划分-子序列"><a href="#446-等差数列划分-子序列" class="headerlink" title="446.等差数列划分-子序列"></a>446.等差数列划分-子序列</h1><p>给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。</p><p>如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p><p>例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。<br>再例如，[1, 1, 2, 5, 7] 不是等差序列。<br>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p><p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br>题目数据保证答案是一个 32-bit 整数。</p><p>示例 1：</p><p>输入：nums = [2,4,6,8,10]<br>输出：7<br>解释：所有的等差子序列为：<br>[2,4,6]<br>[4,6,8]<br>[6,8,10]<br>[2,4,6,8]<br>[4,6,8,10]<br>[2,4,6,8,10]<br>[2,6,10]<br>示例 2：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM极客时间</title>
      <link href="2021/08/10/JVM%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
      <url>2021/08/10/JVM%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="因素："><a href="#因素：" class="headerlink" title="因素："></a>因素：</h2><p>​        1.分配效率</p><p>​        2.回收效率</p><p>​        3.是否产生内存碎片</p><p>​        4.空间利用率</p><p>​        5.是否停顿，停顿时间是否可以接受</p><p>​        6.时间复杂度</p><p>​        7.实现的复杂度</p><h2 id="引用计数："><a href="#引用计数：" class="headerlink" title="引用计数："></a>引用计数：</h2><p>​        算法原理：统计每个对象被引用的次数，如果引用次数为0就释放该对象。实现简单，能立即回收无用内存。</p><p>​        存在的问题：在并发场景下，对应用计数的修改需要和对象指针的修改保证同步。需要加锁或者非常复杂的无锁算法。有时会引发连锁式的回收。无法有效解决循环引用。</p><h3 id="如何解决循环引用："><a href="#如何解决循环引用：" class="headerlink" title="如何解决循环引用："></a>如何解决循环引用：</h3><p>​        可以通过强、弱引用计数结合方式解决引用计数的循环引用问题。（android的智能指针就是这样实现的）。</p><p>​        智能指针：在binder源码中可以看到sp、wp类型的引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; result = new BpBinder(handle);</span><br><span class="line"></span><br><span class="line">wp&lt;IBinder&gt; result = new BpBinder(handle);</span><br></pre></td></tr></table></figure><p>在 Java 中我们不用关心对象的销毁及内存释放，GC 机制会自动辨别回收无用对象，而 「智能指针」 就是 native 层一个小型的 GC 实现。</p><p>智能指针以引用计数的方式来标识无用对象，使用智能指针的对象需继承自 RefBase，RefBase 中维护了此对象的强引用数量和弱引用数量。</p><p>强指针 sp 重载了 “=” 运算符，在引用其他对象时将强引用计数 +1，在 sp 析构函数中将强引用计数 -1，当强引用计数减至 0 时销毁引用的对象，这样就实现了对象的自动释放。</p><p>弱指针引用其他对象时将弱引用计数 +1，在 wp 析构函数中将弱引用计数 -1，当强引用计数为 0 时，不论弱引用计数是否为 0 都销毁引用的对象。</p><p><strong>如何解决循环引用问题</strong><br>只靠强引用计数方式，会存在循环引用的问题，导致对象永远无法被释放，弱引用就是专门用来解决循环引用问题的：</p><p>「若 A 强引用了 B，那 B 引用 A 时就需使用弱引用，当判断是否为无用对象时仅考虑强引用计数是否为 0，不关心弱引用计数的数量」</p><p>这样就解决了循环引用导致对象无法释放的问题，但这会引发野指针问题：当 B 要通过弱指针访问 A 时，A 可能已经被销毁了，那指向 A 的这个弱指针就变成野指针了。在这种情况下，就表示 A 确实已经不存在了，需要进行重新创建等其他操作</p><p><strong>智能指针自定义规则</strong><br>智能指针并不是固定的 “当强引用计数为 0 时，不论弱引用计数是否为 0 都销毁引用的对象” ，而是可以自定义规则。RefBase 提供了 extendObjectLifetime() 方法，可以用来设置引用计数器的规则，不同规则对删除目标对象的时机判断也是不一样的，包括以下三种规则：</p><p>OBJECT_LIFETIME_STRONG：只有在这个对象内存空间中的强计数器值为 0 的时候才会销毁对象</p><p>OBJECT_LIFETIME_WEAK：只有在这个对象内存空间中的强计数器和弱计数器的值都为 0 的时候才会销毁对象</p><p>OBJECT_LIFETIME_MASK：不管这两个计数器是不是都为 0，都不销毁对象，即与一般指针无异，还是要自己手动去释放对象</p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高频面试题</title>
      <link href="2021/08/10/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/08/10/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="TopK问题"><a href="#TopK问题" class="headerlink" title="TopK问题"></a>TopK问题</h1><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p><p>请实现 KthLargest 类：</p><p>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。<br>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p><p>示例：</p><p>输入：<br>[“KthLargest”, “add”, “add”, “add”, “add”, “add”]<br>[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]<br>输出：<br>[null, 4, 5, 5, 8, 8]</p><p>解释：<br>KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);<br>kthLargest.add(3);   // return 4<br>kthLargest.add(5);   // return 5<br>kthLargest.add(10);  // return 5<br>kthLargest.add(9);   // return 8<br>kthLargest.add(4);   // return 8</p><p>思路一：每次调用add的时候，先加入，再遍历k次，找到TopK值。</p><p>通过冒泡的方法寻找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class TOPK &#123;</span><br><span class="line">    int k;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    //构造函数</span><br><span class="line">    public TOPK()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public TOPK(int k, int[] nums)&#123;</span><br><span class="line">        this.k = k;</span><br><span class="line">        for (int num : nums)&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int add(int val)&#123;</span><br><span class="line">        list.add(val);</span><br><span class="line">        int cur = 0;</span><br><span class="line">        for (int i = 0; i &lt; k; i++)&#123;</span><br><span class="line">            int index = findMax(cur, list.size() - 1);</span><br><span class="line">            swap(cur, index);</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        return list.get(cur - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int findMax(int start, int end)&#123;</span><br><span class="line">        int ans = 0, max = Integer.MIN_VALUE;</span><br><span class="line">        for (int i = start; i &lt; end; i++)&#123;</span><br><span class="line">            int temp = list.get(i);</span><br><span class="line">            if (temp &gt; max)&#123;</span><br><span class="line">                max = temp;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int a, int b)&#123;</span><br><span class="line">        int c = list.get(a);</span><br><span class="line">        list.set(a, list.get(b));</span><br><span class="line">        list.set(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：用快排来代替冒泡排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TopK2 &#123;</span><br><span class="line">    int k;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public TopK2(int k, int[] nums)&#123;</span><br><span class="line">        this.k = k;</span><br><span class="line">        for (int num : nums)&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int add(int val)&#123;</span><br><span class="line">        list.add(val);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        return list.get(list.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路三：优先队列</p><p>使用一个大小为k的优先队列来存储 前k大的元素，其中优先队列的队头为队列中最小的元素，也就是第k大的元素。</p><p>在单次插入的操作中，我们首先将元素val加入到优先队列中。如果此时优先队列的大小大于k，需要将优先队列的队头元素弹出，以保证优先队列的大小为k。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TopK3 &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq;</span><br><span class="line">    int k;</span><br><span class="line"></span><br><span class="line">    public TopK3(int k, int[] nums) &#123;</span><br><span class="line">        this.k = k;</span><br><span class="line">        pq = new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int add(int val) &#123;</span><br><span class="line">        pq.offer(val);</span><br><span class="line">        if (pq.size() &gt; k) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：java中的优先队列PriprityQueue"><a href="#补充：java中的优先队列PriprityQueue" class="headerlink" title="补充：java中的优先队列PriprityQueue"></a>补充：java中的优先队列PriprityQueue</h2><p>​        java中的PriorityQueue通过二叉小顶堆实现，可以用一颗完全二叉树表示。</p><p>​        优先队列的作用是能保证每次取出的元素都是队列中权值最小的（java优先队列每次取最小元素，c++的优先队列每次取最大元素）。元素的大小可以通过元素本身的自然顺序，也可以通过构造时传入的比较器。</p><p>​        PriorityQueue实现了Queue接口，不允许放入null值。通过堆实现。具体来说是通过完全二叉树实现的小顶堆，可以通过数组作为PriorityQueue的底层实现。</p><p>​        add（）和offer（）：add(E e)<code>和</code>offer(E e)<code>的语义相同，都是向优先队列中插入元素，只是</code>Queue<code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回</code>false。</p><p>​        element（）和peek（）：element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。</p><p>​        remove（）和poll（）：remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p>​        remove（Object o）：remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可</p><p>\1. Java中的优先队列默认情况下是小顶堆，堆是一种完全二叉树的结构，底层是基于数组实现的，<code>parentIndexInArr = (nodeIndexInArr-1)/2</code></p><p>   \2. 小顶堆只要保证任意非叶子节点的值比起左右子树的值都要小即可。(和二叉搜索树不同，二叉搜索树要求左子树节点的值都要小于右子树所有节点的值)</p><p>  \3. 插入的时候要求符合完全二叉树，所以是从最右边的叶子节点插入，然后依次和partent比较大小，调整堆的结构。默认情况下使用的比较器是类似于(a,b) -&gt; a - b , a表示输入的元素，b表示已经存在的元素，按照siftUp()的扩及，如果a-b&gt;=0,程序就会break，a就不会继续再往堆顶移动了，所以是小顶堆。</p><p>  \4. 删除的时候根节点就是最小的位置，使用最右边的叶子节点替换根节点的值，然后逐层下面与左右孩子节点中较小的那个做交换，直到值小于等于左右孩子中任何一个为止。 </p><p>  \5. PriorityQueue的构造函数支持自定义比较器，如果你反转下比较的逻辑，它也可以是个大顶堆！</p><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><p>将两个升序链表合并为一个新的升序链表。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       if (l1 == null) return l2;    </span><br><span class="line">       if (l2 == null) return l1;</span><br><span class="line">               </span><br><span class="line">       ListNode dummy = new ListNode(0);</span><br><span class="line">       ListNode cur = dummy;</span><br><span class="line">       while (l1 != null &amp;&amp; l2 != null) &#123;</span><br><span class="line">           if (l1.val &lt; l2.val) &#123;</span><br><span class="line">               cur.next = l1;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               cur.next = l2;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       while (l1 != null) &#123;</span><br><span class="line">           cur.next = l1;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">           l1 = l1.next;</span><br><span class="line">       &#125;</span><br><span class="line">       while (l2 != null) &#123;</span><br><span class="line">           cur.next = l2;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">           l2 = l2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode dummy = new ListNode(0);</span><br><span class="line">       if (l1 == null &amp;&amp; l2 == null) return null;</span><br><span class="line">       if (l1 == null)&#123;</span><br><span class="line">           dummy.next = l2;</span><br><span class="line">           return dummy.next;</span><br><span class="line">       &#125;</span><br><span class="line">       if (l2 == null)&#123;</span><br><span class="line">           dummy.next = l1;</span><br><span class="line">           return dummy.next;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode l1Temp = l1, l2Temp = l2, dummyTemp = dummy;</span><br><span class="line">       /**</span><br><span class="line">        *遍历链表得到长度</span><br><span class="line">        */</span><br><span class="line">       int len1 = 0, len2 = 0;</span><br><span class="line">       while (l1Temp != null)&#123;</span><br><span class="line">           len1++;</span><br><span class="line">           l1Temp = l1Temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       while (l2Temp != null)&#123;</span><br><span class="line">           len2++;</span><br><span class="line">           l2Temp = l2Temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       while (l1 != null &amp;&amp; l2 != null)&#123;</span><br><span class="line">           if (l1.val &lt;= l2.val)&#123;</span><br><span class="line">               dummyTemp.next = new ListNode(l1.val);</span><br><span class="line">               dummyTemp = dummyTemp.next;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               dummyTemp.next = new ListNode(l2.val);</span><br><span class="line">               dummyTemp = dummyTemp.next;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (l1 != null)&#123;</span><br><span class="line">           dummyTemp.next = l1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (l2 != null)&#123;</span><br><span class="line">           dummyTemp.next = l2;</span><br><span class="line">       &#125;</span><br><span class="line">       return dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-10</title>
      <link href="2021/08/10/8-10/"/>
      <url>2021/08/10/8-10/</url>
      
        <content type="html"><![CDATA[<h1 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413.等差数列划分"></a>413.等差数列划分</h1><p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。<br>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。</p><p>子数组 是数组中的一个连续序列。</p><p>示例 1：</p><p>输入：nums = [1,2,3,4]<br>输出：3<br>解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。<br>示例 2：</p><p>输入：nums = [1]<br>输出：0</p><p>思路1：滑动窗口+单独判断函数</p><p>isOrNot是用来判断固定窗口内是否为等差数列。</p><p>另外要遍历固定窗口，窗口大小从【3-n】。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static int numberOfArithmeticSlices(int[] nums)&#123;</span><br><span class="line">       int ans = 0;</span><br><span class="line">       int length = nums.length;</span><br><span class="line">       for (int i = 3; i &lt;= length; i++)&#123;</span><br><span class="line">           int first = 0, end = i - 1;</span><br><span class="line">           while (end &lt;= length - 1)&#123;</span><br><span class="line">               if (isOrNot(nums, first, end))&#123;</span><br><span class="line">                   ans++;</span><br><span class="line">               &#125;</span><br><span class="line">               first++;</span><br><span class="line">               end++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static boolean isOrNot(int[] nums, int first, int end)&#123;</span><br><span class="line">       int cutNum = nums[first + 1] - nums[first];</span><br><span class="line">       for (int i = first; i &lt; end; i++)&#123;</span><br><span class="line">           if (nums[i + 1] - nums[i] != cutNum)&#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>优化：官方题解</p><p>如果求出了nums[i - 1]和nums[i]作为等差数列的最后两项的时候，答案增加的次数ti，可以快速求出ti+1。</p><p>如果nums[i]-nums[i +1]==d，在这一轮遍历中，j会遍历到与上一轮相同的位置，答案增加的次数相同，并且额外多了一个等差数列。</p><p>如果nums[i] - nums[i+1] != d,j从初始值i-1开始就会直接退出遍历，答案不会增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numberOfArithmeticSlices(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int d = nums[0] - nums[1], t = 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        // 因为等差数列的长度至少为 3，所以可以从 i=2 开始枚举</span><br><span class="line">        for (int i = 2; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i - 1] - nums[i] == d) &#123;</span><br><span class="line">                ++t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                d = nums[i - 1] - nums[i];</span><br><span class="line">                t = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路三：来源于宫水三叶大佬的双指针</p><p>具体：可以枚举i作为差值为d的子数组的左端点，然后通过双指针的方式找到当前等差并且最长的子数组的右端点j。所以区间长度为【i，j】为等差为d的子数组。</p><p>这个子数组符合条件的数量，为首项为1，末项为len - 3 +1，等差为1的等差数列，可以直接求出结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int numberOfArithmeticSlices(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n - 2; ) &#123;</span><br><span class="line">            int j = i, d = nums[i + 1] - nums[i];</span><br><span class="line">            while (j + 1 &lt; n &amp;&amp; nums[j + 1] - nums[j] == d) j++;</span><br><span class="line">            int len = j - i + 1;</span><br><span class="line">            // a1：长度为 len 的子数组数量；an：长度为 3 的子数组数量</span><br><span class="line">            int a1 = 1, an = len - 3 + 1;</span><br><span class="line">            // 符合条件（长度大于等于3）的子数组的数量为「差值数列求和」结果</span><br><span class="line">            int cnt = (a1 + an) * an / 2;</span><br><span class="line">            ans += cnt;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计数据结构</title>
      <link href="2021/08/09/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2021/08/09/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="实现栈（数组）"><a href="#实现栈（数组）" class="headerlink" title="实现栈（数组）"></a>实现栈（数组）</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-9</title>
      <link href="2021/08/09/8-9/"/>
      <url>2021/08/09/8-9/</url>
      
        <content type="html"><![CDATA[<h1 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313.超级丑数"></a>313.超级丑数</h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p><p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p><p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p><p>示例 1：</p><p>输入：n = 12, primes = [2,7,13,19]<br>输出：32<br>解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>示例 2：</p><p>输入：n = 1, primes = [2,3,5]<br>输出：1<br>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。</p><p>思路一：优先队列。丑数定义：1是最小的丑数，对于任意一个丑数x，其与给定质数数组primes的乘机，也是丑数。</p><p>​        步骤一：起始先将最小丑数1放入队列</p><p>​        步骤二：每次从队列取出最小值x，然后将x所对应的丑数x*primes[i]进行入队</p><p>​        步骤三：对步骤二循环多次，第n次出队就是结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int uglyNumber(int n, int[] primes)&#123;</span><br><span class="line">        Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class="line">        Set&lt;Long&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">        set.add(1L);</span><br><span class="line">        queue.add(1L);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            long temp = queue.poll();</span><br><span class="line">            if (i == n)&#123;</span><br><span class="line">                return (int)temp;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int prime : primes)&#123;</span><br><span class="line">                if (!set.contains(temp * prime))&#123;</span><br><span class="line">                    set.add(temp * prime);</span><br><span class="line">                    queue.add(temp * prime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>多路归并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int nthSuperUglyNumber(int n, int[] primes) &#123;</span><br><span class="line">        int m = primes.length;</span><br><span class="line">        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a,b)-&gt;a[0]-b[0]); </span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            q.add(new int[]&#123;primes[i], i, 0&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ans = new int[n];</span><br><span class="line">        ans[0] = 1;</span><br><span class="line">        for (int j = 1; j &lt; n; ) &#123;</span><br><span class="line">            int[] poll = q.poll();</span><br><span class="line">            int val = poll[0], i = poll[1], idx = poll[2];</span><br><span class="line">            if (val != ans[j - 1]) ans[j++] = val;</span><br><span class="line">            q.add(new int[]&#123;ans[idx + 1] * primes[i], i, idx + 1&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans[n - 1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="264-丑数"><a href="#264-丑数" class="headerlink" title="264.丑数"></a>264.丑数</h1><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p><p>示例 1：</p><p>输入：n = 10<br>输出：12<br>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。<br>示例 2：</p><p>输入：n = 1<br>输出：1<br>解释：1 通常被视为丑数。</p><p>思路：根据丑数的定义：1是最小的丑数、对于任意一个丑数x，与任意质因数（2/3/5）相乘，结果仍然是丑数。</p><p>解法一：优先队列（小根堆解法）</p><p>​        步骤一：起始先将最小丑数1放入队列</p><p>​        步骤二：每次从队列取出最小值x，然后将x所对应的丑数（和质因数相乘）进行入队。</p><p>​        步骤三：对步骤二循环多次，第n次出队的值就是答案。</p><p>为了防止同一丑数多次进队，使用数据结构set记录入过队列的丑数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public  static int uglyNumber(int n)&#123;</span><br><span class="line">        int[] primes = &#123;2,3,5&#125;;</span><br><span class="line">        Set&lt;Long&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class="line">        set.add(1L);</span><br><span class="line">        queue.add(1L);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            long x = queue.poll();</span><br><span class="line">            if (i == n)&#123;</span><br><span class="line">                return (int)x;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int prime : primes)&#123;</span><br><span class="line">                long temp = x * prime;</span><br><span class="line">                if (!set.contains(temp))&#123;</span><br><span class="line">                    set.add(temp);</span><br><span class="line">                    queue.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解法二：多路归并，三指针解法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int uglyNumber(int n)&#123;</span><br><span class="line">         int[] ans = new int[n + 1];</span><br><span class="line">         ans[1] = 1;</span><br><span class="line">         for (int i2 = 1, i3 = 1, i5 = 1, idx = 2; idx &lt;= n; idx++)&#123;</span><br><span class="line">             int a = ans[i2] * 2, b = ans[i3] * 3, c = ans[i5] * 5;</span><br><span class="line">             int min = Math.min(a, Math.min(b,c));</span><br><span class="line">             if (min == a) i2++;</span><br><span class="line">             if (min == b) i3++;</span><br><span class="line">             if (min == c) i5++;</span><br><span class="line">             ans[idx] = min;</span><br><span class="line">         &#125;</span><br><span class="line">         return ans[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-8</title>
      <link href="2021/08/08/8-8/"/>
      <url>2021/08/08/8-8/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-7</title>
      <link href="2021/08/08/8-7/"/>
      <url>2021/08/08/8-7/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-6</title>
      <link href="2021/08/08/8-6/"/>
      <url>2021/08/08/8-6/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-5</title>
      <link href="2021/08/05/8-5/"/>
      <url>2021/08/05/8-5/</url>
      
        <content type="html"><![CDATA[<h1 id="802-找到最终的安全状态"><a href="#802-找到最终的安全状态" class="headerlink" title="802.找到最终的安全状态"></a>802.找到最终的安全状态</h1><p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p><p>对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。</p><p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。</p><p>该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。</p><h2 id="思路：深度优先搜索和三色法标记。"><a href="#思路：深度优先搜索和三色法标记。" class="headerlink" title="思路：深度优先搜索和三色法标记。"></a>思路：深度优先搜索和三色法标记。</h2><p>特点：如果起始节点在一个环内，或者能够到达一个环，则该节点不是安全的。否则，该节点是安全的。我们可以用深度优先搜索来找环，并在深度优先搜索的时候，用三种颜色进行标记。</p><p>白色（用 00 表示）：该节点尚未被访问；<br>灰色（用 11 表示）：该节点位于递归栈中，或者在某个环上；<br>黑色（用 22 表示）：该节点搜索完毕，是一个安全节点。</p><p>当我们首次访问一个节点时，将其标记为灰色，并继续搜索与其相连的节点。</p><p>如果在搜索过程中遇到了一个灰色节点，则说明找到了一个环，此时退出搜索，栈中的节点仍保持为灰色，这一做法可以将「找到了环」这一信息传递到栈中的所有节点上。</p><p>如果搜索过程中没有遇到灰色节点，则说明没有遇到环，那么递归返回前，我们将其标记由灰色改为黑色，即表示它是一个安全的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; eventualSafeNodes(int[][] graph)&#123;</span><br><span class="line">       int n = graph.length;</span><br><span class="line">       int[] colors = new int[n];</span><br><span class="line">       List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">       for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">           if (safe(graph, colors, i))&#123;</span><br><span class="line">               list.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static boolean safe(int[][] graph, int[] colors, int x)&#123;</span><br><span class="line">       if (colors[x] &gt; 0)&#123;</span><br><span class="line">           return colors[x] == 2;</span><br><span class="line">       &#125;</span><br><span class="line">       colors[x] = 1;</span><br><span class="line">       for (int y : graph[x])&#123;</span><br><span class="line">           if (!safe(graph, colors, y)) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       colors[x] = 2;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊TCP</title>
      <link href="2021/08/04/%E7%9E%8E%E8%81%8ATCP/"/>
      <url>2021/08/04/%E7%9E%8E%E8%81%8ATCP/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>​         数据链路层协议：规定了电子信号如何组成数据包，解决了子网内部的点对点通信问题。但是不能解决多个局域网互通问题</p><p>​        网络层：IP协议定义了一套自己的地址，实现了路由功能。IP协议并不保证数据包的完整性。（依靠TCp协议，保证数据）</p><p>​        以太网数据包大小是固定的，最初是1518，后来增加到1522字节。其中1500字节是负载，22字节是头信息。</p><p>​        IP数据包在以太网数据包的负载里面，头信息最少需要20字节，所以IP数据包负载最多是1480字节。</p><p>​        TCP在IP数据包的负载里面，头信息最少需要20字节，TCP最大的负载1460.由于IP和TCP协议往往有额外的头信息，所以TCP负载实际为1400字节左右。</p><h2 id="TCP的服务"><a href="#TCP的服务" class="headerlink" title="TCP的服务"></a>TCP的服务</h2><p>​        TCP提供的是一种面向连接、可靠的字节流服务。</p><p>​        面向连接：使用TCP的应用，在彼此交换数据之前必须先建立一个TCP连接。</p><p>​        字节流服务：应用程序通过TCP连接交换8bit构成的一个字节，tcp不在字节流中插入记录标识符。</p><p>​        TCP不对字节流内容进行解释，由应用层进行解释。</p><h2 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h2><p>​        TCP数据被封装在一个数据报中。</p><img "" class="lazyload placeholder" data-original="/2021/08/04/%E7%9E%8E%E8%81%8ATCP/tcp1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="TCP首部" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/08/04/%E7%9E%8E%E8%81%8ATCP/tcp2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="TCP首部" style="zoom:200%;"><h4 id="TCP数据包编号（seq）"><a href="#TCP数据包编号（seq）" class="headerlink" title="TCP数据包编号（seq）"></a>TCP数据包编号（seq）</h4><p>​        TCP协议为每个包编号，以便接受的一方按照顺序还原。</p><h4 id="TCP数据包组装"><a href="#TCP数据包组装" class="headerlink" title="TCP数据包组装"></a>TCP数据包组装</h4><p>​        组装还原由操作系统完成。应用程序不会直接处理TCP数据包，应用程序需要的数据放在TCP数据包里面，有自己的格式。</p><p>​        TCP没有提供任何机制，表示原始文件的大小。大小由应用层的协议规定。</p><h4 id="慢启动和ACK"><a href="#慢启动和ACK" class="headerlink" title="慢启动和ACK"></a>慢启动和ACK</h4><p>​        慢启动：开始的时候发送的比较慢，根据丢包的情况，调整速率。</p><p>​        ACK携带两个信息：1、期待要收到下一个数据包的编号。2、接收方的接收窗口的剩余容量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习多线程2</title>
      <link href="2021/08/04/java%E5%A4%8D%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B2/"/>
      <url>2021/08/04/java%E5%A4%8D%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程上篇（一）"><a href="#多线程上篇（一）" class="headerlink" title="多线程上篇（一）"></a>多线程上篇（一）</h1>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化枚举的基本思路</title>
      <link href="2021/08/04/%E4%BC%98%E5%8C%96%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/"/>
      <url>2021/08/04/%E4%BC%98%E5%8C%96%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="优化枚举的基本思路"><a href="#优化枚举的基本思路" class="headerlink" title="优化枚举的基本思路"></a>优化枚举的基本思路</h1><p>整理自：宫水三叶大佬的lc题解。地址为：<a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-uttw/%E3%80%82">https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-uttw/。</a></p><h2 id="leetcode1074-元素和为目标值的子矩阵数量"><a href="#leetcode1074-元素和为目标值的子矩阵数量" class="headerlink" title="leetcode1074.元素和为目标值的子矩阵数量"></a>leetcode1074.元素和为目标值的子矩阵数量</h2><p>给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。</p><p>子矩阵 x1, y1, x2, y2 是满足 x1 &lt;= x &lt;= x2 且 y1 &lt;= y &lt;= y2 的所有单元 matrix[x][y] 的集合。</p><p>如果 (x1, y1, x2, y2) 和 (x1’, y1’, x2’, y2’) 两个子矩阵中部分坐标不同（如：x1 != x1’），那么这两个子矩阵也不同。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-4</title>
      <link href="2021/08/04/8-4/"/>
      <url>2021/08/04/8-4/</url>
      
        <content type="html"><![CDATA[<h1 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611.有效三角形的个数"></a>611.有效三角形的个数</h1><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p><p>示例 1:</p><p>输入: [2,2,3,4]<br>输出: 3<br>解释:<br>有效的组合是:<br>2,3,4 (使用第一个 2)<br>2,3,4 (使用第二个 2)<br>2,2,3</p><p>思路：对于正整数 a, b, ca,b,c，它们可以作为三角形的三条边，当且仅当：</p><p>a+b&gt;c、a+c&gt;b、b+c&gt;a，均成立。如果我们将三条边进行升序排序，当两条小边满足条件的（a + b &gt; c）的话，另外两个一定满足。</p><p>解法一：排序+三层暴力循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int triangleNumber(int[] nums)&#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            for (int j = i - 1; j&gt;= 0; j--)&#123;</span><br><span class="line">                for (int k = j - 1; k &gt;= 0; k--)&#123;</span><br><span class="line">                    if (nums[k] + nums[j] &gt; nums[i])&#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解法二：进行优化。要找符合条件的三元组，其中一个切入点，可以是【枚举三元组的两个值，然后优化第三个数的逻辑】。</p><p>在数组有序的前提下，当枚举到较大数下标i和次大树下标j的情况下，在[0，j）范围内找到符合条件的k的集合时，以符合条件的最小下标k为分割点的数轴上具有<strong>二段性。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int triangleNumber(int[] nums)&#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            for (int j = i - 1; j&gt;= 0; j--)&#123;</span><br><span class="line">            //寻找最后一位的时候，用二分法</span><br><span class="line">                int left = 0, right = j - 1;</span><br><span class="line">                while (left &lt; right)&#123;</span><br><span class="line">                    int mid = (left + right) / 2;</span><br><span class="line">                    if (nums[mid] + nums[j] &gt; nums[i])&#123;</span><br><span class="line">                        right = mid;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        left = mid + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (left == right &amp;&amp; nums[right] + nums[j] &gt;nums[i])&#123;</span><br><span class="line">                    ans = ans + j - right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>思路三：排序+双指针</p><p>当枚举最大数下标i的时候，在[0，i）范围内逐步减小下标，找次大下标j，符合条件的k必然是从0逐步递增。因为在[0   i）范围内通过双指针，以逐步减小下标的方式枚举j，并在遇到不满足条件的k时，增大k下标。从而找到所有符合条件三元组的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int triangleNumber(int[] nums)&#123;</span><br><span class="line">       int length = nums.length;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       int ans = 0;</span><br><span class="line">       for (int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">           for (int j = i - 1, k = 0; k &lt; j; j--)&#123;</span><br><span class="line">               while (k &lt; j &amp;&amp; nums[k] + nums[j] &lt;= nums[i])&#123;</span><br><span class="line">                   k++;</span><br><span class="line">               &#125;</span><br><span class="line">               ans = ans + j - k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-3</title>
      <link href="2021/08/04/8-3/"/>
      <url>2021/08/04/8-3/</url>
      
        <content type="html"><![CDATA[<h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581.最短无序连续子数组"></a>581.最短无序连续子数组</h1><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><p>示例 1：</p><p>输入：nums = [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>示例 2：</p><p>输入：nums = [1,2,3,4]<br>输出：0<br>示例 3：</p><p>输入：nums = [1]<br>输出：0</p><p>思路：赋值数组temp，并进行排序。只要找到无序数组的第一位和最后一位就好。注意一点，不能遍历把每一个不相同都自加一，因为无序数组中可能有一位位置并没有放错，所以需要找到第一位和最后一位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int findUnsortedSubarray(int[] nums)&#123;</span><br><span class="line">        int[] temp = new int[nums.length];</span><br><span class="line">        System.arraycopy(nums, 0, temp, 0, nums.length);</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        int first = 0, end = 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (temp[i] != nums[i])&#123;</span><br><span class="line">                first = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = nums.length - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">            if (temp[j] != nums[j])&#123;</span><br><span class="line">                end = j;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return end - first + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>思路二：双指针 + 线性扫描<br>另外一个做法是，我们把整个数组分成三段处理。</p><p>起始时，先通过双指针 ii 和 jj 找到左右两次侧满足 单调递增 的分割点。</p><p>即此时 [0, i][0,i] 和 [j, n)[j,n) 满足升序要求，而中间部分 (i, j)(i,j) 不确保有序。</p><p>然后我们对中间部分 [i, j][i,j] 进行遍历：</p><p>发现 nums[x] &lt; nums[i - 1]nums[x]&lt;nums[i−1]：由于对 [i, j][i,j] 部分进行排序后 nums[x]nums[x] 会出现在 nums[i - 1]nums[i−1] 后，将不满足整体升序，此时我们需要调整分割点 ii 的位置；<br>发现 nums[x] &gt; nums[j + 1]nums[x]&gt;nums[j+1]：由于对 [i, j][i,j] 部分进行排序后 nums[x]nums[x] 会出现在 nums[j + 1]nums[j+1] 前，将不满足整体升序，此时我们需要调整分割点 jj 的位置。<br>一些细节：在调整 ii 和 jj 的时候，我们可能会到达数组边缘，这时候可以建立两个哨兵：数组左边存在一个足够小的数，数组右边存在一个足够大的数。</p><p>来自大佬三叶，<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-e1le/">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-e1le/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int MIN = -100005, MAX = 100005;</span><br><span class="line">    public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int i = 0, j = n - 1;</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[i + 1]) i++;</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[j - 1]) j--;</span><br><span class="line">        int l = i, r = j;</span><br><span class="line">        int min = nums[i], max = nums[j];</span><br><span class="line">        for (int u = l; u &lt;= r; u++) &#123;</span><br><span class="line">            if (nums[u] &lt; min) &#123;</span><br><span class="line">                while (i &gt;= 0 &amp;&amp; nums[i] &gt; nums[u]) i--;</span><br><span class="line">                min = i &gt;= 0 ? nums[i] : MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[u] &gt; max) &#123;</span><br><span class="line">                while (j &lt; n &amp;&amp; nums[j] &lt; nums[u]) j++;</span><br><span class="line">                max = j &lt; n ? nums[j] : MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return j == i ? 0 : (j - 1) - (i + 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-2</title>
      <link href="2021/08/04/8-2/"/>
      <url>2021/08/04/8-2/</url>
      
        <content type="html"><![CDATA[<h1 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743.网络延迟时间"></a>743.网络延迟时间</h1><p>有 n 个网络节点，标记为 1 到 n。</p><p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-1</title>
      <link href="2021/08/04/8-1/"/>
      <url>2021/08/04/8-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1337-矩阵中战斗力最弱的K行"><a href="#1337-矩阵中战斗力最弱的K行" class="headerlink" title="1337.矩阵中战斗力最弱的K行"></a>1337.矩阵中战斗力最弱的K行</h1><p>给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p><p>请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。</p><p>如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。</p><p>军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p><p>示例 1：</p><p>输入：mat =<br>[[1,1,0,0,0],<br> [1,1,1,1,0],<br> [1,0,0,0,0],<br> [1,1,0,0,0],<br> [1,1,1,1,1]],<br>k = 3<br>输出：[2,0,3]<br>解释：<br>每行中的军人数目：<br>行 0 -&gt; 2<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 2<br>行 4 -&gt; 5<br>从最弱到最强对这些行排序后得到 [2,0,3,1,4]<br>示例 2：</p><p>输入：mat =<br>[[1,0,0,0],<br> [1,1,1,1],<br> [1,0,0,0],<br> [1,0,0,0]],<br>k = 2<br>输出：[0,2]<br>解释：<br>每行中的军人数目：<br>行 0 -&gt; 1<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 1<br>从最弱到最强对这些行排序后得到 [0,2,3,1]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int[] KWeakestRows(int[][] mat, int k)&#123;</span><br><span class="line">        int m = mat.length, n = mat[0].length;</span><br><span class="line"></span><br><span class="line">        int[][] all = new int[m][2];</span><br><span class="line">        for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int cur = 0;</span><br><span class="line">            for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                cur = cur + mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            all[i] = new int[]&#123;cur, i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(all, (a, b)-&gt;&#123;</span><br><span class="line">            if (a[0] != b[0]) return a[0] - b[0];</span><br><span class="line">            return a[1] - b[1];</span><br><span class="line">        &#125;);</span><br><span class="line">        int[] ans = new int[k];</span><br><span class="line">        for (int i = 0; i &lt; k; i++) ans[i] = all[i][1];</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-进程管理</title>
      <link href="2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程的概念："><a href="#进程的概念：" class="headerlink" title="进程的概念："></a>进程的概念：</h2><p>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。</p><p>为此引入了进程(Process)的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block, PCB)。</p><p>系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。</p><p>相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。</p><p>所谓创建进程，实质上是创建进程映像中的PCB；而撤销进程，实质上是撤销进程的PCB。</p><p>值得注意的是，进程映像是静态的，进程则是动态的。</p><p>注意：PCB是进程存在的唯一标志！</p><p>ps: 个人理解，PCB 只是对于进程的数据结构描述而已，就像 class 只是定义描述，创建的实体才是对象本身。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>从不同的角度，进程可以有不同的定义，比较典型的定义有：</p><ol><li>进程是程序的一次执行过程。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li></ol><p>在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：</p><blockquote><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><p>进程是系统分配资源的基本单位，线程是系统调度的基本单位。</p></blockquote><h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p>进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。</p><p>动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p><p>并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</p><p>独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。</p><p>异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。</p><p>结构性：每个进程都配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。</p><h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。</p><p>通常进程有以下五种状态，前三种是进程的基本状态。</p><p>\1) 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</p><p>\2) 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</p><p>\3) 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</p><p>\4) 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源；最后把该进程转入到就绪状态。</p><p>\5) 结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。</p><p>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</p><p>之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。</p><p>也就是说，<strong>进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的；而其他资源（如外设）的使用和分配或者某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少</strong>。</p><p>这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，很显然需要加以区分。</p><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/process.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="process" style="zoom:200%;"><p>就绪状态 -&gt; 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</p><p>运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p><p>运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p><p>阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>允许一个进程创建另一个进程。</p><p>此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。</p><p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。</p><h6 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h6><p>操作系统创建一个新进程的过程如下（创建原语)：</p><ol><li>为新进程分配一个唯一的进程标识号，并申请一个空白的PCB(PCB是有限的)。若PCB申请失败则创建失败。</li><li>为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在PCB 中体现）。注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于”等待状态“，或称为“阻塞状态”，等待的是内存这个资源。</li><li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li><li>如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。</li></ol><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。</p><p>异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。</p><p>外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p><h6 id="操作系统终止进程的过程如下（撤销原语）："><a href="#操作系统终止进程的过程如下（撤销原语）：" class="headerlink" title="操作系统终止进程的过程如下（撤销原语）："></a>操作系统终止进程的过程如下（撤销原语）：</h6><ol><li>根据被终止进程的标识符，检索PCB，从中读出该进程的状态。</li><li>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li><li>若该进程还有子进程，则应将其所有子进程终止。</li><li>将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。</li><li>将该PCB从所在队列（链表）中删除。</li></ol><h4 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。</p><p>可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p><h6 id="阻塞原语"><a href="#阻塞原语" class="headerlink" title="阻塞原语"></a>阻塞原语</h6><p>阻塞原语的执行过程是：</p><ol><li>找到将要被阻塞进程的标识号对应的PCB。</li><li>若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。</li><li>把该PCB插入到相应事件的等待队列中去。</li></ol><p>当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。</p><h6 id="唤醒原语"><a href="#唤醒原语" class="headerlink" title="唤醒原语"></a>唤醒原语</h6><p>唤醒原语的执行过程是：</p><ol><li>在该事件的等待队列中找到相应进程的PCB。</li><li>将其从等待队列中移出，并置其状态为就绪状态。</li><li>把该PCB插入就绪队列中，等待调度程序调度。</li></ol><p>需要注意的是，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。</p><p>Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的。</p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>对于通常的进程，其创建、撤销以及要求由系统设备完成的I/O操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。</p><p>进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。</p><h6 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h6><p>进程切换的过程如下：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。</p><p>如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的CPU现场，无需改变当前进程的环境信息。</p><p>但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p><h2 id="进程的组织：控制块、程序段和数据段"><a href="#进程的组织：控制块、程序段和数据段" class="headerlink" title="进程的组织：控制块、程序段和数据段"></a>进程的组织：控制块、程序段和数据段</h2><p>进程是操作系统的资源分配和独立运行的基本单位。</p><p>它一般由以下三个部分组成。</p><ol><li>进程控制块</li><li>程序段</li><li>数据段</li></ol><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>进程创建时，操作系统就新建一个PCB结构，它之后就常驻内存，任一时刻可以存取, 在进程结束时删除。</p><p>PCB是进程实体的一部分，是进程存在的唯一标志。</p><p>当创建一个进程时，系统为该进程建立一个PCB；当进程执行时，系统通过其 PCB 了 解进程的现行状态信息，以便对其进行控制和管理；当进程结束时，系统收回其PCB,该进程随之消亡。</p><p>操作系统通过PCB表来管理和控制进程。</p><ul><li>表  PCB通常包含的内容</li></ul><table><thead><tr><th align="left">进程描述信息 进程控制和管理信息 资源分配清单</th><th align="left">处理机相关信息</th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">进程标识符(PID)</td><td align="left">进程当前状态</td><td align="left">代码段指针</td><td align="left">通用寄存器值</td></tr><tr><td align="left">用户标识符(UID)</td><td align="left">进程优先级</td><td align="left">数据段指针</td><td align="left">地址寄存器值</td></tr><tr><td align="left"></td><td align="left">代码运行入口地址</td><td align="left">堆栈段指针</td><td align="left">控制寄存器值</td></tr><tr><td align="left"></td><td align="left">程序的外存地址</td><td align="left">文件描述符</td><td align="left">标志寄存器值</td></tr><tr><td align="left"></td><td align="left">进入内存时间</td><td align="left">键盘</td><td align="left">状态字</td></tr><tr><td align="left"></td><td align="left">处理机占用时间</td><td align="left">鼠标</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">信号量使用</td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="进程通信：见操作系统-进程间通信"><a href="#进程通信：见操作系统-进程间通信" class="headerlink" title="进程通信：见操作系统-进程间通信"></a>进程通信：见操作系统-进程间通信</h2><h1 id="线程的概念和多线程模型"><a href="#线程的概念和多线程模型" class="headerlink" title="线程的概念和多线程模型"></a>线程的概念和多线程模型</h1><h2 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h2><p>引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；</p><p>而<strong>引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p><p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。</p><p>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。</p><p>一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。</p><p>线程也有就绪、阻塞和运行三种基本状态。</p><p>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。</p><h2 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h2><p>\1) 调度。</p><p>在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>\2) 拥有资源。</p><p>不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），但线程可以访问其隶属进程的系统资源。</p><p>\3) 并发性。</p><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</p><p>\4) 系统开销。</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、 I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。</p><p>类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。</p><p>\5) 地址空间和其他资源（如打开的文件）</p><p>进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</p><p>\6) 通信方面</p><p>进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p><h2 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h2><p>在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是一个基本的可执行实体。</p><p>但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。</p><p>线程的主要属性如下：</p><ol><li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</li><li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程。</li><li>同一进程中的各个线程共享该进程所拥有的资源。</li><li>线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间。</li><li>一个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li></ol><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。</p><p>内核级线程又称为内核支持的线程。</p><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</p><p>应用程序可以通过使用线程库设计成多线程程序。</p><p>通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。</p><p>图2-2(a)说明了用户级线程的实现方式。</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。</p><p>内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。</p><p>图2-2(b)说明了内核级线程的实现方式。</p><p>在一些系统中，使用组合方式的多线程实现。</p><p>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。</p><p>图2-2(c)说明了用户级与内核级的组合实现方式。</p><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/xiancheng.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="用户级和内核级" style="zoom:200%;"><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>有些系统同时支持用户线程和内核线程由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p><h4 id="1-多对一模型"><a href="#1-多对一模型" class="headerlink" title="1) 多对一模型"></a>1) 多对一模型</h4><p>将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。</p><p>此模式中，用户级线程对操作系统不可见（即透明）。</p><p>优点：线程管理是在用户空间进行的，因而效率比较高。</p><p>缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。</p><h4 id="2-一对一模型"><a href="#2-一对一模型" class="headerlink" title="2) 一对一模型"></a>2) 一对一模型</h4><p>将每个用户级线程映射到一个内核级线程。</p><p>优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</p><p>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p><h4 id="3-多对多模型"><a href="#3-多对多模型" class="headerlink" title="3) 多对多模型"></a>3) 多对多模型</h4><p>将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。</p><p>特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</p><h2 id="进程调度的概念"><a href="#进程调度的概念" class="headerlink" title="进程调度的概念"></a>进程调度的概念</h2><h4 id="1-调度的基本概念"><a href="#1-调度的基本概念" class="headerlink" title="1. 调度的基本概念"></a>1. 调度的基本概念</h4><p>在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。</p><p>处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p><p>处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。</p><h4 id="2-调度的层次"><a href="#2-调度的层次" class="headerlink" title="2. 调度的层次"></a>2. 调度的层次</h4><p>一个作业从提交开始直到完成，往往要经历以下三级调度，如图2-4所示。</p><p>\1) 作业调度。</p><p>又称高级调度。其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。</p><p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</p><p>\2) 中级调度。</p><p>又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。</p><p>\3) 进程调度。</p><p>又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/processSchedulinig.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="processScheduling" style="zoom:200%;"><h4 id="3-三级调度的联系"><a href="#3-三级调度的联系" class="headerlink" title="3. 三级调度的联系"></a>3. 三级调度的联系</h4><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。</p><p>中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p><p>\1) 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</p><p>\2) 作业调度次数少，中级调度次数略多，进程调度频率最高。</p><p>\3) 进程调度是最基本的，不可或缺。</p><h2 id="调度的时机、切换与过程"><a href="#调度的时机、切换与过程" class="headerlink" title="调度的时机、切换与过程"></a>调度的时机、切换与过程</h2><p>进程调度和切换程序是操作系统内核程序。</p><p>当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。</p><p>理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。</p><h2 id="不能切换的场景"><a href="#不能切换的场景" class="headerlink" title="不能切换的场景"></a>不能切换的场景</h2><p>现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况。</p><p>\1) 在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</p><p>\2) 进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</p><p>\3) 其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</p><p>如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。</p><h2 id="应该切换的场景"><a href="#应该切换的场景" class="headerlink" title="应该切换的场景"></a>应该切换的场景</h2><p>应该进行进程调度与切换的情况有：</p><p>\1) 当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。</p><p>\2) 当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。</p><p>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。</p><p>现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。</p><p>内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p><h2 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h2><p>所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更髙的进程进入就绪队列，此时应如何分配处理机。</p><p>通常有以下两种进程调度方式：</p><p>\1) 非剥夺调度方式，又称非抢占方式。</p><p>是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。</p><p>在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</p><p>\2) 剥夺调度方式，又称抢占方式。</p><p>是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p><p>釆用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间片原则等。</p><h2 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h2><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。</p><h4 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h4><p>为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种：</p><p>\1) CPU利用率。</p><p>CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。</p><p>\2) 系统吞吐量。</p><p>表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。</p><p>而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p><p>\3) 周转时间。</p><p>是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。</p><p>作业的周转时间可用公式表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">周转时间 = 作业完成时间 - 作业提交时间</span><br></pre></td></tr></table></figure><p>平均周转时间是指多个作业周转时间的平均值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n</span><br></pre></td></tr></table></figure><p>带权周转时间是指作业周转时间与作业实际运行时间的比值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">带权周转时间 = 作业周转时间 / 作业实际运行时间</span><br></pre></td></tr></table></figure><p>平均带权周转时间是指多个作业带权周转时间的平均值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n</span><br></pre></td></tr></table></figure><p>\4) 等待时间。</p><p>是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。</p><p>\5) 响应时间。</p><p>是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。</p><p>从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p><p>要想得到一个满足所有用户和系统要求的算法几乎是不可能的。</p><p>设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统进程平均周转时间），同时还要考虑调度算法的开销。</p><h2 id="操作系统典型调度算法"><a href="#操作系统典型调度算法" class="headerlink" title="操作系统典型调度算法"></a>操作系统典型调度算法</h2><p>在操作系统中存在多种调度算法，其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。</p><p>下面介绍几种常用的调度算法。</p><h4 id="先来先服务-FCFS-调度算法"><a href="#先来先服务-FCFS-调度算法" class="headerlink" title="先来先服务(FCFS)调度算法"></a>先来先服务(FCFS)调度算法</h4><p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。</p><p>在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面通过一个实例来说明FCFS调度算法的性能。</p><p>假设系统中有4个作业，它们的提交时间分别是8、8.4、8.8、9，运行时间依次是2、1、0.5、0.2，系统釆用FCFS调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见表2-3。</p><ul><li>表 2-3 FCFS调度算法的性能</li></ul><table><thead><tr><th align="left">作业号</th><th align="left">提交时间</th><th align="left">运行时间</th><th align="left">开始时间</th><th align="left">等待时间</th><th align="left">完成时间</th><th align="left">周转时间</th><th align="left">带权周转时间</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">8</td><td align="left">2</td><td align="left">8</td><td align="left">0</td><td align="left">10</td><td align="left">2</td><td align="left">1</td></tr><tr><td align="left">2</td><td align="left">8.4</td><td align="left">1</td><td align="left">10</td><td align="left">1.6</td><td align="left">11</td><td align="left">2.6</td><td align="left">2.6</td></tr><tr><td align="left">3</td><td align="left">8.8</td><td align="left">0.5</td><td align="left">11</td><td align="left">2.2</td><td align="left">11.5</td><td align="left">2.7</td><td align="left">5.4</td></tr><tr><td align="left">4</td><td align="left">9</td><td align="left">0.2</td><td align="left">11.5</td><td align="left">2.5</td><td align="left">11.7</td><td align="left">2.7</td><td align="left">13.5</td></tr></tbody></table><p>平均等待时间 t = (0+1.6+2.2+2.5)/4=1.575</p><p>平均周转时间 T = (2+2.6+2.7+2.7)/4=2.5</p><p>平均带权周转时间 W = (1+2.6+5.牡13.5)/4=5.625</p><p>FCFS调度算法属于不可剥夺算法。</p><p>从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。</p><p>但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。</p><p>FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</p><h4 id="短作业优先-SJF-调度算法"><a href="#短作业优先-SJF-调度算法" class="headerlink" title="短作业优先(SJF)调度算法"></a>短作业优先(SJF)调度算法</h4><p>短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。</p><p>短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p><p>而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p><p>例如，考虑表2-3中给出的一组作业，若系统釆用短作业优先调度算法，其平均等待时间、平均周转时间和平均带权周转时间见表2-4。</p><ul><li>表2-4 SJF调度算法的性能</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/SJF.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="短作业优先" style="zoom:200%;"><p>平均等待时间 t = (0+2.3+1.4+1)/4=1.175</p><p>平均周转时间 T = (2+3.3+1.9+1.2)/4=2.1</p><p>平均带权周转时间 W = (1+3.3+3.8+6)/4=3.525</p><p>SJF调度算法也存在不容忽视的缺点：</p><p>该算法对长作业不利，由表2-3和表2-4可知，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。</p><p>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。</p><p>由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</p><p>注意，SJF调度算法的平均等待时间、平均周转时间最少。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。</p><p>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p><h6 id="是否抢占"><a href="#是否抢占" class="headerlink" title="是否抢占"></a>是否抢占</h6><p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：</p><p>非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。</p><p>剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。</p><h6 id="优先级是否变更"><a href="#优先级是否变更" class="headerlink" title="优先级是否变更"></a>优先级是否变更</h6><p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：</p><p>静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</p><p>动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</p><h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><p>高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。</p><p>在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p>响应比的变化规律可描述为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">响应比_RP = (等待时间 + 要求服务时间) / 要求服务时间;</span><br></pre></td></tr></table></figure><p>根据公式可知：</p><p>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</p><p>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</p><p>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</p><h4 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h4><p>时间片轮转调度算法主要适用于分时系统。</p><p>在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。</p><p>在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</p><p>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。</p><p>如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。</p><p>如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。</p><p>时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</p><h4 id="多级反馈队列调度算法（集合了前几种算法的优点）"><a href="#多级反馈队列调度算法（集合了前几种算法的优点）" class="headerlink" title="多级反馈队列调度算法（集合了前几种算法的优点）"></a>多级反馈队列调度算法（集合了前几种算法的优点）</h4><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，如图2-5 所示。</p><p>通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。</p><p>例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。</p><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/duojifankui.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="duojifankui" style="zoom:200%;"><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>多级反馈队列调度算法的实现思想如下：</p><p>（1）应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</p><p>（2）赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。</p><p>（3）当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</p><p>（4）仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>多级反馈队列的优势有：</p><p>终端型作业用户：短作业优先。</p><p>短批处理作业用户：周转时间较短。</p><p>长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。</p><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>作业调度方式分为 4 级</p><ul><li>作业调度</li><li>交换调度</li><li>进程调度</li><li>线程调度</li></ul><p><strong>作业调度（宏观调度、高级调度）</strong></p><ul><li>对外存输入井上的大量作业进行选择，对选择的作业分配资源，建立相应进程。作业执行完毕时，回收资源</li></ul><p><strong>交换调度（中级调度）</strong></p><ul><li>将处于<strong>外存交换区</strong>中的<strong>就绪状态</strong>或<strong>等待状态</strong>的进程调入<strong>内存</strong>，或把处于<strong>内存就绪状态</strong>或<strong>内存等待状态</strong>的进程交换到<strong>外存交换区</strong></li></ul><p><strong>进程调度（微观调度、低级调度）</strong></p><ul><li>选取一个处于就绪状态的进程占用处理机，之后，进行上下文切换以便建立与占用处理机进程相适应的执行环境</li></ul><p><strong>线程调度</strong></p><ul><li>选取一个处于就绪状态的线程进入执行状态</li></ul><h2 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h2><p>​        在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p><h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。</p><p>许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p><p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。</p><h2 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h2><p>为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：</p><p>进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</p><p>临界区。进程中访问临界资源的那段代码，又称临界段。</p><p>退出区。将正在访问临界区的标志清除。</p><p>剩余区。代码中的其余部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    entry section;  //进入区</span><br><span class="line">    critical section;  //临界区</span><br><span class="line">    exit section;  //退出区</span><br><span class="line">    remainder section;  //剩余区</span><br><span class="line">&#125; while (true)</span><br></pre></td></tr></table></figure><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。</p><p>进程间的直接制约关系就是源于它们之间的相互合作。</p><p>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥亦称间接制约关系。</p><p>当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。</p><h4 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h4><p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul><h2 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h2><h2 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h2><p>在进入区设置和检查一些标志来标明是否有进程在临界区中，如果已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p><h3 id="1-算法一：单标志法。"><a href="#1-算法一：单标志法。" class="headerlink" title="1) 算法一：单标志法。"></a>1) 算法一：单标志法。</h3><p>该算法设置一个公用整型变量turn,用于指示被允许进入临界区的进程编号，即若turn=0，则允许P0进程进入临界区。</p><p>该算法可确保每次只允许一个进程进入临界区。</p><p>但两个进程必须交替进入临界区，如果某个进程不再进入临界区了，那么另一个进程也将进入临界区（违背“空闲让进”）这样很容易造成资源利用的不充分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// P0进程</span><br><span class="line">while(turn!=0);</span><br><span class="line">critical section;</span><br><span class="line">turn=1;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// P1进程</span><br><span class="line">while(turn!=1);  // 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">turn = 0;  // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><h3 id="2-算法二：双标志法先检查。"><a href="#2-算法二：双标志法先检查。" class="headerlink" title="2) 算法二：双标志法先检查。"></a>2) 算法二：双标志法先检查。</h3><p>该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。</p><p>为此，设置了一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区，值为TRUE，表示Pi进程进入临界区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pi 进程</span><br><span class="line">while(flag[j]);  // ①    </span><br><span class="line">flag[i]=TRUE;  // ③  </span><br><span class="line">critical section;   </span><br><span class="line">flag[i] = FALSE; </span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pj 进程</span><br><span class="line">while(flag[i]);  // ② 进入区</span><br><span class="line">flag[j] =TRUE;  // ④ 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">flag[j] = FALSE;  // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><p>优点：不用交替进入，可连续使用；</p><p>缺点：Pi和Pj可能同时进入临界区。按序列①②③④ 执行时，会同时进入临界区（违背“忙则等待”)。即在检查对方flag之后和切换自己flag 之前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。</p><h3 id="3-算法三：双标志法后检查。"><a href="#3-算法三：双标志法后检查。" class="headerlink" title="3) 算法三：双标志法后检查。"></a>3) 算法三：双标志法后检查。</h3><p>算法二是先检测对方进程状态标志后，再置自己标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后，同时进入临界区。</p><p>为此，算法三釆用先设置自己标志为TRUE后,再检测对方状态标志，若对方标志为TURE，则进程等待；否则进入临界区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pi进程</span><br><span class="line">flag[i] =TRUE;</span><br><span class="line">while(flag[j]);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] =FLASE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pj进程</span><br><span class="line">flag[j] =TRUE;  // 进入区</span><br><span class="line">while(flag[i]);  // 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">flag [j] =FLASE;   // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><p>当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态（执行while语句），发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。</p><h3 id="4-算法四：Peterson’s-Algorithm。"><a href="#4-算法四：Peterson’s-Algorithm。" class="headerlink" title="4)算法四：Peterson’s Algorithm。"></a>4)算法四：Peterson’s Algorithm。</h3><p>为了防止两个进程为进入临界区而无限期等待，又设置变量turn，指示不允许进入临界区的进程编号，每个进程在先设置自己标志后再设置turn 标志，不允许另一个进程进入。</p><p>这时，再同时检测另一个进程状态标志和不允许进入标志，这样可以保证当两个进程同时要求进入临界区，只允许一个进程进入临界区。</p><p> [c]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pi进程</span><br><span class="line">flag[i]=TURE; turn=j;</span><br><span class="line">while(flag[j]&amp;&amp;turn==j); </span><br><span class="line">critical section;</span><br><span class="line">flag[i]=FLASE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p> [c]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pj进程</span><br><span class="line">flag[j] =TRUE;turn=i;  // 进入区</span><br><span class="line">while(flag[i]&amp;&amp;turn==i);   // 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">flag[j]=FLASE;  // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><p>本算法的基本思想是算法一和算法三的结合。</p><p>利用flag解决临界资源的互斥访问，而利用turn解决“饥饿”现象。</p><h2 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h2><p>本节对硬件实现的具体理解对后面的信号量的学习很有帮助。</p><p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。</p><p>通过硬件支持实现临界段问题的低级方法或称为元方法。</p><h3 id="1-中断屏蔽方法"><a href="#1-中断屏蔽方法" class="headerlink" title="1) 中断屏蔽方法"></a>1) 中断屏蔽方法</h3><p>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。</p><p>因为CPU只在发生中断时引起进程切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。</p><p>其典型模式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[plaintext]</span><br><span class="line">…</span><br><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。</p><p>对内核来说，当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。</p><h3 id="2-硬件指令方法"><a href="#2-硬件指令方法" class="headerlink" title="2) 硬件指令方法"></a>2) 硬件指令方法</h3><p>TestAndSet指令：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。</p><p>指令的功能描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean TestAndSet(boolean *lock)&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock=true;</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正被占用，初值为false。</p><p>在进程访问临界资源之前，利用TestAndSet检查和修改标志lock；若有进程在临界区，则重复检查，直到进程退出。</p><p>利用该指令实现进程互斥的算法描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while TestAndSet (&amp; 1ock);</span><br><span class="line">// 进程的临界区代码段;</span><br><span class="line">lock=false;</span><br><span class="line">// 进程的其他代码</span><br></pre></td></tr></table></figure><p>Swap指令：该指令的功能是交换两个字节的内容。</p><p>其功能描述如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Swap(boolean *a, boolean *b)&#123;  </span><br><span class="line">    boolean temp;</span><br><span class="line">    Temp=*a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：以上对TestAndSet和Swap指令的描述仅仅是功能实现，并非软件实现定义，事实上它们是由硬件逻辑直接实现的，不会被中断。</p><p>应为每个临界资源设置了一个共享布尔变量lock，初值为false；在每个进程中再设置一个局部布尔变量key，用于与lock交换信息。</p><p>在进入临界区之前先利用Swap指令交换lock 与key的内容，然后检查key的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。</p><p>利用Swap指令实现进程互斥的算法描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key=true;</span><br><span class="line">while(key!=false)</span><br><span class="line">Swap(&amp;lock, &amp;key); </span><br><span class="line">// 进程的临界区代码段；</span><br><span class="line">lock=false;</span><br><span class="line">// 进程的其他代码；</span><br></pre></td></tr></table></figure><p>硬件方法的优点：适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p><p>硬件方法的缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。</p><p>然而，多个进程的并发执行也带来了新的问题——死锁。</p><p>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><p>\1) 系统资源的竞争</p><p>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在 运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。</p><p>只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p><p>\2) 进程推进顺序非法</p><p>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。</p><p>例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都 会因为所需资源被占用而阻塞。</p><p>信号量使用不当也会造成死锁。</p><p>进程间彼此相互等待对方发来的消息，结果也会使得这些进程间无法继续向前推进。</p><p>例如，进程 A 等待进程B发的消息，进程 B 又在等待进程 A 发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</p><p>\3) 死锁产生的必要条件</p><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><p><strong>互斥条件：</strong>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><p><strong>不剥夺条件：</strong>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p><p><strong>请求和保持条件：</strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><p><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。</p><p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。</p><p>按死锁定义构成等待环所要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。</p><p>例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。</p><p>Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。因此循环等待只是死锁的必要条件。</p><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/xunhuandengdaihesisuo.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="循环等待和死锁" style="zoom:200%;"><p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1。但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。</p><h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><p>为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生， 但当死锁发生时能检测出死锁，并有能力实现恢复。</p><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁。</p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。</p><h4 id="死锁的检测及解除"><a href="#死锁的检测及解除" class="headerlink" title="死锁的检测及解除"></a>死锁的检测及解除</h4><p>无需釆取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后釆取某种措施解除死锁。</p><p>ps：这一种也是最常见的，比如数据库的各种死锁。</p><p>预防死锁和避免死锁都属于事先预防策略，但预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低；</p><p>避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p><p>死锁的几种处理策略的比较见表2-14。</p><ul><li>表2-14 死锁处理策略的比较</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/sisuo.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="死锁处理策略" style="zoom:200%;"><h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>防止死锁的发生只需破坏死锁产生的四个必要条件之一即可。</p><h4 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1) 破坏互斥条件"></a>1) 破坏互斥条件</h4><p>如果允许系统资源都能共享使用，则系统不会进入死锁状态。</p><p>但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。</p><p>所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p><h4 id="2-破坏不剥夺条件"><a href="#2-破坏不剥夺条件" class="headerlink" title="2) 破坏不剥夺条件"></a>2) 破坏不剥夺条件</h4><p>当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。</p><p>这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。</p><p>该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。</p><p>这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p><h4 id="3-破坏请求和保持条件"><a href="#3-破坏请求和保持条件" class="headerlink" title="3) 破坏请求和保持条件"></a>3) 破坏请求和保持条件</h4><p>釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p><p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p><h4 id="4-破坏循环等待条件"><a href="#4-破坏循环等待条件" class="headerlink" title="4) 破坏循环等待条件"></a>4) 破坏循环等待条件</h4><p>为了破坏循环等待条件，可釆用顺序资源分配法。</p><p>首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。</p><p>也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。</p><p>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使甩资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。</p><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>避免死锁同样是属于事先预防的策略，但并不是事先釆取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。</p><p>这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p><h4 id="1-系统安全状态"><a href="#1-系统安全状态" class="headerlink" title="1. 系统安全状态"></a>1. 系统安全状态</h4><p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。</p><p>所谓安全状态，是指系统能按某种进程推进顺序( P1, P2, …, Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, …, Pn 为安全序列。</p><p>如果系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见表2-15。</p><ul><li>表 2-15 资源分配</li></ul><table><thead><tr><th align="left">进程</th><th align="left">最大需求</th><th align="left">已分配</th><th align="left">可用</th></tr></thead><tbody><tr><td align="left">P1</td><td align="left">10</td><td align="left">5</td><td align="left">3</td></tr><tr><td align="left">P2</td><td align="left">4</td><td align="left">2</td><td align="left"></td></tr><tr><td align="left">P3</td><td align="left">9</td><td align="left">2</td><td align="left"></td></tr></tbody></table><p>则在T0时刻是安全的，因为存在一个安全序列P2、Pl、P3，即只要系统按此进程序列分配资源，则每个进程都能顺利完成。</p><p>若在T0时刻后，系统分配1台磁带机给P3，则此时系统便进入不安全状态，因为此时已无法再找到一个安全序列。</p><p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p><h4 id="2-银行家算法"><a href="#2-银行家算法" class="headerlink" title="2. 银行家算法"></a>2. 银行家算法</h4><p>银行家算法是最著名的死锁避免算法。</p><p>它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。</p><p>操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</p><p>当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。</p><p>若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p><p>\1) 数据结构描述</p><p>可利用资源矢量Available：含有m个元素的歎组，其中的每一个元素代表一类可用的资源数目。Available[j]=K，则表示系统中现有Rj类资源K个。</p><p>最大需求矩阵Max：为n*m矩阵，定义了系统中n个进程中的每一个进程对m类资源的最大需求。Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K。</p><p>分配矩阵Allocation：为n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。All0Cati0n[i, j]= K，则表示进程i当前已分得Rj类资源的数目为K。</p><p>需求矩阵Need：为n*m矩阵，表示每个进程尚需的各类资源数。Need[i, j]=K，则表示进程i还需要Rj类资源的数目为K。</p><p>上述三个矩阵间存在下述关系：</p><p>Need[i, j] = Max[i, j] - Allocation[i, j]</p><p>\2) 银行家算法描述</p><p>设Requesti是进程Pi的请求矢量，如果Requesti[j]K，表示进程Pi需要Rj类资源K个。当Pi发出资源请求后，系统按下述步骤进行检查：</p><p>①如果Requesti[j] &lt;= Need[i, j]，便转向步骤②；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p><p>②如果Requesti[j] &lt;= Available[j]，便转向步骤③;否则，表示尚无足够资源，Pi须等待。</p><p>③系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p><p> [c]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available[j] = Available[j] - Requesti[j];</span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Requesti[ j];</span><br><span class="line">Need[i, j] = Need[i, j] - Requesti[j];</span><br></pre></td></tr></table></figure><p>④系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p><p>\3) 安全性算法</p><p>①设置两个矢量。工作矢量Work；它表示系统可提供给进程继续运行所需的各类资源数目，它含有所个元素，在执行安全算法开始时，Work=Available; Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时 Finish[i]=false；当有足够资源分配给进程 Pi 时，再令 Finish[i]=true。</p><p>②从进程集合中找到一个能满足下述条件的进程：Finish[i]=false; Need[i, j]&lt;=Work[j]; 若找到，执行下一步骤，否则，执行步骤4。</p><p>③当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：</p><p> [c]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Work[j]=Work[j]+Allocation[i, j];</span><br><span class="line">Finish[i]=true;</span><br><span class="line">go to step &lt;2&gt;;</span><br></pre></td></tr></table></figure><p>④如果所有进程的Finish[i]=tme都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p><h4 id="银行家算法例子"><a href="#银行家算法例子" class="headerlink" title="银行家算法例子"></a>银行家算法例子</h4><p>假定系统中有5个进程{P0, P1, P2, P3, P4}和三类资源{A, B, C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况见表2-16。</p><p>\1) T0时刻的安全性。</p><p>利用安全性算法对T0时刻的资源分配进行分析，由表2-17可知，在T0时刻存在着一个安全序列{P1, P3, P4, P2, P0}，故系统是安全的。</p><ul><li>表 2-16 T0时刻的资源分配</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/bank1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="T0时刻的资源分配" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/bank2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="T0时刻的安全序列" style="zoom: 200%;"><p>\2) P1请求资源</p><p>P1发出请求矢量Request1(l，, 0, 2)，系统按银行家算法进行检查： Request1(1, 0, 2) &lt;= Need1(l, 2, 2)。 Request1(1, 0, 2) &lt;= Available1(3, 3, 2)。</p><p>系统先假定可为P1分配资源，并修改Available、Allocation1和Need1矢量，由此形成的资源变化情况见表2-18。</p><p>再利用安全性算法检查此时系统是否安全。</p><ul><li>表2-18 P1申请资源时的安全性检测</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/bank3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="P1申请资源时的安全性检测" style="zoom:150%;"><p>\3) P4请求资源</p><p>P4发出请求矢量Request4(3, 3, 0)，系统按银行家算法进行检查：</p><p>Request4(3, 3, 0) &lt;= Need4(4, 3, 1)。</p><p>Request4(3, 3, 0) &gt; Available(2, 3, 0)，让 P4 等待。</p><p>\4) P0请求资源</p><p>P0发出请求矢量Request0(0, 2, 0)，系统按银行家算法进行检查：</p><p>Request0(0, 2, 0) &lt;= Need0(7, 4, 3)。</p><p>Request0(0, 2, 0) &lt;= Available(2, 3, 0)。</p><p>系统暂时先假定可为P0分配资源，并修改有关数据，见表2-19。</p><ul><li>表2-19 为P0分配资源后的有关资源数据</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/bank4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="P0分配资源后的有关资源数据" style="zoom:200%;"><p>\5) 进行安全性检测。</p><p>可用资源Available(2, 1, 0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。</p><h2 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h2><p>前面绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不釆取任何措施，则应该提供死锁检测和解除的手段。</p><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>系统死锁，可利用资源分配图来描述。</p><p>如图2-17所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</p><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/resource.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="资源分配图" style="zoom:200%;"><p>在图2-17所示的资源分配图中，进程P1已经分得了两个R1资源，并又请求一个R2 资源；进程P2分得了一个R1和一个R2资源，并又请求一个R1资源。</p><h2 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h2><p>可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。</p><p>简化方法如下：</p><p>\1) 在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。</p><p>在图2-18(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到图2-18(b)所示的情况。</p><p>\2) 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图2-17中，进程P2就满足这样的条件。根据第1) 条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如图2-18(c)所示。</p><p>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理。</p><img "" class="lazyload placeholder" data-original="/2021/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/dingli.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="死锁定理" style="zoom:200%;"><h2 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h2><p>一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。</p><p>死锁解除的主要方法有：</p><p>\1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</p><p>\2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p><p>\3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://lgwain.gitbooks.io/os/content/unit11.html">https://lgwain.gitbooks.io/os/content/unit11.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-内存管理</title>
      <link href="2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>​        内存管理包括内存管理概念、交换与覆盖、连续分配管理方式和非连续分配管理方式（分页管理方式、分段管理方式、段页式管理方式）。</p><p>​        虚拟内存管理包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。</p><h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><p>内存管理(Memory Management)是操作系统设计中最重要和最复杂的内容之一。</p><p>虽然计算机硬件一直在飞速发展，内存容量也在不断增长，但是仍然不可能将所有用户进程和系统所需要的全部程序和数据放入主存中，所以操作系统必须将内存空间进行合理地划分和有效地动态分配。</p><p><strong>操作系统对内存的划分和动态分配，就是内存管理的概念。</strong></p><p>有效的内存管理在多道程序设计中非常重要，不仅方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。</p><h2 id="内存管理的功能："><a href="#内存管理的功能：" class="headerlink" title="内存管理的功能："></a>内存管理的功能：</h2><p>内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</p><p>地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</p><p>内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</p><p>存储保护：保证各道作业在各自的存储空间内运行，互不干扰。</p><p>在进行具体的内存管理之前，需要了解进程运行的基本原理和要求。</p><h2 id="程序的装入和链接："><a href="#程序的装入和链接：" class="headerlink" title="程序的装入和链接："></a>程序的装入和链接：</h2><p>创建进程首先要将程序和数据装入内存。</p><p>将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p><p>​        <strong>编译：</strong>由编译程序将用户源代码编译成若干个目标模块。</p><p>​        <strong>链接：</strong>由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。</p><p>​        <strong>装入：</strong>由装入程序将装入模块装入内存运行。</p><p>这三步过程如图所示。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/link.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="link" style="zoom:200%;"><h3 id="链接的方式"><a href="#链接的方式" class="headerlink" title="链接的方式"></a>链接的方式</h3><p>​        程序的链接有以下三种方式：</p><p>​        静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</p><p>​        装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，釆用边装入边链接的链接方式。</p><p>​        运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p><h3 id="装入模式"><a href="#装入模式" class="headerlink" title="装入模式"></a>装入模式</h3><p>内存的装入模块在装入内存时，同样有以下三种方式：</p><p>\1) 绝对装入。</p><p>在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。</p><p>绝对装入方式只适用于单道程序环境。另外，程序中所使用的绝对地址,可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中釆用的是符号地址，编译或汇编时再转换为绝对地址。</p><p>\2) 可重定位装入。</p><p>在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的,此时应釆用可重定位装入方式。</p><p>根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位，如图(a)所示。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/putin.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="input" style="zoom:200%;"><p>​        静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。</p><p>​        此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间。</p><p>\3) 动态运行时装入，也称为动态重定位，程序在内存中如果发生移动，就需要釆用动态的装入方式。</p><p>​        装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。</p><p>​        因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持，如图(b)所示。</p><p>​        动态重定位的特点是可以将程序分配到不连续的存储区中；在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p><h2 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h2><p>​        编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址（或逻辑地址)。</p><p>​        当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。</p><p>​        用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，它们只有系统编程人员才会涉及。</p><p>​        不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。</p><p>​        物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。</p><p>​        当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。</p><h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p><p>通过釆用重定位寄存器和界地址寄存器来实现这种保护。</p><p>重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址值。</p><p>每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如图3-3所示。</p><p>当CPU调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每一个逻辑地址都需要与这两个寄存器进行核对，以保证操作系统和其他用户程序及数据不被该进程的运行所影响。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/protect.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="protect" style="zoom:200%;"><h1 id="内存覆盖与内存交换"><a href="#内存覆盖与内存交换" class="headerlink" title="内存覆盖与内存交换"></a>内存覆盖与内存交换</h1><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。</p><h2 id="内存覆盖"><a href="#内存覆盖" class="headerlink" title="内存覆盖"></a>内存覆盖</h2><p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。</p><p>覆盖的基本思想是：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。</p><p>将经常活跃的部分放在固定区，其余部分按调用关系分段。</p><p>首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</p><p>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。</p><h2 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h2><p>交换（对换）的基本思想是，把处于等待状态（或在CPU调度原则下被剥夺运行权利） 的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；</p><p>把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。</p><p>第2章介绍的中级调度就是釆用交换技术。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例如，有一个CPU釆用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。</p><p>同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。</p><p>理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>有关交换需要注意以下几个问题：</p><ul><li>交换需要备份存储，通常是快速磁盘。它必须足够大，并且提供对这些内存映像的直接访问。</li><li>为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所交换的内存空间成正比。</li><li>如果换出进程，必须确保该进程是完全处于空闲状态。</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。</li><li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。</li><li>普通的交换使用不多，但交换策略的某些变种在许多系统中（如UNIX系统）仍发挥作用。</li></ul><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。</p><p>由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p><h1 id="内存连续分配管理方式"><a href="#内存连续分配管理方式" class="headerlink" title="内存连续分配管理方式"></a>内存连续分配管理方式</h1><p>连续分配方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。</p><h2 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h2><p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。</p><p>这种方式无需进行内存保护。</p><p>这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。</p><p>缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</p><h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。</p><p>当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/memory.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="3-4固定分区分配的两种方法" style="zoom:200%;"><p>固定分区分配在划分分区时，有两种不同的方法，如图3-4所示。</p><p>分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。</p><p>分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</p><p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配），如图3-5(a)所示。</p><p>当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为”已分配”；未找到合适分区则拒绝为该用户程序分配内存。存储空间的分配情况如图3-5(b)所示。</p><p>这种分区方式存在两个问题：一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间；二是主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为内部碎片。</p><p>固定分区是可用于多道程序设计最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。</p><ul><li>图3-5 固定分区说明表和内存分配情况</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/memory1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="3-5固定分区说明表和内存分配情况" style="zoom:200%;"><h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。</p><p>这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。</p><p>因此系统中分区的大小和数目是可变的。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dynamic.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="dynamic" style="zoom:200%;"><p>如图3-6所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。</p><p>开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下4MB，进程4无法装入。</p><p>在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。</p><p>由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。之后CPU又出现空闲，而主存无法容纳进程2,操作系统就换出进程1，换入进程2。</p><p>动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。</p><p>随着时间的推移，内存中会产生越来越多的碎片（图3-6中最后的4MB和中间的6MB，且随着进程的换入/换出，很可能会出现更多更小的内存块)，内存的利用率随之下降。这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。</p><p>克服外部碎片可以通过紧凑（Compaction)技术来解决，就是操作系统不时地对进程进行移动和整理。</p><p>但是这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。</p><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：</p><p><strong>首次适应(First Fit)算法：</strong>空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</p><p><strong>最佳适应(Best Fit)算法：</strong>空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。</p><p><strong>最坏适应(Worst Fit)算法：</strong>又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</p><p><strong>邻近适应(Next Fit)算法：</strong>又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。</p><p>在这几种方法中，首次适应算法不仅是最简单的，而且通常也是最好和最快的。</p><p>在UNIX 系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组的数据结构 (而非链表）来实现。</p><p>不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</p><p>邻近适应算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配)，分裂成小碎片。它通常比首次适应算法的结果要差。</p><p>最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，它会产生最多的外部碎片。</p><p>最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，因此性能也非常差。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/test.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="test" style="zoom:200%;"><p>以上三种内存分区管理方法，用户进程在主内中都是连续存放的。</p><p>​    <code>**内部碎片:</code>分配给某进程的内存区域中，有些部分没有用上。**</p><p>​    <strong><code>外部碎片:</code>是指内存中的某些空闲分区由于太小而难以利用。</strong></p><h1 id="内存非连续分配管理方式"><a href="#内存非连续分配管理方式" class="headerlink" title="内存非连续分配管理方式"></a>内存非连续分配管理方式</h1><p>非连续分配允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为<strong>分页存储管理方式和分段存储管理方式</strong>。</p><p><strong>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。</strong></p><p>下面介绍基本分页存储管理方式。</p><h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><p>固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。</p><p>我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。</p><p>每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p>分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。</p><p>但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。</p><p>这样，<strong>进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）</strong>。</p><h3 id="1-分页存储的几个基本概念"><a href="#1-分页存储的几个基本概念" class="headerlink" title="1) 分页存储的几个基本概念"></a>1) 分页存储的几个基本概念</h3><p>①页面和页面大小。进程中的块称为页(Page)，内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</p><p>为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到耷间效率和时间效率的权衡。</p><p>②地址结构。分页存储管理的逻辑地址结构如图3-7所示。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="3-7分页存储管理的地址结构" style="zoom:200%;"><p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32 位，其中0<del>11位为页内地址，即每页大小为4KB；12</del>31位为页号，地址空间最多允许有220页。</p><p>③页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。</p><p>在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。</p><p>可见，页表的作用是<strong>实现从页号到物理块号的地址映射</strong>，如图3-8所示。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page_table.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="3-8页表的作用" style="zoom:200%;"><h3 id="2-基本地址变换机构"><a href="#2-基本地址变换机构" class="headerlink" title="2) 基本地址变换机构"></a>2) 基本地址变换机构</h3><p>地址变换机构的任务是将逻辑地址转换为内存中物理地址，地址变换是借助于页表实现的。图3-9给出了分页存储管理系统中的地址变换机构。</p><ul><li>图 3-9 分页存储管理的地址变换机构</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/translate.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="分页存储管理的地址变换机构" style="zoom:200%;"><p>在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的始址F和页表长度M。</p><p>进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ol><li>计算页号P(P=A/L)和页内偏移量W (W=A%L)。</li><li>比较页号P和页表长度M，若P &gt;= M，则产生越界中断，否则继续执行。</li><li>页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。</li><li>计算E=b*L+W，用得到的物理地址E去访问内存。</li></ol><p>以上整个地址变换过程均是由硬件自动完成的。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>例如，若页面大小L为1K字节，页号2对应的物理块为b=8，计算逻辑地址A=2500 的物理地址E的过程如下：P=2500/1K=2，W=2500%1K=452，查找得到页号2对应的物理块的块号为 8，E=8*1024+452=8644。</p><p>下面讨论分页管理方式存在的两个主要问题：</p><p>（1）每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；</p><p>（2）每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</p><h3 id="3-具有快表的地址变换机构"><a href="#3-具有快表的地址变换机构" class="headerlink" title="3) 具有快表的地址变换机构"></a>3) 具有快表的地址变换机构</h3><p>由上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：一次是访问页表，确定所存取的数据或指令的物理地址，第二次才根据该地址存取数据或指令。</p><p>显然，这种方法比通常执行指令的速度慢了一半。</p><p>为此，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器——快表，又称联想寄存器(TLB)，用来存放当前访问的若干页表项，以加速地址变换的过程。</p><p>与此对应，主存中的页表也常称为慢表，配有快表的地址变换机构如图3-10所示。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/fast_translate.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="具有快表的地址变换机构" style="zoom:200%;"><p>在具有快表的分页机制中，地址的变换过程：</p><ol><li>CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。</li><li>如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li></ol><p>注意：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。</p><p>一般快表的命中率可以达到90%以上，这样，分页带来的速度损失就降低到10%以下。</p><p>快表的有效性是基于著名的局部性原理，这在后面的虚拟内存中将会具体讨论。</p><h3 id="4-两级页表"><a href="#4-两级页表" class="headerlink" title="4) 两级页表"></a>4) 两级页表</h3><p>第二个问题：由于引入了分页管理，进程在执行时不需要将所有页调入内存页框中，而只要将保存有映射关系的页表调入内存中即可。但是我们仍然需要考虑页表的大小。</p><p>以32 位逻辑地址空间、页面大小4KB、页表项大小4B为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要220，约100万个页表项。也就是说，每个进程仅页表这一项就需要4MB主存空间，这显然是不切实际的。</p><p>而即便不考虑对全部逻辑地址空间进行映射的情况，一个逻辑地址空间稍大的进程，其页表大小也可能是过大的。以一个40MB的进程为例，页表项共40KB,如果将所有页表项内容保存在内存中，那么需要10个内存页框来保存整个页表。整个进程大小约为1万个页面，而实际执行时只需要几十个页面进入内存页框就可以运行，但如果要求10个页面大小的页表必须全部进入内存，这相对实际执行时的几十个进程页面的大小来说，肯定是降低了内存利用率的；从另一方面来说，这10页的页表项也并不需要同时保存在内存中，因为大多数情况下，映射所需要的页表项都在页表的同一个页面中。</p><p>将页表映射的思想进一步延伸，就可以得到二级分页：将页表的10页空间也进行地址映射，建立上一级页表，用于存储页表的映射关系。这里对页表的10个页面进行映射只需要10个页表项，所以上一级页表只需要1页就足够（可以存储210=1024个页表项）。在进程执行时，只需要将这1页的上一级页表调入内存即可，进程的页表和进程本身的页面，可以在后面的执行中再i周入内存。</p><p>如图3-11所示，这是Intel处理器80x86系列的硬件分页的地址转换过程。在32位系统中，全部32位逻辑地址空间可以分为220(4GB/4KB)个页面。这些页面可以再进一步建立顶级页表，需要210个顶级页表项进行索引，这正好是一页的大小，所以建立二级页表即可。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/table_two.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="二级页表" style="zoom:200%;"><p>​        举例，32位系统中进程分页的工作过程：假定内核已经给一个正在运行的进程分配的逻辑地址空间是0x20000000到0x2003FFFF，这个空间由64个页面组成。在进程运行时，我们不需要知道全部这些页的页框的物理地址，很可能其中很多页还不在主存中。这里我们只注意在进程运行到某一页时，硬件是如何计算得到这一页的页框的物理地址即可。现在进程需要读逻辑地址0x20021406中的字节内容，这个逻辑地址按如下进行处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址： 0x20021406 (0010 0000 0000 0010 0001 0100 0000 0110 B) </span><br><span class="line">顶级页表字段：0x80 (00 1000 0000 B) </span><br><span class="line">二级页表字段：0x21 (00 0010 0001B) </span><br><span class="line">页内偏移量字段：0x406 (0100 0000 0110 B)</span><br></pre></td></tr></table></figure><p>顶级页表字段的0x80用于选择顶级页表的第0x80表项，此表项指向和该进程的页相关的二级页表；二级页表字段0x21用于选择二级页表的第0x21表项，此表项指向包含所需页的页框；最后的页内偏移量字段0x406用于在目标页框中读取偏移量为0x406中的字节。</p><p>这是32位系统下比较实际的一个例子。</p><p>看似较为复杂的例子，有助于比较深入地理解，希望读者能自己动手计算一遍转换过程。</p><p>建立多级页表的目的在于建立索引，这样不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项，而建立索引的要求是最高一级页表项不超过一页的大小。</p><p>在64位操作系统中，页表的划分则需要重新考虑，这是很多教材和辅导书中的常见题目，但是很多都给出了错误的分析，需要注意。</p><p>我们假设仍然釆用4KB页面大小。偏移量字段12位，假设页表项大小为8B。</p><p>这样，其上一级分页时，每个页框只能存储29(4KB/8B)个页表项，而不再是210个，所以上一级页表字段为9位。后面同理继续分页。64=12+9+9+9+9+9+7，所以需6级分页才能实现索引。很多书中仍然按4B页表项分析，虽然同样得出6级分页的结果，但显然是错误的。</p><p>这里给出两个实际的64位操作系统的分页级别（注意：里面没有使用全部64位寻址，不过由于地址字节对齐的设计考虑，仍然使用8B大小的页表项），理解了表3-2中的分级方式，相信对多级分页就非常清楚了。</p><ul><li>表 两种系统的分级方式</li></ul><table><thead><tr><th align="left">平台</th><th align="left">页面大小</th><th align="left">寻址位数</th><th align="left">分页级数</th><th align="left">具体分级</th></tr></thead><tbody><tr><td align="left">Alpha</td><td align="left">8KB</td><td align="left">43</td><td align="left">3</td><td align="left">13+10+10+10</td></tr><tr><td align="left">X86_64</td><td align="left">4 KB</td><td align="left">48</td><td align="left">4</td><td align="left">12+9+9+9+9</td></tr></tbody></table><h1 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h1><p>分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；</p><p>而分段管理方式的提出则是<strong>考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要</strong>。</p><h2 id="1-分段。"><a href="#1-分段。" class="headerlink" title="1) 分段。"></a>1) 分段。</h2><p>段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。</p><p>其逻辑地址由段号S与段内偏移量W两部分组成。</p><p>在图3-12中，段号为16位，段内偏移量为16位，则一个作业最多可有216=65536个段，最大段长为64KB。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="segment" style="zoom:200%;"><p>​        在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在髙级程序设计语言中，这个工作由编译程序完成。</p><h2 id="2-段表。"><a href="#2-段表。" class="headerlink" title="2) 段表。"></a>2) 段表。</h2><p>每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度。</p><p>段表的内容如图3-13所示。</p><ul><li>图 3-13 段表项</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">| 段号 | 段长| 本段在主存的起始地址 |</span><br></pre></td></tr></table></figure><p>在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区。</p><p>可见，段表用于实现从逻辑段到物理内存区的映射，如图3-14所示。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment_table.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="segment_table" style="zoom:200%;"><h2 id="3-地址变换机构。"><a href="#3-地址变换机构。" class="headerlink" title="3) 地址变换机构。"></a>3) 地址变换机构。</h2><p>分段系统的地址变换过程如图3-15所示。</p><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。其从逻辑地址A到物理地址E之间的地址变换过程如下：</p><ol><li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</li><li>比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。</li><li>段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行。</li><li>取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。</li></ol><ul><li>图3-15 分段系统的地址变换过程</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment_tanslate.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="分段系统地址变换过程" style="zoom:200%;"><h2 id="4-段的共享与保护。"><a href="#4-段的共享与保护。" class="headerlink" title="4) 段的共享与保护。"></a>4) 段的共享与保护。</h2><p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。</p><p>当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（它不属于临界资源)，这样的代码和不能修改的数据是可以共享的，而可修改的代码和数据则不能共享。</p><p>与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。</p><p>地址越界保护是利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断；再利用段表项中的段长和逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。</p><h1 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h1><p>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。</p><p>如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。</p><p>在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。</p><p>对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位，如图3-16所</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment_page.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="segment_table" style="zoom:200%;"><p>在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量，如图3-17 所示。</p><p> [plaintext]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 段号S | 页号P | 页内偏移量 W |</span><br></pre></td></tr></table></figure><p>为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表。</p><p>段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。</p><p>注意：在一个进程中，段表只有一个，而页表可能有多个。</p><p>在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。</p><p>如图3-18所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p><img "" class="lazyload placeholder" data-original="./操作系统-内存管理//segment_table_translate.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="段页式系统地址变换机构" style="zoom:200%;"><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h1 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h1><p>上一节所讨论的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。它们都具有以下两个共同的特征：</p><h2 id="1-一次性"><a href="#1-一次性" class="headerlink" title="1) 一次性"></a>1) 一次性</h2><p>作业必须一次性全部装入内存后，方能开始运行。这会导致两种情况发生：</p><p>当作业很大，不能全部被装入内存时，将使该作业无法运行；</p><p>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</p><h2 id="2-驻留性"><a href="#2-驻留性" class="headerlink" title="2) 驻留性"></a>2) 驻留性</h2><p>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待I/O而被阻塞，可能处于长期等待状态。</p><p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p><h1 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h1><p>要真正理解虚拟内存技术的思想，首先必须了解计算机中著名的局部性原理。</p><p>著名的 Bill Joy (SUN公司CEO)说过：”在研究所的时候，我经常开玩笑地说高速缓存是计算机科学中唯一重要的思想。事实上，髙速缓存技术确实极大地影响了计算机系统的设计。“快表、 页高速缓存以及虚拟内存技术从广义上讲，都是属于高速缓存技术。这个技术所依赖的原理就是局部性原理。局部性原理既适用于程序结构，也适用于数据结构（更远地讲，Dijkstra 著名的关于“goto语句有害”的论文也是出于对程序局部性原理的深刻认识和理解）。</p><h2 id="时间与空间"><a href="#时间与空间" class="headerlink" title="时间与空间"></a>时间与空间</h2><p>局部性原理表现在以下两个方面：</p><p>时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</p><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</p><p><strong>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。</strong></p><p><strong>空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</strong></p><p>虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h1 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h1><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。</p><p>另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。</p><p>这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</p><p>之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。</p><h2 id="存储器的特征"><a href="#存储器的特征" class="headerlink" title="存储器的特征"></a>存储器的特征</h2><p>虚拟存储器的大小由计算机的地址结构决定，并非是内存和外存的简单相加。虚拟存储器有以下三个主要特征：</p><p>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。</p><p>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</p><p>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</p><h1 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h1><p>虚拟内存中，允许将一个作业分多次调入内存。</p><p>釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。</p><p>因此，虚拟内存的实需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p><ol><li>请求分页存储管理。</li><li>请求分段存储管理。</li><li>请求段页式存储管理。</li></ol><h2 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h2><p>不管哪种方式，都需要有一定的硬件支持。</p><p>一般需要的支持有以下几个方面：</p><p>一定容量的内存和外存。</p><p>页表机制（或段表机制），作为主要的数据结构。</p><p>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</p><p>地址变换机构，逻辑地址到物理地址的变换。</p><h1 id="请求分页管理方式实现虚拟内存"><a href="#请求分页管理方式实现虚拟内存" class="headerlink" title="请求分页管理方式实现虚拟内存"></a>请求分页管理方式实现虚拟内存</h1><p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。</p><p>请求分页是目前最常用的一种实现虚拟存储器的方法。</p><p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。</p><p>在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。</p><p>为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。</p><h2 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h2><p>请求分页系统的页表机制不同于基本分页系统，请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存的情况，如何发现和处理这种情况是请求分页系统必须解决的两个基本问题。</p><p>为此，在请求页表项中增加了四个字段，如图3-24所示。</p><ul><li>图3-24 请求分页系统中的页表项</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/pagesystem.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="请求分页系统中的页表项" style="zoom:200%;"><p>增加的四个字段说明如下：</p><p>状态位P：用于指示该页是否已调入内存，供程序访问时参考。</p><p>访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近己有多长时间未被访问，供置换算法换出页面时参考。</p><p>修改位M：标识该页在调入内存后是否被修改过。</p><p>外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</p><h2 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h2><p>在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。</p><p>此时应将缺页的进程阻塞（调页完成唤醒)，如果内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存)。</p><p>缺页中断作为中断同样要经历，诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。</p><p>但与一般的中断相比，它有以下两个明显的区别：</p><p>在指令执行期间产生和处理中断信号，而非一条指令执行完后，属于内部中断。</p><p>一条指令在执行期间，可能产生多次缺页中断。</p><h2 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h2><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的。</p><ul><li>图3-25请求分页中的地址变换过程</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/translatesystem.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="请求分页中的地址变换" style="zoom:200%;"><p>在进行地址变换时，先检索快表：</p><ol><li>若找到要访问的页，便修改页表项中的访问位（写指令则还须重置修改位)，然后利用页表项中给出的物理块号和页内地址形成物理地址。</li><li>若未找到该页的页表项，应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。</li></ol><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><h1 id="页面置换算法-1"><a href="#页面置换算法-1" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。</p><p>选择调出页面的算法就称为页面置换算法。</p><p>好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。</p><p>常见的置换算法有以下四种。</p><h1 id="1-最佳置换算法-OPT"><a href="#1-最佳置换算法-OPT" class="headerlink" title="1. 最佳置换算法(OPT)"></a>1. 最佳置换算法(OPT)</h1><p>最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。</p><p>但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p><p>最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</span><br></pre></td></tr></table></figure><p>进程运行时，先将7, 0, 1三个页面依次装入内存。</p><p>进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。</p><p>然后，访问页面0时，因为已在内存中所以不必产生缺页中断。</p><p>访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。</p><p>可以看到，发生缺页中断的次数为9，页面置换的次数为6。</p><ul><li>图3-26 利用最佳置换算法时的置换图</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/change.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="最佳置换算法" style="zoom:200%;"><h1 id="先进先出-FIFO-页面置换算法"><a href="#先进先出-FIFO-页面置换算法" class="headerlink" title="先进先出(FIFO)页面置换算法"></a>先进先出(FIFO)页面置换算法</h1><p>优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。</p><p>该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。</p><p>但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p><ul><li>图 3-27 利用FIFO置换算法时的置换图</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FIFO.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="先进先出页面置换算法" style="zoom:200%;"><p>这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。</p><p>由图 3-27可以看出，利用FIFO算法时进行了 12次页面置换，比最佳置换算法正好多一倍。</p><p>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</p><ul><li>图 3-28 Belady 异常</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Belady.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Belady异常" style="zoom:200%;"><h1 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h1><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。</p><p>该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p><p>再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。</p><p>进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。</p><ul><li>图3-29 LRU页面置换算法时的置换图</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/LRU.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="LRU页面置换算法" style="zoom:200%;"><p>在图3-29中，前5次置换的情况与最佳置换算法相同，但两种算法并无必然联系。</p><p>实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。</p><p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。</p><p>理论上可以证明，堆栈类算法不可能出现Belady异常。</p><p>FIFO算法基于队列实现，不是堆栈类算法。</p><h1 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h1><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。</p><p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。</p><h2 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h2><p>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。</p><p>当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。</p><p>对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。</p><p>当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。</p><p>每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。</p><p>由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p><h2 id="改进型的-clock-算法"><a href="#改进型的-clock-算法" class="headerlink" title="改进型的 clock 算法"></a>改进型的 clock 算法</h2><p>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。</p><p>这样，每一帧都处于以下四种情况之一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> [plaintext]</span><br><span class="line">最近未被访问，也未被修改(u=0, m=0)。</span><br><span class="line">最近被访问，但未被修改(u=1, m=0)。</span><br><span class="line">最近未被访问，但被修改(u=0, m=1)。</span><br><span class="line">最近被访问，被修改(u=1, m=1)。</span><br></pre></td></tr></table></figure><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>算法执行如下操作步骤：</p><p>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。</p><p>如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。</p><p>如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</p><p>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p><h1 id="页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面"><a href="#页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面" class="headerlink" title="页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面"></a>页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面</h1><h2 id="驻留集大小"><a href="#驻留集大小" class="headerlink" title="驻留集大小"></a>驻留集大小</h2><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。</p><p>也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：</p><ol><li>分配给一个进程的存储量越小，在任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。</li><li>如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。</li><li>如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li></ol><p>基于这些因素，现代操作系统通常釆用三种策略：</p><p>（1）固定分配局部置换。</p><p>它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p><p>实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。</p><p>（2）可变分配全局置换。</p><p>这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。</p><p>当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。</p><p>（3）可变分配局部置换。</p><p>它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。</p><p>如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度；</p><p>反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p><h2 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h2><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：</p><p>（1）预调页策略。</p><p>根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。</p><p>但如果调入的一批页面中大多数都未被访问，则又是低效的。</p><p>所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。</p><p>但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。</p><p>（2）请求调页策略。</p><p>进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。</p><p>由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。</p><p>它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。</p><h2 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h2><p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。</p><p>对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故对换区的磁盘I/O速度比文件区的更快。</p><p>这样从何处调入页面有三种情况：</p><p>（1）系统拥有足够的对换区空间：</p><p>可以全部从对换区调入所需页面，以提髙调页速度。</p><p>为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</p><p>（2）系统缺少足够的对换区空间：</p><p>凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。</p><p>但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。</p><p>（3）UNIX方式：</p><p>与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。</p><p>曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。</p><h1 id="页面抖动-颠簸-和工作集-驻留集"><a href="#页面抖动-颠簸-和工作集-驻留集" class="headerlink" title="页面抖动(颠簸)和工作集(驻留集)"></a>页面抖动(颠簸)和工作集(驻留集)</h1><h2 id="页面抖动（颠簸）"><a href="#页面抖动（颠簸）" class="headerlink" title="页面抖动（颠簸）"></a>页面抖动（颠簸）</h2><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。</p><p>如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。</p><p>虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。</p><p>但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p><h2 id="工作集（驻留集）"><a href="#工作集（驻留集）" class="headerlink" title="工作集（驻留集）"></a>工作集（驻留集）</h2><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。</p><p>经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><p>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。</p><p>如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p><p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://lgwain.gitbooks.io/os/content/unit11.html">https://lgwain.gitbooks.io/os/content/unit11.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统--进程间通信</title>
      <link href="2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能相互访问的，但是内核空间是每个进程共享的，所以进程之间通信都必须通过内核。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/core.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="core" style="zoom:200%;"><h2 id="管道："><a href="#管道：" class="headerlink" title="管道："></a>管道：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux中的命令   【|】这个竖线</span><br><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure><p>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</p><p>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p><p>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure><p>myPipe 就是这个管道的名称，基于 <strong>Linux 一切皆文件的理念</strong>，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">prw-r--r--. 1 root  root</span><br></pre></td></tr></table></figure><p>接下来，我们往 myPipe 这个管道写入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello&quot; &gt; myPipe  // 将数据写进管道</span><br><span class="line">                         // 停住了 ...</span><br></pre></td></tr></table></figure><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; myPipe  // 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p><p>我们可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p><h4 id="管道原理："><a href="#管道原理：" class="headerlink" title="管道原理："></a>管道原理：</h4><p>匿名管道的创建，需要通过下面这个系统调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init pipe（int fd[2]）</span><br></pre></td></tr></table></figure><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/pipe.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="pipe" style="zoom:200%;"><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/fork.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="fork" style="zoom:200%;"><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/fork_pipe.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="fork_pipe.png" style="zoom:200%;"><p>所以说如果需要双向通信，则应该创建两个管道。</p><p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shell.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="shell" style="zoom:200%;"><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><h4 id="管道的实质"><a href="#管道的实质" class="headerlink" title="管道的实质"></a>管道的实质</h4><p>​        管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><h4 id="管道的局限"><a href="#管道的局限" class="headerlink" title="管道的局限"></a>管道的局限</h4><p>只支持单向数据流；</p><p>只能用于具有亲缘关系的进程之间；</p><p>没有名字；</p><p>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</p><p>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</p><p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><p><strong>消息队列特点总结：</strong><br> （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br> （2）消息队列允许一个或多个进程向它写入与读取消息.<br> （3）管道和消息队列的通信数据都是先进先出的原则。<br> （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br> （5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br> （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p><hr><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/share_memory.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="share_memory" style="zoom:200%;"><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/PV.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="pv" style="zoom:200%;"><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p><p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 <code>0</code>。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/pv2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="pv2" style="zoom:200%;"><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p><p><strong>信号量与互斥量之间的区别：</strong><br> （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br> <strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br> <strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br> 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。、</p><h4 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h4><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><h4 id="信号生命周期和处理流程"><a href="#信号生命周期和处理流程" class="headerlink" title="信号生命周期和处理流程"></a>信号生命周期和处理流程</h4><p>（1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br> （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/singleLife.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="singleLife" style="zoom:200%;"><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocal)</span><br></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li><li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM  表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li><li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>接下来，简单说一下这三种通信的编程模式。</p><h4 id="针对TCP协议通信的socket编程模型"><a href="#针对TCP协议通信的socket编程模型" class="headerlink" title="针对TCP协议通信的socket编程模型"></a>针对TCP协议通信的socket编程模型</h4><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/tcp_socket.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="tcp_socket" style="zoom:200%;"><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h4 id="针对UDP协议通信的socket编程模型"><a href="#针对UDP协议通信的socket编程模型" class="headerlink" title="针对UDP协议通信的socket编程模型"></a>针对UDP协议通信的socket编程模型</h4><img "" class="lazyload placeholder" data-original="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/udp_socket.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="udp_socket" style="zoom:200%;"><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p><h4 id="针对本地进程间通信的socket编程模型"><a href="#针对本地进程间通信的socket编程模型" class="headerlink" title="针对本地进程间通信的socket编程模型"></a>针对本地进程间通信的socket编程模型</h4><p>本地 socket  被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p><p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p><p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p><ul><li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li><li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487290&amp;idx=2&amp;sn=4f2e3ea64cf2686c9b7f49a33621cd74&amp;chksm=9bd7f132aca07824352ce2a732122927eb8e5d4919e741b457de14643ac4afab63397cdb309f&amp;scene=126&amp;sessionid=1601022514&amp;key=dab8500b28863cd4fa272fb6ab15b7262dc45238026d39c0f6b1808f3f4b3e755b3e2e86a347378b7b88a1d790be1ce8bc8d279fd5e49191f6d61eefcbd976e2474e8c49516c4a0d92d709c06f50a726c42556be70b80098490d6905645d1ec6b270d127d528c46bb8eab21c6da43b941999cab8ad3183e62b17600b9beec3ca&amp;ascene=1&amp;uin=Mjk4NzM0OTE0MA==&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=ART8oJJqbvwbJssZZs4K+Ak=&amp;pass_ticket=j5yqM9hyuG9Adkgj5cxYregFgIBNGLglupnegUJmXuhjtGZqMV98ABCh0Wh6HQ08&amp;wx_header=0">https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487290&amp;idx=2&amp;sn=4f2e3ea64cf2686c9b7f49a33621cd74&amp;chksm=9bd7f132aca07824352ce2a732122927eb8e5d4919e741b457de14643ac4afab63397cdb309f&amp;scene=126&amp;sessionid=1601022514&amp;key=dab8500b28863cd4fa272fb6ab15b7262dc45238026d39c0f6b1808f3f4b3e755b3e2e86a347378b7b88a1d790be1ce8bc8d279fd5e49191f6d61eefcbd976e2474e8c49516c4a0d92d709c06f50a726c42556be70b80098490d6905645d1ec6b270d127d528c46bb8eab21c6da43b941999cab8ad3183e62b17600b9beec3ca&amp;ascene=1&amp;uin=Mjk4NzM0OTE0MA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=ART8oJJqbvwbJssZZs4K%2BAk%3D&amp;pass_ticket=j5yqM9hyuG9Adkgj5cxYregFgIBNGLglupnegUJmXuhjtGZqMV98ABCh0Wh6HQ08&amp;wx_header=0</a></p><p><a href="http://blog.chinaunix.net/uid-26833883-id-3227144.html">http://blog.chinaunix.net/uid-26833883-id-3227144.html</a></p><p><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p><p><a href="https://link.jianshu.com/?t=http://blog.csdn.net/yang_yulei/article/details/19772649">https://link.jianshu.com/?t=http://blog.csdn.net/yang_yulei/article/details/19772649</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-31</title>
      <link href="2021/07/31/7-31/"/>
      <url>2021/07/31/7-31/</url>
      
        <content type="html"><![CDATA[<h1 id="987-二叉树的垂序排列（困难）"><a href="#987-二叉树的垂序排列（困难）" class="headerlink" title="987.二叉树的垂序排列（困难）"></a>987.二叉树的垂序排列（困难）</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-30</title>
      <link href="2021/07/31/7-30/"/>
      <url>2021/07/31/7-30/</url>
      
        <content type="html"><![CDATA[<h1 id="171-excel表列序号"><a href="#171-excel表列序号" class="headerlink" title="171.excel表列序号"></a>171.excel表列序号</h1><p>给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。</p><p>例如，</p><pre><code>A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ...</code></pre><p>示例 1:</p><p>输入: columnTitle = “A”<br>输出: 1<br>示例 2:</p><p>输入: columnTitle = “AB”<br>输出: 28<br>示例 3:</p><p>输入: columnTitle = “ZY”<br>输出: 701<br>示例 4:</p><p>输入: columnTitle = “FXSHRXW”<br>输出: 2147483647</p><p>思路：进制转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int titleToNumber(String s) &#123;</span><br><span class="line">       char[] cs = s.toCharArray();</span><br><span class="line">       int n = cs.length;</span><br><span class="line">       int ans = 0;</span><br><span class="line">       for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">           ans = ans * 26 + (cs[i] - &#x27;A&#x27; + 1);</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-29</title>
      <link href="2021/07/29/7-29/"/>
      <url>2021/07/29/7-29/</url>
      
        <content type="html"><![CDATA[<h1 id="1104-二叉树寻路"><a href="#1104-二叉树寻路" class="headerlink" title="1104.二叉树寻路"></a>1104.二叉树寻路</h1><p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。</p><p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p><p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; pathInZigZagTree(int label) &#123;</span><br><span class="line">        int row = 1, rowStart = 1;</span><br><span class="line">        while (rowStart * 2 &lt;= label) &#123;</span><br><span class="line">            row++;</span><br><span class="line">            rowStart *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (row % 2 == 0) &#123;</span><br><span class="line">            label = getReverse(label, row);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        while (row &gt; 0) &#123;</span><br><span class="line">            if (row % 2 == 0) &#123;</span><br><span class="line">                path.add(getReverse(label, row));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path.add(label);</span><br><span class="line">            &#125;</span><br><span class="line">            row--;</span><br><span class="line">            label &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(path);</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getReverse(int label, int row) &#123;</span><br><span class="line">        return (1 &lt;&lt; row - 1) + (1 &lt;&lt; row) - 1 - label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-28</title>
      <link href="2021/07/29/7-28/"/>
      <url>2021/07/29/7-28/</url>
      
        <content type="html"><![CDATA[<h1 id="863-二叉树中所有距离为K的节点"><a href="#863-二叉树中所有距离为K的节点" class="headerlink" title="863.二叉树中所有距离为K的节点"></a>863.二叉树中所有距离为K的节点</h1><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p><p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 根据数据范围最多有 501 个点，每个点最多有 2 条无向边（两个子节点）</span><br><span class="line">    int N = 510, M = N * 4;</span><br><span class="line">    int[] he = new int[N], e = new int[M], ne = new int[M];</span><br><span class="line">    int idx;</span><br><span class="line">    void add(int a, int b) &#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = he[a];</span><br><span class="line">        he[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean[] vis = new boolean[N];</span><br><span class="line">    public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode t, int k) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.fill(he, -1);</span><br><span class="line">        dfs(root);</span><br><span class="line">        Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();</span><br><span class="line">        d.addLast(t.val);</span><br><span class="line">        vis[t.val] = true;</span><br><span class="line">        while (!d.isEmpty() &amp;&amp; k &gt;= 0) &#123;</span><br><span class="line">            int size = d.size();</span><br><span class="line">            while (size-- &gt; 0) &#123;</span><br><span class="line">                int poll = d.pollFirst();</span><br><span class="line">                if (k == 0) &#123;</span><br><span class="line">                    ans.add(poll);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int i = he[poll]; i != -1 ; i = ne[i]) &#123;</span><br><span class="line">                    int j = e[i];</span><br><span class="line">                    if (!vis[j]) &#123;</span><br><span class="line">                        d.addLast(j);</span><br><span class="line">                        vis[j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        if (root.left != null) &#123;</span><br><span class="line">            add(root.val, root.left.val);</span><br><span class="line">            add(root.left.val, root.val);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.right != null) &#123;</span><br><span class="line">            add(root.val, root.right.val);</span><br><span class="line">            add(root.right.val, root.val);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习笔记JVM</title>
      <link href="2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/"/>
      <url>2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>​        JVM内存结构：java代码是运行在虚拟机上的，虚拟机在执行java程序的过程会把所管理的内存划分为若干个不同的数据区域。</p><p>知识体系：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/jvm-overview.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="JVM" style="zoom:200%;"><h1 id="java复习JVM"><a href="#java复习JVM" class="headerlink" title="java复习JVM"></a>java复习JVM</h1><p>学习要点：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jvm-overview.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java" style="zoom:200%;"><h1 id="JVM基础-类字节码"><a href="#JVM基础-类字节码" class="headerlink" title="JVM基础-类字节码"></a>JVM基础-类字节码</h1><p>源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行。</p><h2 id="多语言编译为字节码在JVM上运行："><a href="#多语言编译为字节码在JVM上运行：" class="headerlink" title="多语言编译为字节码在JVM上运行："></a>多语言编译为字节码在JVM上运行：</h2><p>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</p><p>JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jvm-class-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jvm-class-1" style="zoom:200%;"><h6 id="Java字节码文件："><a href="#Java字节码文件：" class="headerlink" title="Java字节码文件："></a>Java字节码文件：</h6><p>class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。Class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。</p><h6 id="Class文件的结构属性："><a href="#Class文件的结构属性：" class="headerlink" title="Class文件的结构属性："></a>Class文件的结构属性：</h6><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jvm-class-2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jvm-class-2" style="zoom:200%;"><p>​        常量池可以理解成Class文件中的资源仓库。主要存放的是两大类常量：字面量(Literal)和符号引用(Symbolic References)。字面量类似于java中的常量概念，如文本字符串，final常量等，而符号引用则属于编译原理方面的概念，包括以下三种:</p><ul><li>类和接口的全限定名(Fully Qualified Name)</li><li>字段的名称和描述符号(Descriptor)</li><li>方法的名称和描述符</li></ul><p>不同于C/C++, JVM是在加载Class文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。</p><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><h2 id="类的生命周期："><a href="#类的生命周期：" class="headerlink" title="类的生命周期："></a>类的生命周期：</h2><p>​        类加载的过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，*而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)*。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java_jvm_classload_2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java_jvm_classload_2" style="zoom:200%;"><h6 id="加载阶段：查找并加载类的二进制数据"><a href="#加载阶段：查找并加载类的二进制数据" class="headerlink" title="加载阶段：查找并加载类的二进制数据"></a>加载阶段：查找并加载类的二进制数据</h6><p>​        通过一个类的全限定名来获取其定义的二进制字节流。</p><p>​        将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>​        在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java_jvm_classload_1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java_jvm_classload_1" style="zoom:200%;"><p>​        相对于类加载的其他阶段而言，<em>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>​        加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>​        类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p>加载class文件的方式：</p><ul><li>本地系统直接加载</li></ul><ul><li>通过网络下载class文件</li></ul><ul><li>从zip，jar等归档文件中加载class文件</li></ul><ul><li>从专有数据库中提取class文件</li></ul><ul><li>将java源文件动态编译为class文件</li></ul><h6 id="连接–验证：确保被加载的类的正确性"><a href="#连接–验证：确保被加载的类的正确性" class="headerlink" title="连接–验证：确保被加载的类的正确性"></a>连接–验证：确保被加载的类的正确性</h6><p>​        验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:</p><ul><li><code>文件格式验证</code>: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><code>元数据验证</code>: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><code>符号引用验证</code>: 确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p></blockquote><h6 id="连接–准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#连接–准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="连接–准备：为类的静态变量分配内存，并将其初始化为默认值"></a>连接–准备：为类的静态变量分配内存，并将其初始化为默认值</h6><p>​        准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意:</p><ul><li><p>这时候进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p></li><li><p>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p><p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p></li><li><p>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</p></li><li><p>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</p></li><li><p>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</p></li><li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</p></li><li><p>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</p></li></ul><h6 id="连接–解析：把类中的符号引用转换为直接引用"><a href="#连接–解析：把类中的符号引用转换为直接引用" class="headerlink" title="连接–解析：把类中的符号引用转换为直接引用"></a>连接–解析：把类中的符号引用转换为直接引用</h6><p>​        解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p><code>    直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h6 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h6><p>​        初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>JVM初始化步骤</strong></p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.pdai.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul><h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>类访问方法区内的数据结构的接口，对象是Heap区的数据。</p><h6 id="卸载：java虚拟机将结束生命周期的几种情况"><a href="#卸载：java虚拟机将结束生命周期的几种情况" class="headerlink" title="卸载：java虚拟机将结束生命周期的几种情况"></a>卸载：java虚拟机将结束生命周期的几种情况</h6><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致java虚拟机进程终止</li></ul><h2 id="类加载器、JVM类加载机制"><a href="#类加载器、JVM类加载机制" class="headerlink" title="类加载器、JVM类加载机制"></a>类加载器、JVM类加载机制</h2><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java_jvm_classload_3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java_jvm_classload_3" style="zoom:200%;"><p>以上加载器不是通过继承关系实现的，而是组合关系。</p><p>​        <strong>站在Java虚拟机的角度来讲</strong>，只存在两种不同的类加载器: 启动类加载器: 它使用C++实现(这里仅限于<code>Hotspot</code>，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p>​        <strong>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类</strong> :</p><p><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</p><p><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</p><p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul><h2 id="类的加载：类加载的三种方式"><a href="#类的加载：类加载的三种方式" class="headerlink" title="类的加载：类加载的三种方式"></a>类的加载：类加载的三种方式</h2><p>​        1、命令行启动应用时候由JVM初始化加载</p><p>​        2、通过Class.forName()方法动态加载</p><p>​        3、通过ClassLoader.loadClass（）方法动态加载</p><blockquote><p>Class.forName()和ClassLoader.loadClass()区别?</p></blockquote><ul><li>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 </li></ul><h2 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h2><ul><li><code>全盘负责</code>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><code>缓存机制</code>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li><li><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul><p><strong>双亲委派机制过程？</strong></p><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</span><br><span class="line">            return loadClass(name, false);</span><br><span class="line">    &#125;</span><br><span class="line">    protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</span><br><span class="line">            // 首先判断该类型是否已经被加载</span><br><span class="line">            Class c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                         //如果存在父类加载器，就委派给父类加载器加载</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span><br><span class="line">                        c = findBootstrapClass0(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                 // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>双亲委派机制的优势：</strong></p><p>​        系统类防止内存中出现多份同样的字节码</p><p>​        保证java程序安全稳定运行</p><h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/jvm_memory.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="jvm_memory" style="zoom:200%;"><p>运行时数据区：</p><p>​        内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/jvmRunMemory.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="jvmRunMemory" style="zoom:200%;"><p>​        Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li><li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）</li></ul><h2 id="程序计数器：program-counter-register"><a href="#程序计数器：program-counter-register" class="headerlink" title="程序计数器：program counter register"></a>程序计数器：program counter register</h2><p>​        程序计数器是一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><p>​        作用：PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。<br>由执行引擎读取下一条指令。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/pcjicunqi.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="pc寄存区" style="zoom:200%;"><ul><li><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></li></ul><p>​        因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><ul><li><strong>PC寄存器为什么会被设定为线程私有的？</strong></li></ul><p>​        多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p><p><strong>总结：</strong></p><p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</p><p>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p><p><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></p><h2 id="虚拟机栈：java栈"><a href="#虚拟机栈：java栈" class="headerlink" title="虚拟机栈：java栈"></a>虚拟机栈：java栈</h2><p>​        每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次方法调用，是线程私有的，声明周期和线程一致。</p><p><strong>作用：</strong>主管java程序的运行，保存方法的局部变量、部分结果、并参与方法的调用和返回。</p><p><strong>特点</strong>：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h6 id="栈的存储单位："><a href="#栈的存储单位：" class="headerlink" title="栈的存储单位："></a>栈的存储单位：</h6><p>​        每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在。</p><p>​        在这个线程上正在执行的每个方法都各自对应着一个栈帧。</p><p>​        栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h6 id="栈的运行原理："><a href="#栈的运行原理：" class="headerlink" title="栈的运行原理："></a>栈的运行原理：</h6><p>​        JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出/后进先出”原则</p><p>​        在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</p><p>​        执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p><p>​        如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</p><p>​        不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</p><p>​        如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p><p>​        Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></p><h6 id="栈帧的内部结构："><a href="#栈帧的内部结构：" class="headerlink" title="栈帧的内部结构："></a>栈帧的内部结构：</h6><p>​        局部变量表（local variables）、操作数栈（Operand  stack）、动态链接（指向运行时常量池的方法引用）、方法返回地址（方法正常退出或异常退出的地址）、一些附加信息。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/StackFrame.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="StackFrame" style="zoom:200%;"><p><strong>局部变量表：</strong>变量值存储空间</p><ul><li>局部变量表也被称为局部变量数组或者本地变量表</li><li>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li></ul><h5 id="¶-槽-Slot"><a href="#¶-槽-Slot" class="headerlink" title="¶ 槽 Slot"></a><a href="#%E6%A7%BD-slot">¶</a> 槽 Slot</h5><ul><li>局部变量表最基本的存储单元是 Slot（变量槽）</li><li>在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot<ul><li>byte、short、char 在存储前被转换为int，boolean也被转换为int，0 表示 false，非 0 表示 true</li><li>long 和 double 则占据两个 Slot</li></ul></li><li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot 上</li><li><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</li><li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为this 变量不存在于当前方法的局部变量表中）</li><li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</li></ul><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/LocalVar.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="LocalVar" style="zoom:200%;"><ul><li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ul><p><strong>操作数栈</strong>：保存计算过程的中间结果，作为计算过程中变量的临时存储空间。</p><ul><li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li></ul><h5 id="¶-概述"><a href="#¶-概述" class="headerlink" title="¶ 概述"></a><a href="#%E6%A6%82%E8%BF%B0">¶</a> 概述</h5><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</li><li>栈中的任何一个元素都可以是任意的 Java 数据类型<ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h5 id="¶-栈顶缓存（Top-of-stack-Cashing）"><a href="#¶-栈顶缓存（Top-of-stack-Cashing）" class="headerlink" title="¶ 栈顶缓存（Top-of-stack-Cashing）"></a><a href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98top-of-stack-cashing">¶</a> 栈顶缓存（Top-of-stack-Cashing）</h5><p>​        HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读/写速度非常迅速，甚至可以比内存的读/写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p><p>​        基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong></p><p><strong>动态链接</strong>：指向运行时常量池的方法引用</p><p>​        <strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。</p><p>​        在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/dynamic Linking.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="dynamic Linking" style="zoom:200%;"><h5 id="JVM-是如何执行方法调用的"><a href="#JVM-是如何执行方法调用的" class="headerlink" title="JVM 是如何执行方法调用的"></a>JVM 是如何执行方法调用的</h5><p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p><blockquote><p>【这一块内容，除了方法调用，还包括解析、分派（静态分派、动态分派、单分派与多分派），这里先不介绍，后续再挖】</p></blockquote><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p><ul><li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li></ul><h5 id="¶-虚方法和非虚方法"><a href="#¶-虚方法和非虚方法" class="headerlink" title="¶ 虚方法和非虚方法"></a><a href="#%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95">¶</a> 虚方法和非虚方法</h5><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>其他方法称为虚方法</li></ul><h5 id="¶-虚方法表"><a href="#¶-虚方法表" class="headerlink" title="¶ 虚方法表"></a><a href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8">¶</a> 虚方法表</h5><p>​        在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><p><strong>方法返回地址</strong>：用来存放调用该方法的 PC 寄存器的值。</p><p>一个方法的结束，有两种方式</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong></p><p>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</p><p>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</p></li><li><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong></p><p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p></li></ol><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p><p><strong>附加信息</strong>：栈帧中还允许携带java虚拟机实现相关的一些附加信息。对程序调试支持的信息，但这些信息取决于具体的虚拟机实现。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><strong>本地方法接口</strong>：一个本地方法就是一个java调用非java代码的接口。</p><p>​        Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li><li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li><li>Sun’s Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是C实现的，并被植入 JVM 内部。</li></ul><p><strong>本地方法栈</strong>：</p><ul><li><p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p></li><li><p>本地方法栈也是线程私有的</p></li><li><p>允许线程固定或者可动态扩展的内存大小</p></li><li><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</p></li><li><p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</p></li><li><p>本地方法是使用 C 语言实现的</p></li><li><p>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p></li><li><p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</p></li><li><p>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</p></li><li><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p></li></ul><p><strong>栈是运行时单位，堆是存储的单位。栈解决程序的运行问题，即程序如何执行、如何处理数据。堆解决数据存储问题，数据放在那里、怎么放</strong></p><h2 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h2><h6 id="内存划分："><a href="#内存划分：" class="headerlink" title="内存划分："></a>内存划分：</h6><p>​        对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ul><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li><li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li></ul><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/heap.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="heap" style="zoom:200%;"><h6 id="年轻代："><a href="#年轻代：" class="headerlink" title="年轻代："></a>年轻代：</h6><p>​        年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p><ul><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ul><h6 id="老年代："><a href="#老年代：" class="headerlink" title="老年代："></a>老年代：</h6><p>​        旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p><p>​        大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/memory.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="memory" style="zoom:200%;"><h6 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h6><p>​        不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p><p>​        虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。所以元空间放在后边的方法区再说。</p><h6 id="对象在堆中的生命周期："><a href="#对象在堆中的生命周期：" class="headerlink" title="对象在堆中的生命周期："></a>对象在堆中的生命周期：</h6><p>在 JVM 内存模型的堆中，堆被划分为新生代和老年代</p><ul><li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul><p>当创建一个对象时，对象会被优先分配到新生代的 Eden 区</p><ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul><p>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）</p><ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li></ul><p>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></p><h6 id="对象的分配过程："><a href="#对象的分配过程：" class="headerlink" title="对象的分配过程："></a>对象的分配过程：</h6><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new 的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h6 id="GC简介："><a href="#GC简介：" class="headerlink" title="GC简介："></a>GC简介：</h6><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul><li>目前只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h6 id="TLAB："><a href="#TLAB：" class="headerlink" title="TLAB："></a>TLAB：</h6><p>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</p><p>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></p><p>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</p><h4 id="为什么要有-TLAB"><a href="#为什么要有-TLAB" class="headerlink" title="为什么要有 TLAB ?"></a>为什么要有 TLAB ?</h4><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h2 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h2><ul><li><p>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</p></li><li><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p></li><li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryErro</code>r 异常。</p></li><li><p>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</p></li><li><p>JVM 关闭后方法区即被释放</p></li></ul><h6 id="解惑："><a href="#解惑：" class="headerlink" title="解惑："></a>解惑：</h6><ul><li><strong>方法区（method area）**只是 **JVM 规范**中定义的一个**概念**，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而</strong>永久代（PermGen）**是 **Hotspot** 虚拟机特有的概念， Java8 的时候又被**元空间**取代了，永久代和元空间都可以理解为方法区的落地实现。</li><li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）</li><li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li><li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li><li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li></ul><p>所以对于方法区，Java8 之后的变化：</p><ul><li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul><h6 id="方法区内部结构：虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。"><a href="#方法区内部结构：虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。" class="headerlink" title="方法区内部结构：虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。"></a>方法区内部结构：虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</h6><h4 id="¶-类型信息"><a href="#¶-类型信息" class="headerlink" title="¶ 类型信息"></a><a href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF">¶</a> 类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h4 id="¶-域（Field）信息"><a href="#¶-域（Field）信息" class="headerlink" title="¶ 域（Field）信息"></a><a href="#%E5%9F%9Ffield%E4%BF%A1%E6%81%AF">¶</a> 域（Field）信息</h4><ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul><h4 id="¶-方法（Method）信息"><a href="#¶-方法（Method）信息" class="headerlink" title="¶ 方法（Method）信息"></a><a href="#%E6%96%B9%E6%B3%95method%E4%BF%A1%E6%81%AF">¶</a> 方法（Method）信息</h4><p>JVM 必须保存所有方法的</p><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/three.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Three" style="zoom:200%;"><h6 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h6><p>​        运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><h4 id="¶-常量池"><a href="#¶-常量池" class="headerlink" title="¶ 常量池"></a><a href="#%E5%B8%B8%E9%87%8F%E6%B1%A0">¶</a> 常量池</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><h5 id="¶-为什么需要常量池？"><a href="#¶-为什么需要常量池？" class="headerlink" title="¶ 为什么需要常量池？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0">¶</a> 为什么需要常量池？</h5><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li></ul></li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><h6 id="方法区的演进："><a href="#方法区的演进：" class="headerlink" title="方法区的演进："></a>方法区的演进：</h6><p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/hotspot.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hotspot"></p><ul><li><p>为永久代设置空间大小是很难确定的。</p><p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</p></li><li><p>对永久代进行调优较困难</p></li></ul><h6 id="方法区的垃圾回收："><a href="#方法区的垃圾回收：" class="headerlink" title="方法区的垃圾回收："></a>方法区的垃圾回收：</h6><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code> 、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="JMM引入："><a href="#JMM引入：" class="headerlink" title="JMM引入："></a>JMM引入：</h2><p>JVM内部使用的java内存模型在线程栈和堆之间划分内存。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-memory-model-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-memory-model-1" style="zoom:200%;"><p>​        线程堆栈还包含正在执行的每个方法的所有局部变量(调用堆栈上的所有方法)。 线程只能访问它自己的线程堆栈。 由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。 因此，每个线程都有自己的每个局部变量的版本。</p><p>​        基本类型的所有局部变量(boolean，byte，short，char，int，long，float，double)完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。</p><p>​        堆包含了在Java应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类(例如Byte，Integer，Long等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-memory-model-2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-memory-model-2" style="zoom:200%;"><p>​        局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。</p><p>​        局部变量也可以是对象的引用。 在这种情况下，引用(局部变量)存储在线程堆栈中，但是对象本身存储在堆(Heap)上。</p><p>​        对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。</p><p>​        静态类变量也与类定义一起存储在堆上。</p><h2 id="线程栈如何访问堆上的对象？"><a href="#线程栈如何访问堆上的对象？" class="headerlink" title="线程栈如何访问堆上的对象？"></a>线程栈如何访问堆上的对象？</h2><p>​        所有具有对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-memory-model-3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-memory-model-3" style="zoom:200%;"><p>​        两个线程有一组局部变量。 其中一个局部变量(局部变量2)指向堆上的共享对象(对象3)。 两个线程各自对同一对象具有不同的引用。 它们的引用是局部变量，因此存储在每个线程的线程堆栈中(在每个线程堆栈上)。 但是，这两个不同的引用指向堆上的同一个对象。</p><p>​        注意共享对象(对象3)如何将对象2和对象4作为成员变量引用(由对象3到对象2和对象4的箭头所示)。 通过对象3中的这些成员变量引用，两个线程可以访问对象2和对象4.</p><p>​        该图还显示了一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象(对象1和对象5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象1和对象5。 但是在上图中，每个线程只引用了两个对象中的一个。</p><h2 id="JMM与硬件内存结构关系："><a href="#JMM与硬件内存结构关系：" class="headerlink" title="JMM与硬件内存结构关系："></a>JMM与硬件内存结构关系：</h2><p>​        现代硬件内存架构与内部Java内存模型略有不同。 了解硬件内存架构也很重要，以了解Java内存模型如何与其一起工作。 本节介绍了常见的硬件内存架构，后面的部分将介绍Java内存模型如何与其配合使用。这是现代计算机硬件架构的简化图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-memory-model-4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-memory-model-4" style="zoom:200%;"><p>​        现代计算机通常有2个或更多CPU。 其中一些CPU也可能有多个内核。 关键是，在具有2个或更多CPU的现代计算机上，可以同时运行多个线程。 每个CPU都能够在任何给定时间运行一个线程。 这意味着如果您的Java应用程序是多线程的，线程真的在可能同时运行.</p><p>​        每个CPU基本上都包含一组在CPU内存中的寄存器。 CPU可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为CPU可以比访问主存储器更快地访问这些寄存器。</p><p>​        每个CPU还可以具有CPU高速缓存存储器层。 事实上，大多数现代CPU都有一些大小的缓存存储层。 CPU可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些CPU可能有多个缓存层(级别1和级别2)，但要了解Java内存模型如何与内存交互，这一点并不重要。 重要的是要知道CPU可以有某种缓存存储层。</p><p>​        计算机还包含主存储区(RAM)。 所有CPU都可以访问主内存。 主存储区通常比CPU的高速缓存存储器大得多。同时访问速度也就较慢.</p><p>​        通常，当CPU需要访问主存储器时，它会将部分主存储器读入其CPU缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当CPU需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。</p><h2 id="JMM与硬件内存连接—引入"><a href="#JMM与硬件内存连接—引入" class="headerlink" title="JMM与硬件内存连接—引入"></a>JMM与硬件内存连接—引入</h2><p>​        Java内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于CPU高速缓存和内部CPU寄存器中。 这在图中说明</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-memory-model-5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-memory-model-5" style="zoom:200%;"><p>当对象和变量可以存储在计算机的各种不同存储区域中时，可能会出现某些问题。 两个主要问题是：</p><ul><li>Visibility of thread updates (writes) to shared variables.</li><li>Race conditions when reading, checking and writing shared variables. 以下各节将解释这两个问题。</li></ul><h2 id="JMM与硬件内存连接–对象共享后的可见性"><a href="#JMM与硬件内存连接–对象共享后的可见性" class="headerlink" title="JMM与硬件内存连接–对象共享后的可见性"></a>JMM与硬件内存连接–对象共享后的可见性</h2><p>​        如果两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p><p>​        想象一下，共享对象最初存储在主存储器中。 然后，在CPU上运行的线程将共享对象读入其CPU缓存中。 它在那里对共享对象进行了更改。 只要CPU缓存尚未刷新回主内存，共享对象的更改版本对于在其他CPU上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的CPU缓存中。</p><p>​        下图描绘了该情况。 在左CPU上运行的一个线程将共享对象复制到其CPU缓存中，并将其count变量更改为2.对于在右边的CPU上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-memory-model-6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-memory-model-6" style="zoom:200%;"><p>​        要解决此问题，您可以使用Java的volatile关键字。 <strong>volatile关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存。</strong></p><h2 id="JMM与硬件内存连接–竞态条件"><a href="#JMM与硬件内存连接–竞态条件" class="headerlink" title="JMM与硬件内存连接–竞态条件"></a>JMM与硬件内存连接–竞态条件</h2><p>​        如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态。</p><p>​        想象一下，如果线程A将共享对象的变量计数读入其CPU缓存中。 想象一下，线程B也做同样的事情，但是进入不同的CPU缓存。 现在，线程A将一个添加到count，而线程B执行相同的操作。 现在var1已经增加了两次，每个CPU缓存一次。</p><p>​        如果这些增量是按先后顺序执行的，则变量计数将增加两次并将原始值+ 2写回主存储器。</p><p>​        但是，两个增量同时执行而没有适当的同步。 无论线程A和B中哪一个将其更新后的计数版本写回主存储器，更新的值将仅比原始值高1，尽管有两个增量。</p><p>​        该图说明了如上所述的竞争条件问题的发生：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-memory-model-7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-memory-model-7" style="zoom:200%;"><p>​        要解决此问题，您可以使用Java synchronized块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile</p><h1 id="java内存模型详解"><a href="#java内存模型详解" class="headerlink" title="java内存模型详解"></a>java内存模型详解</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h6 id="并发编程模型的分类："><a href="#并发编程模型的分类：" class="headerlink" title="并发编程模型的分类："></a>并发编程模型的分类：</h6><p>​        在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p><p>​        在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>​        <strong>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</strong></p><p>​        Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><p>​        通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存（隐式通信，显示同步）</strong>和消息传递（显示通信，隐式同步）。<br>1、在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。<br>2、在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>​        同步是指程序用于控制不同线程之间操作发生相对顺序的机制。<br>1、在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br>2、在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><h6 id="java内存模型的抽象"><a href="#java内存模型的抽象" class="headerlink" title="java内存模型的抽象"></a>java内存模型的抽象</h6><p>​        在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>​        Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-1" style="zoom:200%;"><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ul><li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li><li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li></ul><p>下面通过示意图来说明这两个步骤：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-2" style="zoom:200%;"><p>​        如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。</p><p>​        从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>​        在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-3" style="zoom:200%;"><p>​        上述的 <strong>1 属于编译器重排序，2 和 3 属于处理器重排序</strong>。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>​        <strong>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</strong></p><h2 id="处理器重排序与内存屏障指令："><a href="#处理器重排序与内存屏障指令：" class="headerlink" title="处理器重排序与内存屏障指令："></a>处理器重排序与内存屏障指令：</h2><p>​        现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！为了具体说明，请看下面示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Processor A</span><br><span class="line">a = 1; //A1  </span><br><span class="line">x = b; //A2</span><br><span class="line"></span><br><span class="line">// Processor B</span><br><span class="line">b = 2; //B1  </span><br><span class="line">y = a; //B2</span><br><span class="line"></span><br><span class="line">// 初始状态：a = b = 0；处理器允许执行后得到结果：x = y = 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-4" style="zoom:200%;"><p>​        这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>​        从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p><p>​        这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。</p><p>​        下面是常见处理器允许的重排序类型的列表：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/re.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="重排序列表" style="zoom:200%;"><p>​        从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p><ul><li>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li><li>※注 2：上表中的 x86 包括 x64 及 AMD64。</li><li>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li><li>※注 4：数据依赖性后文会专门说明。</li></ul><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/jvmmemory.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="屏障类型" style="zoom:200%;"><p>​        StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p><p>​        StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p><p>happens-before 与 JMM 的关系如下图所示：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-5" style="zoom:200%;"><p>​        如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h2 id="重排序-1"><a href="#重排序-1" class="headerlink" title="重排序"></a>重排序</h2><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/data.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="data" style="zoom:200%;"><p>​        上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>​        前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><p>​        注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><h3 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h3><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi  = 3.14;    //A</span><br><span class="line">double r   = 1.0;     //B</span><br><span class="line">double area = pi * r * r; //C</span><br></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系如下图所示：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-6" style="zoom:200%;"><p>​        如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-7" style="zoom:200%;"><p>​        as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><p>​        根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系：</p><ul><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ul><p>这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。</p><p>​        这里 A happens- before B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果 A happens- before B，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens- before 顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p><p>​        在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ReorderExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1;                   //1</span><br><span class="line">        flag = true;             //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Public void reader() &#123;</span><br><span class="line">        if (flag) &#123;                //3</span><br><span class="line">            int i =  a * a;        //4</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        flag 变量是个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入?</p><p>答案是：不一定能看到。</p><p>​        由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果? 请看下面的程序执行时序图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-8" style="zoom:200%;"><p>​        如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p><p>​        ※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</p><p>​        下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-9" style="zoom:200%;"><p>​        在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p><p>​        从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>​        在单线程程序中，对存在控制依赖的操作</p><h2 id="顺序一致性："><a href="#顺序一致性：" class="headerlink" title="顺序一致性："></a>顺序一致性：</h2><h3 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h3><p>当程序未正确同步时，就会存在数据竞争。java 内存模型规范对数据竞争的定义如下：</p><ul><li>在一个线程中写一个变量，</li><li>在另一个线程读同一个变量，</li><li>而且写和读没有通过同步来排序。</li></ul><p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>JMM 对正确同步的多线程程序的内存一致性做了如下保证：</p><ul><li>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）– 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用。</li></ul><h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。 +（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。 顺序一致性内存模型为程序员提供的视图如下：</li></ul><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-10.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-10" style="zoom:200%;"><p>​        在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读 / 写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 / 写操作串行化。</p><p>​        为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p><p>​        假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B 线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p><p>​        假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-11.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-11" style="zoom:200%;"><p>​        现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-12.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-12" style="zoom:200%;"><p>​        未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>​        但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p><h3 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h3><p>下面我们对前面的示例程序 ReorderExample 用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p><p>请看下面的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class SynchronizedExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public synchronized void writer() &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void reader() &#123;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            int i = a;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        上面示例代码中，假设 A 线程执行 writer() 方法后，B 线程执行 reader() 方法。这是一个正确同步的多线程程序。根据 JMM 规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-13.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-13" style="zoom:200%;"><p>​        在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>​        从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p><h2 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h2><p>​        对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM 保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM 在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM 内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p><p>​        JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p><p>​        和顺序一致性模型一样，未同步程序在 JMM 中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p><ul><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li><li>JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。</li></ul><p>第 3 个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读 / 写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I/O 设备执行内存的读 / 写。下面让我们通过一个示意图来说明总线的工作机制：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-14.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-14" style="zoom:200%;"><p>​        如上图所示，假设处理器 A，B 和 C 同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p><p>​        总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读 / 写操作具有原子性。</p><p>​        在一些 32 位的处理器上，如果要求对 64 位数据的读 / 写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的读 / 写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的读 / 写操作拆分为两个 32 位的读 / 写操作来执行。这两个 32 位的读 / 写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的读 / 写将不具有原子性。</p><p>​        当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-15.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-15" style="zoom:200%;"><p>​        如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被拆分为两个 32 位的读操作，且这两个 32 位的读操作被分配到同一个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A“写了一半“的无效值。</p><h2 id="处理器内存模型"><a href="#处理器内存模型" class="headerlink" title="处理器内存模型"></a>处理器内存模型</h2><p>​        顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM 和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和 JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p><p>​        根据对不同类型读 / 写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p><ul><li>放松程序中写 - 读操作的顺序，由此产生了 total store ordering 内存模型（简称为 TSO）。</li><li>在前面 1 的基础上，继续放松程序中写 - 写操作的顺序，由此产生了 partial store order 内存模型（简称为 PSO）。</li><li>在前面 1 和 2 的基础上，继续放松程序中读 - 写和读 - 读操作的顺序，由此产生了 relaxed memory order 内存模型（简称为 RMO）和 PowerPC 内存模型。</li></ul><p>注意，这里处理器对读 / 写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守 as-if-serial 语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/memoryModul.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="memoryModul" style="zoom:200%;"><p>​        在这个表格中，我们可以看到所有处理器内存模型都允许写 - 读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写 - 读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p><p>​        上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p><p>​        由于常见的处理器内存模型比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-x01.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-x01" style="zoom:200%;"><p>​        如上图所示，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型</p><h2 id="JMM、处理器内存模型与顺序一致性内存模型之间的关系"><a href="#JMM、处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="JMM、处理器内存模型与顺序一致性内存模型之间的关系"></a>JMM、处理器内存模型与顺序一致性内存模型之间的关系</h2><p>​        JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-x02.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-x02" style="zoom:200%;"><p>​        从上图我们可以看出：常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p><h2 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h2><p>从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：</p><ul><li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li><li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li></ul><p>由于这两个因素互相矛盾，所以 JSR-133 专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看 JSR-133 是如何实现这一目标的。</p><p>为了具体说明，请看前面提到过的计算圆面积的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double pi  = 3.14;    //A</span><br><span class="line">double r   = 1.0;     //B</span><br><span class="line">double area = pi * r * r; //C</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面计算圆的面积的示例代码存在三个 happens- before 关系：</p><ul><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ul><p>由于 A happens- before B，happens- before 的定义会要求：A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。 但是从程序语义的角度来说，对 A 和 B 做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个 happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before 要求禁止的重排序分为了下面两类：</p><ul><li>会改变程序执行结果的重排序。</li><li>不会改变程序执行结果的重排序。</li></ul><p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p><ul><li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li><li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li></ul><p>下面是 JMM 的设计示意图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-x03.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-x03" style="zoom:200%;"><p>从上图可以看出两点：</p><ul><li>JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的 happens- before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A happens- before B）。</li><li>JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li></ul><h2 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h2><p>​        Java 程序的内存可见性保证按程序类型可以分为下列三类：</p><ul><li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li><li>未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li></ul><p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/java-jmm-x04.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-x04" style="zoom:200%;"><p>​        只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p><h3 id="JSR-133-对旧内存模型的修补"><a href="#JSR-133-对旧内存模型的修补" class="headerlink" title="JSR-133 对旧内存模型的修补"></a>JSR-133 对旧内存模型的修补</h3><p>JSR-133 对 JDK5 之前的旧内存模型的修补主要有两个：</p><ul><li>增强 volatile 的内存语义。旧内存模型允许 volatile 变量与普通变量重排序。JSR-133 严格限制 volatile 变量与普通变量的重排序，使 volatile 的写 - 读和锁的释放 - 获取具有相同的内存语义。</li><li>增强 final 的内存语义。在旧内存模型中，多次读取同一个 final 变量的值可能会不相同。为此，JSR-133 为 final 增加了两个重排序规则。现在，final 具有了初始化安全性。</li></ul><h1 id="java垃圾回收基础"><a href="#java垃圾回收基础" class="headerlink" title="java垃圾回收基础"></a>java垃圾回收基础</h1><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h6 id="1-引用计数算法："><a href="#1-引用计数算法：" class="headerlink" title="1.引用计数算法："></a>1.引用计数算法：</h6><p>​        给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p><p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><h6 id="2-可达性分析算法："><a href="#2-可达性分析算法：" class="headerlink" title="2.可达性分析算法："></a>2.可达性分析算法：</h6><p>​        通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/GCRoots.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="GCRoots" style="zoom:200%;"><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h6 id="3-方法区的回收："><a href="#3-方法区的回收：" class="headerlink" title="3.方法区的回收："></a>3.方法区的回收：</h6><p>​        因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>​        在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p><p>​        类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p><h6 id="4-finalize（）"><a href="#4-finalize（）" class="headerlink" title="4.finalize（）"></a>4.finalize（）</h6><p>​        finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>​        当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>​        无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 具有四种强度不同的引用类型。</p><h6 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h6><p>​        被强引用关联的对象不会被回收。</p><p>​        使用 new 一个新对象的方式来创建强引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h6><p>​        被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>​        使用 SoftReference 类来创建软引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;  // 使对象只被软引用关联</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h6><p>​        被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>​        使用 WeakReference 类来实现弱引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h6><p>​        又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>​        为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>​        使用 PhantomReference 来实现虚引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h6 id="1-标记–清除"><a href="#1-标记–清除" class="headerlink" title="1.标记–清除"></a>1.标记–清除</h6><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/mark-clear.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="mark-clear" style="zoom:200%;"><p>将存活的对象进行标记，然后清理掉未被标记的对象。</p><p>不足:</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h6 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2.标记-整理"></a>2.标记-整理</h6><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/mark-compact.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="mark-compact" style="zoom:200%;"><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h6 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3.复制算法"></a>3.复制算法</h6><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/copy.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="copy" style="zoom:200%;"><p>​        将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是只使用了内存的一半。</p><p>​        现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>​        HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><h6 id="4-分代收集（-Generational-Collection-）"><a href="#4-分代收集（-Generational-Collection-）" class="headerlink" title="4.分代收集（****Generational Collection******）"></a>4.分代收集（**<em>*</em>*Generational Collection******）</h6><p>​        现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用: 复制算法</li><li>老年代使用: 标记 - 清除 或者 标记 - 整理 算法</li></ul><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0JVM/generation.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="generation" style="zoom:200%;"><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li><li>串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul><li>Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h3 id="¶-内存分配策略"><a href="#¶-内存分配策略" class="headerlink" title="¶ 内存分配策略"></a><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">¶</a> 内存分配策略</h3><h4 id="¶-1-对象优先在-Eden-分配"><a href="#¶-1-对象优先在-Eden-分配" class="headerlink" title="¶ 1. 对象优先在 Eden 分配"></a><a href="#1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-eden-%E5%88%86%E9%85%8D">¶</a> 1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><h4 id="¶-2-大对象直接进入老年代"><a href="#¶-2-大对象直接进入老年代" class="headerlink" title="¶ 2. 大对象直接进入老年代"></a><a href="#2-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">¶</a> 2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><h4 id="¶-3-长期存活的对象进入老年代"><a href="#¶-3-长期存活的对象进入老年代" class="headerlink" title="¶ 3. 长期存活的对象进入老年代"></a><a href="#3-%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">¶</a> 3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h4 id="¶-4-动态对象年龄判定"><a href="#¶-4-动态对象年龄判定" class="headerlink" title="¶ 4. 动态对象年龄判定"></a><a href="#4-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A">¶</a> 4. 动态对象年龄判定</h4><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="¶-5-空间分配担保"><a href="#¶-5-空间分配担保" class="headerlink" title="¶ 5. 空间分配担保"></a><a href="#5-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D">¶</a> 5. 空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p><h3 id="¶-Full-GC-的触发条件"><a href="#¶-Full-GC-的触发条件" class="headerlink" title="¶ Full GC 的触发条件"></a><a href="#full-gc-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">¶</a> Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p><h4 id="¶-1-调用-System-gc"><a href="#¶-1-调用-System-gc" class="headerlink" title="¶ 1. 调用 System.gc()"></a><a href="#1-%E8%B0%83%E7%94%A8-systemgc">¶</a> 1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h4 id="¶-2-老年代空间不足"><a href="#¶-2-老年代空间不足" class="headerlink" title="¶ 2. 老年代空间不足"></a><a href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3">¶</a> 2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h4 id="¶-3-空间分配担保失败"><a href="#¶-3-空间分配担保失败" class="headerlink" title="¶ 3. 空间分配担保失败"></a><a href="#3-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E5%A4%B1%E8%B4%A5">¶</a> 3. 空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。</p><h4 id="¶-4-JDK-1-7-及以前的永久代空间不足"><a href="#¶-4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="¶ 4. JDK 1.7 及以前的永久代空间不足"></a><a href="#4-jdk-17-%E5%8F%8A%E4%BB%A5%E5%89%8D%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3">¶</a> 4. JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h4 id="¶-5-Concurrent-Mode-Failure"><a href="#¶-5-Concurrent-Mode-Failure" class="headerlink" title="¶ 5. Concurrent Mode Failure"></a><a href="#5-concurrent-mode-failure">¶</a> 5. Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-x-overview.html">https://www.pdai.tech/md/java/jvm/java-jvm-x-overview.html</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5</a></p><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf</a></p><p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></p><p><a href="https://blog.csdn.net/weixin_39596082/article/details/88093274">https://blog.csdn.net/weixin_39596082/article/details/88093274</a></p><p><a href="https://yq.aliyun.com/articles/94557?spm=5176.100239.blogcont217385.73.SaQb9l">https://yq.aliyun.com/articles/94557?spm=5176.100239.blogcont217385.73.SaQb9l</a></p><p><a href="https://mp.weixin.qq.com/s/S3PcA2KIzCVB2hJmsbVzyQ">https://mp.weixin.qq.com/s/S3PcA2KIzCVB2hJmsbVzyQ</a></p><p><a href="https://mp.weixin.qq.com/s/olNXcRAT3PTK-hV_ehtmtw">https://mp.weixin.qq.com/s/olNXcRAT3PTK-hV_ehtmtw</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习笔记多线程</title>
      <link href="2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java并发"><a href="#java并发" class="headerlink" title="java并发"></a>java并发</h1><p>知识体系：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-concurrent-overview-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-concurrent-overview" style="zoom:200%;"><h1 id="并发–理论基础"><a href="#并发–理论基础" class="headerlink" title="并发–理论基础"></a>并发–理论基础</h1><h2 id="带着问题去理解："><a href="#带着问题去理解：" class="headerlink" title="带着问题去理解："></a>带着问题去理解：</h2><ul><li>多线程的出现是要解决什么问题的?</li><li>线程不安全是指什么? 举例说明</li><li>并发出现线程不安全的本质什么? 可见性，原子性和有序性。</li><li>Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before</li><li>线程安全是不是非真即假? 不是</li><li>线程安全有哪些实现思路?</li><li>如何理解并发和并行的区别?</li></ul><h2 id="为什么需要多线程？"><a href="#为什么需要多线程？" class="headerlink" title="为什么需要多线程？"></a>为什么需要多线程？</h2><p>​        众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 <code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 <code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 <code>有序性</code>问题</li></ul><h2 id="并发出现问题的根源：并发三要素"><a href="#并发出现问题的根源：并发三要素" class="headerlink" title="并发出现问题的根源：并发三要素"></a>并发出现问题的根源：并发三要素</h2><h6 id="可见性：CPU缓存引起"><a href="#可见性：CPU缓存引起" class="headerlink" title="可见性：CPU缓存引起"></a>可见性：CPU缓存引起</h6><p>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>​        假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>​        此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p><p>​        这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h6 id="原子性：分时复用引起"><a href="#原子性：分时复用引起" class="headerlink" title="原子性：分时复用引起"></a>原子性：分时复用引起</h6><p>​        原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>​        经典的<strong>转账问题</strong>：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p><p>​        所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p><h6 id="有序性：重排序引起"><a href="#有序性：重排序引起" class="headerlink" title="有序性：重排序引起"></a>有序性：重排序引起</h6><p>有序性：程序执行的顺序按照代码的先后顺序执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;              </span><br><span class="line">boolean flag = false;</span><br><span class="line">i = 1;                //语句1  </span><br><span class="line">flag = true;          //语句2</span><br></pre></td></tr></table></figure><p>​        上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p><p>​        在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-jmm-3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm" style="zoom:200%;"><p>​        上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><h2 id="JAVA解决并发问题：JMM（java内存模型）、"><a href="#JAVA解决并发问题：JMM（java内存模型）、" class="headerlink" title="JAVA解决并发问题：JMM（java内存模型）、"></a>JAVA解决并发问题：JMM（java内存模型）、</h2><p>​        Java 内存模型是个很复杂的规范，强烈推荐你看后续（应该是网上能找到最好的材料之一了）：<a href>Java 内存模型详解</a>。</p><p><strong>理解的第一个维度：核心知识点</strong></p><p>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p><ul><li>原子性</li></ul><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br><span class="line">y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br><span class="line">x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br><span class="line">x = x + 1;     //语句4： 同语句3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        只有语句1的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><p>​        从上面可以看出，<strong>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现</strong>。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><ul><li>可见性</li></ul><p><strong>Java提供了volatile关键字来保证可见性。</strong></p><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><blockquote><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote><ul><li>有序性</li></ul><p><strong>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</strong></p><h2 id="Happens—Before原则："><a href="#Happens—Before原则：" class="headerlink" title="Happens—Before原则："></a>Happens—Before原则：</h2><p>​        可用volatile和synchronized来保证有序性。JVM还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h6 id="1-单一线程原则"><a href="#1-单一线程原则" class="headerlink" title="1.单一线程原则"></a>1.单一线程原则</h6><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/single-thread-rule.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="single-thread-rule" style="zoom:150%;"><h6 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2.管程锁定规则"></a>2.管程锁定规则</h6><p>一个unlock操作先行发生于后面对同一个锁的lock操作。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/monitor-lock-rule.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="monitor-lock-rule" style="zoom:200%;"><h6 id="3-volatile变量规则"><a href="#3-volatile变量规则" class="headerlink" title="3.volatile变量规则"></a>3.volatile变量规则</h6><p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/volatile-variable-rule.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="volatile-variable-rule" style="zoom:200%;"><h6 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5.线程加入规则"></a>5.线程加入规则</h6><p>Thread对象的结束先行发生于join（）方法返回</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread-join-rule.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="thread-join-rule" style="zoom:200%;"><h6 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6.线程中断规则"></a>6.线程中断规则</h6><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h6 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7.对象终结规则"></a>7.对象终结规则</h6><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</p><h6 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8.传递性"></a>8.传递性</h6><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-jmm-5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-jmm-5" style="zoom:200%;"><h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><h2 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1.互斥同步"></a>1.互斥同步</h2><p>synchronized和ReentrantLock</p><h2 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2.非阻塞同步"></a>2.非阻塞同步</h2><p>​        互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>​        互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h3 id="2-1-CAS"><a href="#2-1-CAS" class="headerlink" title="2.1.CAS"></a>2.1.CAS</h3><p>​        随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>​        乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h3 id="2-2AtomicInteger"><a href="#2-2AtomicInteger" class="headerlink" title="2.2AtomicInteger"></a>2.2AtomicInteger</h3><p>​        J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。</p><p>​        以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger cnt = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3ABA问题"><a href="#2-3ABA问题" class="headerlink" title="2.3ABA问题"></a>2.3ABA问题</h3><p>​        如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>​        J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h2 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h2><p>​        要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h3 id="3-1栈封闭"><a href="#3-1栈封闭" class="headerlink" title="3.1栈封闭"></a>3.1栈封闭</h3><p>​        多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class StackClosedExample &#123;</span><br><span class="line">    public void add100() &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    StackClosedExample example = new StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="3-2线程本地存储"><a href="#3-2线程本地存储" class="headerlink" title="3.2线程本地存储"></a>3.2线程本地存储</h3><p>​        如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>​        符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>​        可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>​        对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocal threadLocal = new ThreadLocal();</span><br><span class="line">        Thread thread1 = new Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(1);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(2);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalExample1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocal threadLocal1 = new ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = new ThreadLocal();</span><br><span class="line">        Thread thread1 = new Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(1);</span><br><span class="line">            threadLocal2.set(1);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(2);</span><br><span class="line">            threadLocal2.set(2);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码对应的底层结构图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/threadLocal.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="threadLocal.png" style="zoom:200%;"><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h3 id="3-3可重入代码"><a href="#3-3可重入代码" class="headerlink" title="3.3可重入代码"></a>3.3可重入代码</h3><p>​        这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</p><p>​        可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="带着大厂的面试问题去理解："><a href="#带着大厂的面试问题去理解：" class="headerlink" title="带着大厂的面试问题去理解："></a>带着大厂的面试问题去理解：</h2><ul><li>线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?</li><li>通常线程有哪几种使用方式?</li><li>基础线程机制有哪些?</li><li>线程的中断方式有哪些?</li><li>线程的互斥同步方式有哪些? 如何比较和选择?</li><li>线程之间有哪些协作方式?</li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/threadThrans.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="threadThrans" style="zoom:200%;"><h6 id="新建-New"><a href="#新建-New" class="headerlink" title="新建(New)"></a>新建(New)</h6><p>创建后尚未启动。</p><h6 id="可运行-Runnable"><a href="#可运行-Runnable" class="headerlink" title="可运行(Runnable)"></a>可运行(Runnable)</h6><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><h6 id="阻塞-Blocking"><a href="#阻塞-Blocking" class="headerlink" title="阻塞(Blocking)"></a>阻塞(Blocking)</h6><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><h6 id="无限期等待-Waiting"><a href="#无限期等待-Waiting" class="headerlink" title="无限期等待(Waiting)"></a>无限期等待(Waiting)</h6><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/waiting.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="waiting" style="zoom:200%;"><h6 id="限期等待-Timed-Waiting"><a href="#限期等待-Timed-Waiting" class="headerlink" title="限期等待(Timed Waiting)"></a>限期等待(Timed Waiting)</h6><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/timedWaiting.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="timedWaiting" style="zoom:200%;"><h6 id="死亡-Terminated"><a href="#死亡-Terminated" class="headerlink" title="死亡(Terminated)"></a>死亡(Terminated)</h6><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h2 id="线程使用方式（创建线程）："><a href="#线程使用方式（创建线程）：" class="headerlink" title="线程使用方式（创建线程）："></a>线程使用方式（创建线程）：</h2><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p><h6 id="Runnable接口："><a href="#Runnable接口：" class="headerlink" title="Runnable接口："></a>Runnable接口：</h6><p>需要实现run（）方法，通过Thread调用start（）来启动线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable instance = new MyRunnable();</span><br><span class="line">    Thread thread = new Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="实现Callable接口："><a href="#实现Callable接口：" class="headerlink" title="实现Callable接口："></a>实现Callable接口：</h6><p>Callable可以有返回值，返回值通过FutureTask进行封装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public Integer call() &#123;</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    MyCallable mc = new MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = new Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h6><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyThread mt = new MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h3><p>实现接口会更好一些，因为:</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h2 id="线程互斥同步"><a href="#线程互斥同步" class="headerlink" title="线程互斥同步"></a>线程互斥同步</h2><p>​        Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h6 id="synchronized："><a href="#synchronized：" class="headerlink" title="synchronized："></a>synchronized：</h6><p>1.同步一个代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void func() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只作用于同一个对象，如果调用两个对象上的同步代码块，就不会同步。</p><p>2.同步一个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void func () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和同步代码块一样，作用于同一个对象</p><p>3.同步一个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void func() &#123;</span><br><span class="line">    synchronized (SynchronizedExample.class) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><p>4.同步一个静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized static void fun() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作用于整个类</p><h6 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock:"></a>ReentrantLock:</h6><p>ReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void func() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); // 确保释放锁，从而避免发生死锁。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    LockExample lockExample = new LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h3 id="¶-使用选择"><a href="#¶-使用选择" class="headerlink" title="¶ 使用选择"></a><a href="#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9">¶</a> 使用选择</h3><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</p><h1 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h1><h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="面试问题："><a href="#面试问题：" class="headerlink" title="面试问题："></a>面试问题：</h2><ul><li><p>Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。</p></li><li><p>Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。</p></li><li><p>Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。</p></li><li><p>Synchronized和Lock的对比，和选择?</p></li><li><p>Synchronized在使用时有何注意事项?</p></li><li><p>Synchronized修饰的方法在抛出异常时,会释放锁吗?</p></li><li><p>多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?</p></li><li><p>Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?</p></li><li><p>我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?</p></li><li><p>什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?</p></li><li><p>不同的JDK中对Synchronized有何优化?</p></li></ul><h2 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h2><p>在应用Sychronized关键字时需要把握如下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁</li><li>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li></ul><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>包括方法锁（默认锁对象为this、当前实例对象）和同步代码块锁（自己指定锁对象）</p><h4 id="代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁"><a href="#代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁" class="headerlink" title="代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁"></a>代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedObjectLock implements Runnable &#123;</span><br><span class="line">    static SynchronizedObjectLock instence = new SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(instence);</span><br><span class="line">        Thread t2 = new Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedObjectLock implements Runnable &#123;</span><br><span class="line">    static SynchronizedObjectLock instence = new SynchronizedObjectLock();</span><br><span class="line">    // 创建2把锁</span><br><span class="line">    Object block1 = new Object();</span><br><span class="line">    Object block2 = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br><span class="line">        synchronized (block1) &#123;</span><br><span class="line">            System.out.println(&quot;block1锁,我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;block1锁,&quot;+Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (block2) &#123;</span><br><span class="line">            System.out.println(&quot;block2锁,我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;block2锁,&quot;+Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(instence);</span><br><span class="line">        Thread t2 = new Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">block1锁,我是线程Thread-0</span><br><span class="line">block1锁,Thread-0结束</span><br><span class="line">block2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br><span class="line">block1锁,我是线程Thread-1</span><br><span class="line">block2锁,Thread-0结束</span><br><span class="line">block1锁,Thread-1结束</span><br><span class="line">block2锁,我是线程Thread-1</span><br><span class="line">block2锁,Thread-1结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法锁形式：synchronized修饰普通方法，锁对象默认为this"><a href="#方法锁形式：synchronized修饰普通方法，锁对象默认为this" class="headerlink" title="方法锁形式：synchronized修饰普通方法，锁对象默认为this"></a>方法锁形式：synchronized修饰普通方法，锁对象默认为this</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedObjectLock implements Runnable &#123;</span><br><span class="line">    static SynchronizedObjectLock instence = new SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void method() &#123;</span><br><span class="line">        System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(instence);</span><br><span class="line">        Thread t2 = new Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类锁：指synchronize修饰静态的方法或指定锁对象为Class对象"><a href="#类锁：指synchronize修饰静态的方法或指定锁对象为Class对象" class="headerlink" title="类锁：指synchronize修饰静态的方法或指定锁对象为Class对象"></a>类锁：指synchronize修饰静态的方法或指定锁对象为Class对象</h2><h4 id="synchronize修饰静态方法"><a href="#synchronize修饰静态方法" class="headerlink" title="synchronize修饰静态方法"></a>synchronize修饰静态方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedObjectLock implements Runnable &#123;</span><br><span class="line">    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();</span><br><span class="line">    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // synchronized用在普通方法上，默认的锁就是this，当前实例</span><br><span class="line">    public synchronized void method() &#123;</span><br><span class="line">        System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // t1和t2对应的this是两个不同的实例，所以代码不会串行</span><br><span class="line">        Thread t1 = new Thread(instence1);</span><br><span class="line">        Thread t2 = new Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我是线程Thread-0</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br><span class="line">Thread-0结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedObjectLock implements Runnable &#123;</span><br><span class="line">    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();</span><br><span class="line">    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span><br><span class="line">    public static synchronized void method() &#123;</span><br><span class="line">        System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(instence1);</span><br><span class="line">        Thread t2 = new Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="synchronized指定锁对象为Class对象"><a href="#synchronized指定锁对象为Class对象" class="headerlink" title="synchronized指定锁对象为Class对象"></a>synchronized指定锁对象为Class对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedObjectLock implements Runnable &#123;</span><br><span class="line">    static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();</span><br><span class="line">    static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 所有线程需要的锁都是同一把</span><br><span class="line">        synchronized(SynchronizedObjectLock.class)&#123;</span><br><span class="line">            System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(instence1);</span><br><span class="line">        Thread t2 = new Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Synchronized原理分析"><a href="#Synchronized原理分析" class="headerlink" title="Synchronized原理分析"></a>Synchronized原理分析</h2><h6 id="加锁和释放锁的原理"><a href="#加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理"></a>加锁和释放锁的原理</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedDemo2 &#123;</span><br><span class="line">    Object object = new Object();</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        synchronized (object) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用javac命令进行编译生成.class文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;javac SynchronizedDemo2.java</span><br><span class="line">  </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>使用javap命令反编译查看.class文件的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;javap -verbose SynchronizedDemo2.class</span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-1" style="zoom:200%;"><p>关注红色方框里的<code>monitorenter</code>和<code>monitorexit</code>即可。</p><p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：</p><ul><li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li><li>这把锁已经被别的线程获取了，等待锁释放</li></ul><p><code>monitorexit指令</code>：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p><p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-2" style="zoom:200%;"><p>​        该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p><h2 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h2><p>​        上面的demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。</p><p>​        Synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</p><h2 id="保证可见性的原理：内存模型和happens-before规则"><a href="#保证可见性的原理：内存模型和happens-before规则" class="headerlink" title="保证可见性的原理：内存模型和happens-before规则"></a>保证可见性的原理：内存模型和happens-before规则</h2><p>​        <strong>Synchronized的happens-before规则，即监视器锁规则</strong>：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MonitorDemo &#123;</span><br><span class="line">    private int a = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void writer() &#123;     // 1</span><br><span class="line">        a++;                                // 2</span><br><span class="line">    &#125;                                       // 3</span><br><span class="line"></span><br><span class="line">    public synchronized void reader() &#123;    // 4</span><br><span class="line">        int i = a;                         // 5</span><br><span class="line">    &#125;                                      // 6</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码和happens-before的关系：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-3" style="zoom:200%;"><p>​        在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么?</p><p>​        根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。</p><h2 id="JVM中锁的优化"><a href="#JVM中锁的优化" class="headerlink" title="JVM中锁的优化"></a>JVM中锁的优化</h2><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。<strong>不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销</strong>。</p><ul><li><code>锁粗化(Lock Coarsening)</code>：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</li><li><code>锁消除(Lock Elimination)</code>：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</li><li><code>轻量级锁(Lightweight Locking)</code>：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</li><li><code>偏向锁(Biased Locking)</code>：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li><li><code>适应性自旋(Adaptive Spinning)</code>：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</li></ul><blockquote><p>下面来详细讲解下，先从Synchronied同步锁开始讲起：</p></blockquote><h3 id="¶-锁的类型"><a href="#¶-锁的类型" class="headerlink" title="¶ 锁的类型"></a><a href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B">¶</a> 锁的类型</h3><p>在Java SE 1.6里Synchronied同步锁，一共有四种状态：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级所</code>、<code>重量级锁</code>，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p><blockquote><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p></blockquote><h3 id="¶-自旋锁与自适应自旋锁"><a href="#¶-自旋锁与自适应自旋锁" class="headerlink" title="¶ 自旋锁与自适应自旋锁"></a><a href="#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81">¶</a> 自旋锁与自适应自旋锁</h3><h4 id="¶-自旋锁"><a href="#¶-自旋锁" class="headerlink" title="¶ 自旋锁"></a><a href="#%E8%87%AA%E6%97%8B%E9%94%81">¶</a> 自旋锁</h4><blockquote><p>引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p></blockquote><p>自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的新能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p><p>可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)</p><h4 id="¶-自适应自旋锁"><a href="#¶-自适应自旋锁" class="headerlink" title="¶ 自适应自旋锁"></a><a href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81">¶</a> 自适应自旋锁</h4><p>​         在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准备，JVM也会越来越聪明。</p><h3 id="¶-锁消除"><a href="#¶-锁消除" class="headerlink" title="¶ 锁消除"></a><a href="#%E9%94%81%E6%B6%88%E9%99%A4">¶</a> 锁消除</h3><p>​        锁消除时指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。</p><p>​        当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象的连续append()操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static String test03(String s1, String s2, String s3) &#123;</span><br><span class="line">    String s = s1 + s2 + s3;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-4" style="zoom:200%;"><p>​        众所周知，StringBuilder不是安全同步的，但是在上述代码中，JVM判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内)</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。</p><p>这里贴上根据上述Javap 编译地情况编写地实例java类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static String test04(String s1, String s2, String s3) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        在上述地连续append()操作中就属于这类情况。JVM会检测到这样一连串地操作都是对同一个对象加锁，那么JVM会将加锁同步地范围扩展(粗化)到整个一系列操作的 外部，使整个一连串地append()操作只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能。</p><p>如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头地内存布局。上面介绍Java对象头也详细介绍过。在对象头中(<code>Object Header</code>)存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为32位或者64位(视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="¶-轻量级锁加锁"><a href="#¶-轻量级锁加锁" class="headerlink" title="¶ 轻量级锁加锁"></a><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81">¶</a> 轻量级锁加锁</h4><p>在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(<code>Lock Record</code>)的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝(JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>)这个时候线程堆栈与对象头的状态如图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-5" style="zoom:200%;"><p>​        如上图所示：如果当前对象没有被锁定，那么锁标志位位01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录<code>Lock Record</code>的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝。</p><pre><code>     然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将`Mark Word`更新为指向`Lock Record`的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(`Mark Word`中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：</code></pre><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-6" style="zoom:200%;"><p>​        如果这个更新操作失败，JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<code>10.Mark Word</code>中存储的时指向重量级锁的指针。</p><p>​         轻量级解锁时，会使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-7 " style="zoom:200%;"><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><blockquote><p>引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p></blockquote><p> 为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和推出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-8" style="zoom:200%;"><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p> 偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-schronized-9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-schronized-9" style="zoom:200%;"><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/lock.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="lock" style="zoom:200%;"><h2 id="Synchronized与Lock"><a href="#Synchronized与Lock" class="headerlink" title="Synchronized与Lock"></a>Synchronized与Lock</h2><h3 id="¶-synchronized的缺陷"><a href="#¶-synchronized的缺陷" class="headerlink" title="¶ synchronized的缺陷"></a><a href="#synchronized%E7%9A%84%E7%BC%BA%E9%99%B7">¶</a> synchronized的缺陷</h3><ul><li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时</li><li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活</li><li><code>无法知道是否成功获得锁</code>，相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，…..</li></ul><h3 id="¶-Lock解决相应问题"><a href="#¶-Lock解决相应问题" class="headerlink" title="¶ Lock解决相应问题"></a><a href="#lock%E8%A7%A3%E5%86%B3%E7%9B%B8%E5%BA%94%E9%97%AE%E9%A2%98">¶</a> Lock解决相应问题</h3><p>Lock类这里不做过多解释，主要看里面的4个方法:</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个boolean值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。</p><blockquote><p><code>ReentrantLock</code>为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。详细分析请看: <a href>JUC锁: ReentrantLock详解</a></p></blockquote><h2 id="¶-再深入理解"><a href="#¶-再深入理解" class="headerlink" title="¶ 再深入理解"></a><a href="#%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">¶</a> 再深入理解</h2><p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛地使用。</p><ul><li><strong>使用Synchronized有哪些要注意的？</strong><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li></ul></li><li><strong>synchronized是公平锁吗？</strong></li></ul><p>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，不过这种抢占的方式可以预防饥饿</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="面试问题：-1"><a href="#面试问题：-1" class="headerlink" title="面试问题："></a>面试问题：</h2><p>volatile关键字的作用是什么?</p><p>volatile能保证原子性吗?</p><p>之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?</p><p>i++为什么不能保证原子性?</p><p>volatile是如何实现可见性的?  内存屏障。</p><p>volatile是如何实现有序性的?  happens-before等</p><p>说下volatile的应用场景?</p><h2 id="volatile作用详解："><a href="#volatile作用详解：" class="headerlink" title="volatile作用详解："></a>volatile作用详解：</h2><h4 id="防止重排序"><a href="#防止重排序" class="headerlink" title="防止重排序"></a>防止重排序</h4><p>​        大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。其源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    public static volatile Singleton singleton;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数私有，禁止外部实例化</span><br><span class="line">     */</span><br><span class="line">    private Singleton() &#123;&#125;;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p><h4 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h4><p>​        可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line"></span><br><span class="line">    public void change()&#123;</span><br><span class="line">        a = 3;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;b=&quot;+b+&quot;;a=&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            final VolatileTest test = new VolatileTest();</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line">b=2;a=1</span><br><span class="line">b=2;a=1</span><br><span class="line">b=3;a=3</span><br><span class="line">b=3;a=3</span><br><span class="line">b=3;a=1 // 这里</span><br><span class="line">b=3;a=3</span><br><span class="line">b=2;a=1</span><br><span class="line">b=3;a=3</span><br><span class="line">b=3;a=3</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        为什么会出现b=3;a=1这种结果呢? 正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。那b=3;a=1的结果是怎么出来的? 原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</p><h4 id="保证原子性：单次读-写"><a href="#保证原子性：单次读-写" class="headerlink" title="保证原子性：单次读/写"></a>保证原子性：单次读/写</h4><p>​        volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。先从如下两个问题来理解（后文再从内存屏障的角度理解）：</p><h6 id="i-为什么不能保证原子性"><a href="#i-为什么不能保证原子性" class="headerlink" title="i++为什么不能保证原子性"></a>i++为什么不能保证原子性</h6><p>​        对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p><p>现在我们就通过下列程序来演示一下这个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest01 &#123;</span><br><span class="line">    volatile int i;</span><br><span class="line"></span><br><span class="line">    public void addI()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final  VolatileTest01 test01 = new VolatileTest01();</span><br><span class="line">        for (int n = 0; n &lt; 1000; n++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test01.addI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(10000);//等待10秒，保证上面程序执行完成</span><br><span class="line">        System.out.println(test01.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：981 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的(否则结果应该是1000)。原因也很简单，i++其实是一个复合操作，包括三步骤：</p><ul><li>读取i的值。</li><li>对i加1。</li><li>将i的值写回内存。 volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</li></ul><h6 id="共享的long和double变量为什么用volatile"><a href="#共享的long和double变量为什么用volatile" class="headerlink" title="共享的long和double变量为什么用volatile"></a>共享的long和double变量为什么用volatile</h6><p>​        因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</p><p>如下是JLS中的解释：</p><blockquote><p>17.7 Non-Atomic Treatment of double and long</p></blockquote><ul><li>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.</li><li>Writes and reads of volatile long and double values are always atomic.</li><li>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</li><li>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.</li><li>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.</li></ul><p>目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。</p><h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><h4 id="volatile可见性实现"><a href="#volatile可见性实现" class="headerlink" title="volatile可见性实现"></a>volatile可见性实现</h4><blockquote><p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:</p></blockquote><ul><li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li><li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</li></ul><p>写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private volatile int a;</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  0x0000000002951563: and    $0xffffffffffffff87,%rdi</span><br><span class="line">  0x0000000002951567: je     0x00000000029515f8</span><br><span class="line">  0x000000000295156d: test   $0x7,%rdi</span><br><span class="line">  0x0000000002951574: jne    0x00000000029515bd</span><br><span class="line">  0x0000000002951576: test   $0x300,%rdi</span><br><span class="line">  0x000000000295157d: jne    0x000000000295159c</span><br><span class="line">  0x000000000295157f: and    $0x37f,%rax</span><br><span class="line">  0x0000000002951586: mov    %rax,%rdi</span><br><span class="line">  0x0000000002951589: or     %r15,%rdi</span><br><span class="line">  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br><span class="line">  0x0000000002951591: jne    0x0000000002951a15</span><br><span class="line">  0x0000000002951597: jmpq   0x00000000029515f8</span><br><span class="line">  0x000000000295159c: mov    0x8(%rdx),%edi</span><br><span class="line">  0x000000000295159f: shl    $0x3,%rdi</span><br><span class="line">  0x00000000029515a3: mov    0xa8(%rdi),%rdi</span><br><span class="line">  0x00000000029515aa: or     %r15,%rdi</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效。</li></ul><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p><p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><h4 id="¶-lock-指令"><a href="#¶-lock-指令" class="headerlink" title="¶ lock 指令"></a><a href="#lock-%E6%8C%87%E4%BB%A4">¶</a> lock 指令</h4><p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(MESI)来保证。</p><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>​        缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ 嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p><h4 id="volatile有序性实现"><a href="#volatile有序性实现" class="headerlink" title="volatile有序性实现"></a>volatile有序性实现</h4><h6 id="volatile-的-happens-before-关系"><a href="#volatile-的-happens-before-关系" class="headerlink" title="volatile 的 happens-before 关系"></a>volatile 的 happens-before 关系</h6><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//假设线程A执行writer方法，线程B执行reader方法</span><br><span class="line">class VolatileExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    volatile boolean flag = false;</span><br><span class="line">    </span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1;              // 1 线程A修改共享变量</span><br><span class="line">        flag = true;        // 2 线程A写volatile变量</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (flag) &#123;         // 3 线程B读同一个volatile变量</span><br><span class="line">        int i = a;          // 4 线程B读共享变量</span><br><span class="line">        ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p><ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-volatile-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-volatile-1" style="zoom:200%;"><p>因为以上规则，当线程A将volatile变量flag更改为true后，线程B能够迅速感知。</p><h6 id="volatile禁止重排序"><a href="#volatile禁止重排序" class="headerlink" title="volatile禁止重排序"></a>volatile禁止重排序</h6><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM 会针对编译器制定 volatile 重排序规则表。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/volatile.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="volatile" style="zoom:200%;"><p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/store.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="store" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-volatile-3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-volatile-3" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-volatile-4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-volatile-4" style="zoom:200%;"><h2 id="volatile的应用场景"><a href="#volatile的应用场景" class="headerlink" title="volatile的应用场景"></a>volatile的应用场景</h2><p>使用 volatile 必须具备的条件</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h4 id="模式一：状态标志"><a href="#模式一：状态标志" class="headerlink" title="模式一：状态标志"></a>模式一：状态标志</h4><p>​        也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean shutdownRequested;</span><br><span class="line">......</span><br><span class="line">public void shutdown() &#123; shutdownRequested = true; &#125;</span><br><span class="line">public void doWork() &#123; </span><br><span class="line">    while (!shutdownRequested) &#123; </span><br><span class="line">        // do stuff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式二：一次性安全发布"><a href="#模式二：一次性安全发布" class="headerlink" title="模式二：一次性安全发布"></a>模式二：一次性安全发布</h4><p>​        缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class BackgroundFloobleLoader &#123;</span><br><span class="line">    public volatile Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    public void initInBackground() &#123;</span><br><span class="line">        // do lots of stuff</span><br><span class="line">        theFlooble = new Flooble();  // this is the only write to theFlooble</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class SomeOtherClass &#123;</span><br><span class="line">    public void doWork() &#123;</span><br><span class="line">        while (true) &#123; </span><br><span class="line">            // do some stuff...</span><br><span class="line">            // use the Flooble, but only if it is ready</span><br><span class="line">            if (floobleLoader.theFlooble != null) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式三：独立观察"><a href="#模式三：独立观察" class="headerlink" title="模式三：独立观察"></a>模式三：独立观察</h4><p>​        安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserManager &#123;</span><br><span class="line">    public volatile String lastUser;</span><br><span class="line"> </span><br><span class="line">    public boolean authenticate(String user, String password) &#123;</span><br><span class="line">        boolean valid = passwordIsValid(user, password);</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">            User u = new User();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        return valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式四：volatile-bean模式"><a href="#模式四：volatile-bean模式" class="headerlink" title="模式四：volatile bean模式"></a>模式四：volatile bean模式</h4><p>​        在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private volatile String firstName;</span><br><span class="line">    private volatile String lastName;</span><br><span class="line">    private volatile int age;</span><br><span class="line"> </span><br><span class="line">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class="line">    public String getLastName() &#123; return lastName; &#125;</span><br><span class="line">    public int getAge() &#123; return age; &#125;</span><br><span class="line"> </span><br><span class="line">    public void setFirstName(String firstName) &#123; </span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setLastName(String lastName) &#123; </span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setAge(int age) &#123; </span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式五：开销较低的读–写锁策略"><a href="#模式五：开销较低的读–写锁策略" class="headerlink" title="模式五：开销较低的读–写锁策略"></a>模式五：开销较低的读–写锁策略</h4><p>​        volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class CheesyCounter &#123;</span><br><span class="line">    // Employs the cheap read-write lock trick</span><br><span class="line">    // All mutative operations MUST be done with the &#x27;this&#x27; lock held</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private volatile int value;</span><br><span class="line"> </span><br><span class="line">    public int getValue() &#123; return value; &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized int increment() &#123;</span><br><span class="line">        return value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式6：双重检查"><a href="#模式6：双重检查" class="headerlink" title="模式6：双重检查"></a>模式6：双重检查</h4><p>​        单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            syschronized(Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h1><h2 id="面试问题：-2"><a href="#面试问题：-2" class="headerlink" title="面试问题："></a>面试问题：</h2><p>所有的final修饰的字段都是编译期常量吗?</p><p>如何理解private所修饰的方法是隐式的final?</p><p>说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?</p><p>final方法可以被重载吗? 可以</p><p>父类的final方法能不能够被子类重写? 不可以</p><p>说说final域重排序规则?</p><p>说说final的原理?</p><p>使用 final 的限制条件和局限性?</p><p>看本文最后的一个思考题</p><h2 id="final基础使用"><a href="#final基础使用" class="headerlink" title="final基础使用"></a>final基础使用</h2><h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><p>注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</p><blockquote><p>这里顺道说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? @pdai</p></blockquote><p>​        设计模式中最重要的两种关系，一种是继承/实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合, 如下代码大概写个组合实现的意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @pdai</span><br><span class="line">*/</span><br><span class="line">class MyString&#123;</span><br><span class="line"></span><br><span class="line">    private String innerString;</span><br><span class="line"></span><br><span class="line">    // ...init &amp; other methods</span><br><span class="line"></span><br><span class="line">    // 支持老的方法</span><br><span class="line">    public int length()&#123;</span><br><span class="line">        return innerString.length(); // 通过innerString调用老的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加新方法</span><br><span class="line">    public String toMyString()&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><blockquote><p>常规的使用就不说了，这里说下:</p></blockquote><ul><li>private 方法是隐式的final</li><li>final方法是可以被重载的</li></ul><h4 id="¶-private-final"><a href="#¶-private-final" class="headerlink" title="¶ private final"></a><a href="#private-final">¶</a> private final</h4><p>类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。看下下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Base &#123;</span><br><span class="line">    private void test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Base&#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son son = new Son();</span><br><span class="line">        Base father = son;</span><br><span class="line">        //father.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        Base和Son都有方法test(),但是这并不是一种覆盖，因为private所修饰的方法是隐式的final，也就是无法被继承，所以更不用说是覆盖了，在Son中的test()方法不过是属于Son的新成员罢了，Son进行向上转型得到father，但是father.test()是不可执行的，因为Base中的test方法是private的，无法被访问到。</p><h4 id="final方法是可以被重载的"><a href="#final方法是可以被重载的" class="headerlink" title="final方法是可以被重载的"></a>final方法是可以被重载的</h4><p>​        我们知道父类的final方法是不能够被子类重写的，那么final方法可以被重载吗? 答案是可以的，下面代码是正确的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class FinalExampleParent &#123;</span><br><span class="line">    public final void test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test(String str) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h4><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p><h3 id="¶-修饰变量"><a href="#¶-修饰变量" class="headerlink" title="¶ 修饰变量"></a><a href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F">¶</a> 修饰变量</h3><blockquote><p>常规的用法比较简单，这里通过下面三个问题进一步说明。</p></blockquote><h4 id="¶-所有的final修饰的字段都是编译期常量吗"><a href="#¶-所有的final修饰的字段都是编译期常量吗" class="headerlink" title="¶ 所有的final修饰的字段都是编译期常量吗?"></a><a href="#%E6%89%80%E6%9C%89%E7%9A%84final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E9%83%BD%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%90%97">¶</a> 所有的final修饰的字段都是编译期常量吗?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    //编译期常量</span><br><span class="line">    final int i = 1;</span><br><span class="line">    final static int J = 1;</span><br><span class="line">    final int[] a = &#123;1,2,3,4&#125;;</span><br><span class="line">    //非编译期常量</span><br><span class="line">    Random r = new Random();</span><br><span class="line">    final int k = r.nextInt();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        <strong>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</strong></p><h4 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h4><p>​        一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    static Random r = new Random();</span><br><span class="line">    final int k = r.nextInt(10);</span><br><span class="line">    static final int k2 = r.nextInt(10); </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test t1 = new Test();</span><br><span class="line">        System.out.println(&quot;k=&quot;+t1.k+&quot; k2=&quot;+t1.k2);</span><br><span class="line">        Test t2 = new Test();</span><br><span class="line">        System.out.println(&quot;k=&quot;+t2.k+&quot; k2=&quot;+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k=2 k2=7</span><br><span class="line">k=8 k2=7</span><br></pre></td></tr></table></figure><p>​        我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p><h4 id="blank-final"><a href="#blank-final" class="headerlink" title="blank final"></a>blank final</h4><p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p><ul><li>在定义处进行赋值(这不叫空白final)</li><li>在构造器中进行赋值，保证了该值在被使用前赋值。</li></ul><p>这增强了final的灵活性。</p><p>看下面代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    final int i1 = 1;</span><br><span class="line">    final int i2;//空白final</span><br><span class="line">    public Test() &#123;</span><br><span class="line">        i2 = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public Test(int x) &#123;</span><br><span class="line">        this.i2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="final域重排序规则："><a href="#final域重排序规则：" class="headerlink" title="final域重排序规则："></a>final域重排序规则：</h2><p>​        上面我们聊的final使用，应该属于Java基础层面的，当理解这些后我们就真的算是掌握了final吗? 有考虑过final在多线程并发的情况吗? 在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下,final会进行怎样的重排序? 会导致线程安全的问题吗? 下面，就来看看final的重排序。</p><h3 id="¶-final域为基本类型"><a href="#¶-final域为基本类型" class="headerlink" title="¶ final域为基本类型"></a><a href="#final%E5%9F%9F%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">¶</a> final域为基本类型</h3><p>先看一段示例性的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class FinalDemo &#123;</span><br><span class="line">    private int a;  //普通域</span><br><span class="line">    private final int b; //final域</span><br><span class="line">    private static FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">    public FinalDemo() &#123;</span><br><span class="line">        a = 1; // 1. 写普通域</span><br><span class="line">        b = 2; // 2. 写final域</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        finalDemo = new FinalDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reader() &#123;</span><br><span class="line">        FinalDemo demo = finalDemo; // 3.读对象引用</span><br><span class="line">        int a = demo.a;    //4.读普通域</span><br><span class="line">        int b = demo.b;    //5.读final域</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="写final域重排序规则"><a href="#写final域重排序规则" class="headerlink" title="写final域重排序规则"></a>写final域重排序规则</h4><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外；</li><li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li></ul><p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：</p><ul><li>构造了一个FinalDemo对象；</li><li>把这个对象赋值给成员变量finalDemo。</li></ul><p>我们来画下存在的一种可能执行时序图，如下：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-final-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-final-1" style="zoom:200%;"><p>​        由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。</p><p>​        因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。</p><h4 id="读final域重排序规则"><a href="#读final域重排序规则" class="headerlink" title="读final域重排序规则"></a>读final域重排序规则</h4><p>读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p><p>read()方法主要包含了三个操作：</p><ul><li>初次读引用变量finalDemo;</li><li>初次读引用变量finalDemo的普通域a;</li><li>初次读引用变量finalDemo的final与b;</li></ul><p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-final-2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-final-2" style="zoom:200%;"><p>​        读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p><p>​        读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用</p><h3 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h3><p>我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了? 如果是引用数据类型了? 我们接着继续来探讨。</p><h4 id="¶-对final修饰的对象的成员域写操作"><a href="#¶-对final修饰的对象的成员域写操作" class="headerlink" title="¶ 对final修饰的对象的成员域写操作"></a><a href="#%E5%AF%B9final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%9F%9F%E5%86%99%E6%93%8D%E4%BD%9C">¶</a> 对final修饰的对象的成员域写操作</h4><p>​        针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceDemo &#123;</span><br><span class="line">    final int[] arrays;</span><br><span class="line">    private FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">    public FinalReferenceDemo() &#123;</span><br><span class="line">        arrays = new int[1];  //1</span><br><span class="line">        arrays[0] = 1;        //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writerOne() &#123;</span><br><span class="line">        finalReferenceDemo = new FinalReferenceDemo(); //3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writerTwo() &#123;</span><br><span class="line">        arrays[0] = 2;  //4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (finalReferenceDemo != null) &#123;  //5</span><br><span class="line">            int temp = finalReferenceDemo.arrays[0];  //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论(耐心看完才有收获)。</p><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-final-3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-final-3" style="zoom:200%;"><h4 id="对final修饰的对象的成员域读操作"><a href="#对final修饰的对象的成员域读操作" class="headerlink" title="对final修饰的对象的成员域读操作"></a>对final修饰的对象的成员域读操作</h4><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p><h3 id="¶-关于final重排序的总结"><a href="#¶-关于final重排序的总结" class="headerlink" title="¶ 关于final重排序的总结"></a><a href="#%E5%85%B3%E4%BA%8Efinal%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93">¶</a> 关于final重排序的总结</h3><p>按照final修饰的数据类型分类：</p><ul><li>基本数据类型:<ul><li><code>final域写</code>：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li><li><code>final域读</code>：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>引用数据类型：<ul><li><code>额外增加约束</code>：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li></ul></li></ul><h2 id="¶-final再深入理解"><a href="#¶-final再深入理解" class="headerlink" title="¶ final再深入理解"></a><a href="#final%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">¶</a> final再深入理解</h2><h3 id="¶-final的实现原理"><a href="#¶-final的实现原理" class="headerlink" title="¶ final的实现原理"></a><a href="#final%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">¶</a> final的实现原理</h3><p>上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p><p>很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器</p><h3 id="¶-为什么final引用不能从构造函数中“溢出”"><a href="#¶-为什么final引用不能从构造函数中“溢出”" class="headerlink" title="¶ 为什么final引用不能从构造函数中“溢出”"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88final%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BB%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E6%BA%A2%E5%87%BA">¶</a> 为什么final引用不能从构造函数中“溢出”</h3><p>这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。以下面的例子来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeDemo &#123;</span><br><span class="line">    private final int a;</span><br><span class="line">    private FinalReferenceEscapeDemo referenceDemo;</span><br><span class="line"></span><br><span class="line">    public FinalReferenceEscapeDemo() &#123;</span><br><span class="line">        a = 1;  //1</span><br><span class="line">        referenceDemo = this; //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (referenceDemo != null) &#123;  //3</span><br><span class="line">            int temp = referenceDemo.a; //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/2021/07/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread-x-key-final-4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="java-thread-x-key-final-4" style="zoom:200%;"><p>​        假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。</p><h3 id="¶-使用-final-的限制条件和局限性"><a href="#¶-使用-final-的限制条件和局限性" class="headerlink" title="¶ 使用 final 的限制条件和局限性"></a><a href="#%E4%BD%BF%E7%94%A8-final-%E7%9A%84%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7">¶</a> 使用 final 的限制条件和局限性</h3><p>当声明一个 final 成员时，必须在构造函数退出前设置它的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">  private final int myField = 1;</span><br><span class="line">  public MyClass() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">  private final int myField;</span><br><span class="line">  public MyClass() &#123;</span><br><span class="line">    ...</span><br><span class="line">    myField = 1;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。</p><p>下面的方法仍然可以修改该 list。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final List myList = new ArrayList();</span><br><span class="line">myList.add(&quot;Hello&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>声明为 final 可以保证如下操作不合法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myList = new ArrayList();</span><br><span class="line">myList = someOtherList;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全。</p><p>“ 其他方式 “ 可以包括声明成员为 volatile，使用 synchronized 或者显式 Lock 控制所有该成员的访问。</p><h3 id="¶-再思考一个有趣的现象："><a href="#¶-再思考一个有趣的现象：" class="headerlink" title="¶ 再思考一个有趣的现象："></a><a href="#%E5%86%8D%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%9A">¶</a> 再思考一个有趣的现象：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte b1=1;</span><br><span class="line">byte b2=3;</span><br><span class="line">byte b3=b1+b2;//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果对b1 b2加上final就不会出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final byte b1=1;</span><br><span class="line">final byte b2=3;</span><br><span class="line">byte b3=b1+b2;//不会出错，相信你看了上面的解释就知道原因了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-overview.html">https://www.pdai.tech/md/java/thread/java-thread-x-overview.html</a></p><p>官方文档 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html</a></p><p>并发官方教程 <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html">https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html</a></p><p>Doug Lea并发编程文章全部译文 <a href="http://ifeve.com/doug-lea/">http://ifeve.com/doug-lea/</a></p><p>Java并发知识点总结 <a href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p><p>线程与多线程必知必会(基础篇) <a href="https://zhuanlan.zhihu.com/p/33616143">https://zhuanlan.zhihu.com/p/33616143</a></p><p>著作权归<a href="https://pdai.tech所有./">https://pdai.tech所有。</a> 链接：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></p><p>《深入理解Java虚拟机》 +《Java并发编程的艺术》</p><p><a href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff">https://juejin.im/post/5ae6dc04f265da0ba351d3ff</a></p><p><a href="https://www.cnblogs.com/javaminer/p/3889023.html">https://www.cnblogs.com/javaminer/p/3889023.html</a></p><p><a href="https://www.jianshu.com/p/dab7745c0954">https://www.jianshu.com/p/dab7745c0954</a></p><p><a href="https://www.cnblogs.com/wuchaodzxx/p/6867546.html">https://www.cnblogs.com/wuchaodzxx/p/6867546.html</a></p><p><a href="https://www.cnblogs.com/xyabk/p/10901291.html">https://www.cnblogs.com/xyabk/p/10901291.html</a></p><p><a href="https://www.jianshu.com/p/64240319ed60">https://www.jianshu.com/p/64240319ed60</a></p><p><a href="https://blog.csdn.net/devotion987/article/details/68486942">https://blog.csdn.net/devotion987/article/details/68486942</a></p><p><a href="https://www.jianshu.com/p/ccfe24b63d87">https://www.jianshu.com/p/ccfe24b63d87</a></p><p><a href="https://www.jianshu.com/p/1e82c75034b7">https://www.jianshu.com/p/1e82c75034b7</a></p><p>《java并发编程的艺术》</p><p>《疯狂java讲义》</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java复习笔记2</title>
      <link href="2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="java复习笔记"><a href="#java复习笔记" class="headerlink" title="java复习笔记"></a>java复习笔记</h1><h2 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h2><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/collection1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="集合1" style="zoom:200%;"><h2 id="List集合："><a href="#List集合：" class="headerlink" title="List集合："></a>List集合：</h2><p>​        有序可重复。</p><p>​        有序：存进去的顺序和取出的顺序相同，每一个元素都有下标。</p><p>​        可重复：存进去1，可以在存储一个1.</p><p><strong>ArrayList</strong>:底层是数组，是线程非安全的。</p><p>Arraylist集合初始化的容量为10.</p><p>ArrayList集合底层是Object类型的数组。</p><p>扩容为原来的1.5倍。</p><p>建议给定一个预估计的初始化容量，减少数组的扩容次数—优化策略。</p><p>优点：检索效率比较高、增删元素效率比较低。末尾添加元素效率也比较高。</p><p><strong>LinkedList集合</strong>：底层采用双向链表。</p><p>随机增删效率较高，检索效率较低。</p><p>链表上的元素在空间存储上，内存地址不连续。</p><p><strong>Vector</strong>：底层是数组，vector集合是线程安全的，所有的方法都有synchronized关键字，效率比较低。</p><p>怎么将线程不安全的ArrayList集合转换成线程安全的。<br>     使用集合工具类，</p><p>Java.util.Collection 是集合接口</p><p>Java.util.Collections 是集合工具类</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/collections.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="collections" style="zoom:200%;"><p><strong>Set</strong>：集合存储 元素：无序不可重复。</p><p>无序:存进去这个顺序，取出来就不一定是这个顺序了。</p><p>Set集合中元素没有下标，Set集合中的元素不能重复。</p><p>HashSet：实际上HashSet集合new的时候，底层实际上new了一个HashMap集合。向HashSet集合中存储元素，实际上是存储到了HashMap中。HashMap集合是一个哈希表数据结构。HashSet集合初始化容量是16，初始化容量建议是2的倍数。扩容：扩容之后是原来的2倍。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashset.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashset" style="zoom:200%;"><p>SortedSet集合：这是个接口。由于继承Set集合，所以特点是无序不可重复，但是放在SortedSet集合中的元素可以自动排序，称之为可排序集合。</p><p>TreeSet集合：底层实际上是一个TreeMap,new TreeSet集合的时候，实际上new了一个TreeMap集合，TreeMap集合底层采用了二叉树数据结构。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/collection2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="集合2" style="zoom:200%;"><p>Map集合和Collection集合没有关系。</p><p>Map集合以key和value这种键值对的方式存储元素。</p><p>key和value都是存储java对象的内存地址</p><p>所有Map集合的key特点：无序不可重复。Map集合的key和Set集合存储元素特点相同。</p><p>HashMap：HashMap集合底层是哈希表，是非线程安全的。在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于6个时，会重新把红黑树变成单向链表数据结构。这种方式是为了提高检索效率，二叉树的检索会再次缩小扫描范围，提高效率。HashMap集合初始化容量16，默认加载因子0.75，扩容之后的容量是元容量的2倍。集合中的key和value允许为null。</p><p>Hashtable：Hashtable集合底层也是哈希表数据结构，是线程安全的，所有方法都带有synchronized关键字，效率比较低。Hashtable集合的key和value不允许为null。Hashtable集合初始化容量为11，扩容是原容量*2 + 1.</p><p>Properties：继承自Hashtable，是线程安全的。存储元素的时候key和value只支持String类型不支持其他类型，properties被称为属性类。</p><p>SortedMap：这是个接口。SortedMap集合的key存储元素的特点：首先是无序不可重复，另外放在SortedMap集合key部分的元素会自动按照大小顺序排序，称为可排序集合。</p><p>TreeMap：TreeMap集合底层是一个二叉树</p><h6 id="Map接口的常用方法："><a href="#Map接口的常用方法：" class="headerlink" title="Map接口的常用方法："></a>Map接口的常用方法：</h6><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/map1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="map1" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/map2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="map2" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/map3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="map3" style="zoom:200%;"><h2 id="集合的遍历和迭代："><a href="#集合的遍历和迭代：" class="headerlink" title="集合的遍历和迭代："></a>集合的遍历和迭代：</h2><p>Collection中的通用方式：map集合没有继承Iterator，所以没有迭代器。</p><p>调iterator方法得到迭代器，迭代器是一个对象，it保存的对象的内存地址，是一个引用。迭代器对象有两个方法next（）和hasnext（）。next（）方法取出来统一都是Object。</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/iterator.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="iterator"></p><p>集合是无限的会自动扩容。迭代器的执行原理。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/iteratoryuanli.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="iteratoryuanli" style="zoom:200%;"><p>Collection中的contains方法：用来判断集合中是否包含某个元素，在底层调用了equals方法，如果包含返回true，否则返回false。</p><p>String中的equals方法已经重写，比较的是内容，不是内存地址。</p><p><strong>放在集合中的元素（类型）要重写equals方法。</strong></p><p>Collection中的remove方法：也调用了equals方法</p><p><strong>关于集合元素的remove方法：</strong></p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/remove.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="remove" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/remove2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="remove2" style="zoom:200%;"><p>重点：</p><p>当集合结构发生改变时，迭代器必须重新获取，如果还是以前老的迭代器，会出现异常。</p><p>在迭代集合元素过程中，不能调用集合对象的remove（）方法，删除元素。会出现异常。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/remove3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="remove3" style="zoom:200%;"><p>但是可以用迭代器的remove（）方法，原理是会把迭代器快照中的对应的元素也删掉。</p><p>通过集合去删除元素没有通知迭代器，导致迭代器的快照和原集合不一样。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/remove4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="remove4" style="zoom:200%;"><p>集合状态发生变化，需要重新获取迭代器。</p><p>删除元素时一定要使用迭代器的remove方法，不要使用集合自带的remove方法</p><p>放在集合中的元素是需要重写equals方法的</p><p>特别的：list集合有下标，可以根据下标获取元素。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/listxiabiao.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="listxiabiao" style="zoom:200%;"><p>set集合：可以用增强for循环，虽然没有下标。</p><p><strong>Map集合的遍历：</strong></p><p>1.获取所有的key，通过遍历key获取value。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/mapbianli.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="mapbianli" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/mapbianli2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="mapbianli2" style="zoom:200%;"><p>2.通过map的entryset方法把map集合直接转换成set集合，set集合中的元素是Map.Entry&lt;Interger, String&gt; 类型的对象。（效率比较高）</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/entry1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="entry1" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/entry2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="entry2" style="zoom:200%;"><p>下边这种效率比较高直接获取key和value</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/entry3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="entry3" style="zoom:200%;"><h6 id="HashMap开始：HashMap集合底层是一个哈希表，哈希表是数组和单向链表的结合体。哈希值（哈希值是key的hashcode（）方法的执行结果，hash值通过哈希函数可以转换成数组的下标）"><a href="#HashMap开始：HashMap集合底层是一个哈希表，哈希表是数组和单向链表的结合体。哈希值（哈希值是key的hashcode（）方法的执行结果，hash值通过哈希函数可以转换成数组的下标）" class="headerlink" title="HashMap开始：HashMap集合底层是一个哈希表，哈希表是数组和单向链表的结合体。哈希值（哈希值是key的hashcode（）方法的执行结果，hash值通过哈希函数可以转换成数组的下标）"></a>HashMap开始：HashMap集合底层是一个哈希表，哈希表是数组和单向链表的结合体。哈希值（哈希值是key的hashcode（）方法的执行结果，hash值通过哈希函数可以转换成数组的下标）</h6><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashmap1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashmap1" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashmap2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashmap2" style="zoom:200%;"><p>一维数组，数组中每个元素是一个单向链表。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashmap3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashmap3" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashmap4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashmap4" style="zoom:200%;"><p>hash表的随机增删和查询的效率都很高。增删是在链表上完成的，查询只进行了部分扫描。</p><p>HashMap集合的key，会先后调用两个方法，一个方法是hashCode（），一个方法是equals（），这两个方法都需要重写。同一个链表撒花姑娘所有的hash值一样，同一个链表上的k和k的equals方法返回值是false，都不相等。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashmap5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashmap5" style="zoom:200%;"><p>hashcode（）方法需要重写，但是返回值不能都一样，否则就会单向链表。</p><p>hashcode（）方法需要重写，也不能都不一样，否则会变成数组</p><p>HashMap的key部分的元素，无序不可重复。需要同时重写hashcode和equals方法 。如果一个类的equals方法重写了，hashcode方法必须重写。equals方法返回结果为true，hashcode方法返回值必须一样。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashmap6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashmap6" style="zoom:200%;"><p>下边的情况不用调用equals方法：</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/hashmap7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="hashmap7" style="zoom:200%;"><h6 id="TreeSet集合："><a href="#TreeSet集合：" class="headerlink" title="TreeSet集合："></a>TreeSet集合：</h6><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset4" style="zoom:200%;"><p>对自定义的类型TreeSet可以自动排序吗？</p><p>不可以，如果没有指定自定义类实例化的对象之间的比较规则，谁大谁小并没有说明。</p><p>class com.xidian.javase.Collection.Wugui cannot be cast to class java.lang.Comparable</p><p>不指定排序规则会出现上述的异常，没有转化为Comparable</p><p>需要继承Comparable接口，并且实现toString方法</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset" style="zoom:200%;"><p>TreeSet集合中元素可排序的第一种方式：自定义的类继承Comparable接口，重写compareTo（）方法，自定义大小规则。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset2" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset3" style="zoom:200%;"><p>TreeSet集合中元素可排序的第二种方法，使用比较器的方式。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset5" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset6" style="zoom:200%;"><p>单独编写一个比较器：</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset7" style="zoom:200%;"><p>单独编写的比较器，也可以采用匿名内部的方法。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset8" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B02/treeset10.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="treeset10" style="zoom:200%;">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2021/07/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2021/07/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>排序：对一序列对象根据某个关键字进行排序</p><p>术语说明：</p><p>​        稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p>​        不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面。</p><p>​        内排序：所有排序操作都在内存中完成的。</p><p>​        外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</p><p>​        时间复杂度：一个算法执行所耗费的时间。</p><p>​        空间复杂度：运行完一个程序所需要的的内存大小。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="排序总结" style="zoom:200%;"><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>​        冒泡排序：重复的走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 特点：稳定排序、平均时间复杂度o(n的平方)</span><br><span class="line">* 思想：有多少个待排元素就需要多少次排序。每次排序的结果会把最大的放在最后，排序的过程是相邻元素比较，排序的个数不包括已经排好的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int[] bubbleSort(int[] nums)&#123;</span><br><span class="line">        int temp;</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        //length长度的数组，需要进行length次循环进行排序</span><br><span class="line">        for (int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            //每次排序的个数不包括已经排好的元素，所以每次排序的个数都会递减。而且都是从第一个元素开始比较</span><br><span class="line">            for (int j = 0; j &lt; length - 1 - i; j++)&#123;</span><br><span class="line">                if (nums[j] &gt; nums[j +1])&#123;</span><br><span class="line">                    temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j +1];</span><br><span class="line">                    nums[j + 1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>​        表现最稳定的排序算法，无论什么样的数据都是0（n平方）的时间复杂度。优点不占用额外的内存空间。</p><p>​        选择排序：首先在未排序序列中找到最小或最大的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中寻找最小或最大元素，然后放到已排序序列的末尾。以此类推，直到所有元素排序完成。</p><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int[] selectionSort(int[] array)&#123;</span><br><span class="line">        if (array.length == 0)&#123;</span><br><span class="line">            return array;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++)&#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            for (int j = i; j &lt; array.length; j++)&#123;</span><br><span class="line">                if (array[j] &lt; array[minIndex])&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int temp = array[minIndex];</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>​        插入排序的算法描述是一种简单直观的排序算法。工作原理是通过构建有序序列，对于未排序数据，在已排序的序列中从后向前扫描，找到响应位置并插入。</p><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int[] insert(int[] array)&#123;</span><br><span class="line">        if (array.length == 0)&#123;</span><br><span class="line">            return array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int current;</span><br><span class="line">        for (int i = 0; i &lt; array.length - 1; i++)&#123;</span><br><span class="line">            current = array[i + 1];</span><br><span class="line">            int preIndex = i;</span><br><span class="line">            while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex])&#123;</span><br><span class="line">                array[preIndex + 1] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + 1] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>​        归并排序的性能不受输入数据的影响，但是时间复杂度为o（nlogn）。代价是需要额外的内存空间。</p><p>​        归并排序是建立在归并操作上的一种有效的排序算法。该算法是分治法的典型应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并为一个有序表，称为2-路归并。</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static int[] MergeSort(int[] array) &#123;</span><br><span class="line">       if (array.length &lt; 2) return array;</span><br><span class="line">       int mid = array.length / 2;</span><br><span class="line">       int[] left = Arrays.copyOfRange(array, 0, mid);</span><br><span class="line">       int[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">       return merge(MergeSort(left), MergeSort(right));</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * 归并排序——将两段排序好的数组结合成一个排序数组</span><br><span class="line">    *</span><br><span class="line">    * @param left</span><br><span class="line">    * @param right</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static int[] merge(int[] left, int[] right) &#123;</span><br><span class="line">       int[] result = new int[left.length + right.length];</span><br><span class="line">       for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) &#123;</span><br><span class="line">           if (i &gt;= left.length)</span><br><span class="line">               result[index] = right[j++];</span><br><span class="line">           else if (j &gt;= right.length)</span><br><span class="line">               result[index] = left[i++];</span><br><span class="line">           else if (left[i] &gt; right[j])</span><br><span class="line">               result[index] = right[j++];</span><br><span class="line">           else</span><br><span class="line">               result[index] = left[i++];</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>​        通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，在分别对两部分继续进行排序，已达到整个序列有序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-27</title>
      <link href="2021/07/27/7-27/"/>
      <url>2021/07/27/7-27/</url>
      
        <content type="html"><![CDATA[<h1 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671.二叉树中第二小的节点"></a>671.二叉树中第二小的节点</h1><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p>更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</p><p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p><p>思路：BFS和集合排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int findSecondMinimumValue(TreeNode root)&#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty())&#123;</span><br><span class="line">        int size = queue.size();</span><br><span class="line">        TreeNode node = queue.remove();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        if (node.left != null)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = list.get(0);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    for (int rev : list)&#123;</span><br><span class="line">        if (rev &gt; ans)&#123;</span><br><span class="line">            return rev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="2021/07/27/java/"/>
      <url>2021/07/27/java/</url>
      
        <content type="html"><![CDATA[<h1 id="java笔记复习"><a href="#java笔记复习" class="headerlink" title="java笔记复习"></a>java笔记复习</h1><h6 id="方法重载：与返回值类型无关，与修饰符列表无关"><a href="#方法重载：与返回值类型无关，与修饰符列表无关" class="headerlink" title="方法重载：与返回值类型无关，与修饰符列表无关"></a>方法重载：与返回值类型无关，与修饰符列表无关</h6><p>什么时候考虑方法重载：在同一个类中，方法一和方法二功能相似，可以考虑将它们的方法名一致。</p><p>什么时候会发生重载：同一个类中，方法名相同，参数列表不同（参数个数、参数类型、参数顺序不同）会发生重载。</p><h6 id="方法递归："><a href="#方法递归：" class="headerlink" title="方法递归："></a>方法递归：</h6><p>​        方法自己调用自己，递归一定要有结束条件。</p><p>​        先检查递归的结束条件对不对</p><p>​        手动调整JVM栈内存初始化大小，将栈内存大小调大</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/digui.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="递归"></p><h6 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h6><p>​        变量根据出现的位置：局部变量、成员变量（实例变量和静态变量）</p><p>​        局部变量：方法体内声明，不会默认赋值。变量必须先声明再赋值才能访问。局部变量只在方法体（在自己的作用域）中有效，方法结束，内存释放。</p><p>​        实例变量：方法体外声明，实例变量没有手动赋值，系统会默认赋值（构造方法执行的时候）。实例变量时对象级别的变量，必须先创建对象才能访问，不能通过类名直接访问。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/morenzhi.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="默认值" style="zoom:150%;"><p>​        静态变量：类变量。</p><h6 id="对象和引用的区别？"><a href="#对象和引用的区别？" class="headerlink" title="对象和引用的区别？"></a>对象和引用的区别？</h6><p>​        对象是通过new出来的，在堆内存中存储。</p><p>​        引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。保存地址指向堆内存中的对象</p><p>​        保存对象内存地址的变量称为引用</p><p>​        对象在内存中的内存地址，附给实例化过程中的变量名</p><p>​        访问实例变量：引用.实例变量名    </p><p>​        因为java中没有指针，所以只能通过引用来操作堆内存</p><p>​        <u><em><strong>引用不一定是局部变量，也可能是实例变量</strong></em>。</u></p><h2 id="方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。"><a href="#方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。" class="headerlink" title="方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。"></a>方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。</h2><p>​        Java中其实都是值传递，只是有的时候是传递的数据的值，有的时候呢传递的是引用地址的值</p><h6 id="对于基本数据类型来说："><a href="#对于基本数据类型来说：" class="headerlink" title="对于基本数据类型来说："></a>对于基本数据类型来说：</h6><p>传递的是数据的值，在接受参数的函数里改变的时候原来的是不会有任何影响的。</p><h6 id="对于引用类型来说："><a href="#对于引用类型来说：" class="headerlink" title="对于引用类型来说："></a>对于引用类型来说：</h6><p>传递的是一个引用、这个引用存放的是<strong>参数的地址的值</strong>，如果在函数中没有改变这个参数的引用地址（没有new一个新的地址—这也叫做浅拷贝），那么就会改变原来的值，影响到传入的参数。（比如数组、集合就是很明显的例子）；如果在函数中改变了参数的引用地址,也就是new了一个，那就不会改变参数的值了，这也叫做深拷贝。</p><h6 id="对于String类型和包装类型来说："><a href="#对于String类型和包装类型来说：" class="headerlink" title="对于String类型和包装类型来说："></a>对于String类型和包装类型来说：</h6><hr><blockquote><p>String类型和包装类型都是对象类型，所以必然是引用传递</p></blockquote><hr><p>​        但是由于String类和包装类都被设定成不可变的&lt;这里应该可以理解为什么说String是不可变的，StringBuilder是可变的&gt;，没有提供value对应的setter方法，而且很多都是final的，我们无法改变其内容，所以导致我们看起来好像是值传递（即没有影响原来的值）。</p><p>​        理由很简单，Integer 类中value字段是final的，说明一旦integer类创建之后他的值就不能被修改，在 index++ 的时候Integer是创建一个新的类，所以这个第二次输出的时候结果是一样的！所以对于包装类和String来说，他们是不可变类，进入一个方法后，在里面的值的改变不会影响方法外的引用</p><h2 id="类方法和实例方法："><a href="#类方法和实例方法：" class="headerlink" title="类方法和实例方法："></a>类方法和实例方法：</h2><p><strong>类方法</strong></p><p>用static修饰的方法。</p><p>由于类方法是属于整个类的，所以类方法的方法体中不能有与类的对象有关的内容。</p><p>即类方法体有如下限制：</p><p>1.类方法中不能引用对象变量；</p><p>2.类方法中不能调用类的对象方法；</p><p>3.在类方法中不能调使用super，this关键字；</p><p>4.类方法不能被覆盖。</p><p><strong>实例方法</strong></p><p>当一个类创建了一个对象后，这个对象就可以调用该类的方法（对象方法）。</p><p>1.实例方法中可以引用对象变量，也可以引用类变量；</p><p>2.实例方法中可以调用类方法；</p><p>3.对象方法中可以使用super，this关键字。</p><p><strong>区别和注意事项</strong></p><p>区别：类方法可以通过类名调用，实例方法不能通过类名调用</p><p>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址</p><p>当该类创建对象后，类中的实例方·法才分配入口地址，</p><p>从而实例方法可以被类创建的任何对象调用执行。</p><p>类方法在该类被加载到内存时，就分配了相应的入口地址。</p><p>从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。</p><p>类方法的入口地址直到程序退出时才被取消。</p><p>注意：</p><p>当我们创建第一个对象时，类中的实例方法就分配了入口地址（也就是实例方法的引用，在堆区。真正的方法体在方法区），当再创建对象时，不再分配入口地址。</p><p>也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。</p><p>在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址</p><p>如果一个类中所有的方法都是静态的，需要将该类的构造方法私有化。目的是防止在其他类中创建该类的实例对象，通过实例对象来调用这些静态方法，浪费空间。</p><p>只要是方法，不管是静态方法（类级别的）、实例方法（实例、对象级别）、构造方法（用来完成对象的创建和实例边变量的赋值）、main方法，运行的时候都需要压栈</p><h2 id="静态变量和实例变量："><a href="#静态变量和实例变量：" class="headerlink" title="静态变量和实例变量："></a>静态变量和实例变量：</h2><p>静态变量一般都会赋值，不赋值类加载会初始化，静态变量只能是成员变量（也就是说只能定义在方法体外，类体中）</p><p>静态变量方法区中（类相关的，使用类名.的方式访问）、实例变量堆中（对象级别的，必须先new对象，通过引用.的方式访问）、局部变量栈中  。</p><p> 只有类才存在静态的变量 方法只能对静态变量的操作 不能在方法内试图定义静态变量。</p><p>实例变量必须用引用来访问</p><p>静态变量，建议使用类名访问，但是也可以使用引用点的方式访问</p><p>类方法可以通过类名调用，实例方法不能通过类名调用</p><p>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址</p><p>当该类创建对象后，类中的实例方·法才分配入口地址，</p><p>从而实例方法可以被类创建的任何对象调用执行。</p><p>类方法在该类被加载到内存时，就分配了相应的入口地址。</p><p>从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。</p><p>类方法的入口地址直到程序退出时才被取消。</p><h2 id="静态代码块和动态代码块："><a href="#静态代码块和动态代码块：" class="headerlink" title="静态代码块和动态代码块："></a>静态代码块和动态代码块：</h2><img "" class="lazyload placeholder" data-original="/2021/07/27/java/staticCode.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="静态代码块" style="zoom:150%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java/staticCodeUse.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="静态代码块的作用" style="zoom:150%;"><p>静态变量和静态代码块都是类加载的时候执行，只能根据代码的先后来判断</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/staticandstatic.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="静态变量和静态代码块" style="zoom:150%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java/dongtaicode.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="动态代码块" style="zoom:150%;"><h2 id="this关键字和super关键字："><a href="#this关键字和super关键字：" class="headerlink" title="this关键字和super关键字："></a>this关键字和super关键字：</h2><p>1.1、this是一个关键字，是一个引用，保存内存地址指向自身。</p><p>1.2、this可以使用在实例方法中，也可以使用在构造方法中。</p><p>1.3、this出现在实例方法中其实代表的是当前对象。</p><p>1.4、this不能使用在静态方法中。</p><p>1.5、this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。</p><p>1.6、this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/this.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="dogntai"><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/thisMem.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="this"></p><p>super关键字（构造方法默认是有super（））。super代表当前对象的父类型特征</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/super.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="super" style="zoom:200%;"><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/super2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="super2"></p><p>super（），通过子类的构造方法调用父类的无参数构造方法。</p><p>super（1000），通过子类的构造方法调用父类的有参数构造方法。</p><p>5.this（）和super（）不能共存，他们都是出现在构造方法的第一行</p><p>什么都不写默认是有super（）的，写了super（）没影响，写了super（123）就没有super（）了，写了this（）就没有super（）了。</p><p>this（）和super（）不能共存，this（）调本类的构造方法，super（）调父类的构造方法</p><p>在恰当时间使用super（实际参数列表），初始化当前对象的父类型特征。</p><p>已经继承过来的父类型特征是属于子类的</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/super3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="super3"></p><p>6.无论什么情况，父类的构造方法一定会执行。</p><p>默认类的构造方法里边有super（），不管是new什么对象，老祖宗object类的无参数构造方法一定会执行。（object类的无参数构造方法处于栈顶部）</p><p>super能出现在实例方法和构造方法中。</p><p>super的语法是：“super.”、“super()”</p><p>super不能使用在静态方法中。</p><p>super. 大部分情况下是可以省略的。</p><p>super.什么时候不能省略呢？</p><p>父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，super. 不能省略。</p><p>对于继承只有方法才存在覆盖的说法，属性可以存在同名属性。 </p><p>super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中</p><p>的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。</p><p>super的使用：</p><p>super.属性名                【访问父类的属性】</p><p>super.方法名(实参)        【访问父类的方法】</p><p>super(实参)                    【调用父类的构造方法】</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/super6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="super6"></p><h2 id="final关键字："><a href="#final关键字：" class="headerlink" title="final关键字："></a>final关键字：</h2><p>final：关键字，表示的是最后的、不能变的、不能改的</p><p>可以修饰变量、方法、类</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/final.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="final"></p><p>final修饰的类无法被继承</p><p>final修饰的方法无法被覆盖，被重新 </p><p>final修饰的局部变量（包括引用），一旦赋值不能重新赋值。（只能赋一次值）</p><p>final修饰的引用只能指向1个对象，并且只能永远指向该对象，无法在指向其他的对象。并且在该方法执行过程中，该引用指向对象后，该对象不会被垃圾回收期回收。但是所指向的对象内部数据可以改变</p><p>final修饰的实例变量，系统不会赋默认值，必须手动赋值，但是赶在系统赋默认值之前就行。</p><p>直接在变量后边赋值或者在构造方法中赋值</p><p>（实例变量没有赋默认值的时候，系统会赋默认值，构造方法执行的过程中赋值，new的时候）</p><p>常量：final修饰的实例变量都加上一个static</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/changliang.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="changliang"></p><h2 id="方法覆盖和方法重载："><a href="#方法覆盖和方法重载：" class="headerlink" title="方法覆盖和方法重载："></a>方法覆盖和方法重载：</h2><p>什么条件满足的时候构成方法覆盖？</p><p>第一：有继承关系的两个类</p><p>第二：具有相同方法名、返回值类型、形式参数列表</p><p>第三：访问权限不能更低，可以更高。Private&lt;protected&lt;public</p><p>第四：抛出异常不能更多,可以更少。</p><p>注意：方法覆盖只针对方法，和属性无关</p><p>​        私有方法无法覆盖</p><p>​        构造方法不能被继承，所以构造方法不能被覆盖</p><p>​        方法覆盖只是针对实例方法，静态方法覆盖没有意义</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/fugaichognzai.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="fugaichognzai"></p><p>方法重载和方法覆盖有什么区别？</p><p>方法重载发生在同一个类当中。</p><p>方法覆盖是发生在具有继承关系的父子类之间。</p><p>方法重载是一个类中，方法名相同，参数列表不同。</p><p>方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：</p><p>方法名一致、参数列表一致、返回值类型一致。</p><h2 id="Object类中的相关方法：toString（）方法、equals（）方法"><a href="#Object类中的相关方法：toString（）方法、equals（）方法" class="headerlink" title="Object类中的相关方法：toString（）方法、equals（）方法"></a>Object类中的相关方法：toString（）方法、equals（）方法</h2><p>toString()方法存在的作用就是：将java对象转换成字符串形式。</p><p>大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()</p><p>方法输出的是一个java对象的内存地址。</p><p>至于toString()方法具体怎么进行覆盖？</p><p>格式可以自己定义，或者听需求的。（听项目要求的。）</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/toString.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="toString"></p><p>public String toString(){</p><p>​        return year + “年” + month + “月” + day + “日”；</p><p>}</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/equals.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="equals"></p><p>equals方法里边内容为空，会出现空指针异常</p><p>判断两个基本数据类型直接使用“==”</p><p>判断两个java对象是否相等，不能使用“==”，其实双等号比较的两个对象的内存地址</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/equalsmoba.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="equalsmoba"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/toStringequals.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="toStringequals"></p><h2 id="抽象类和接口："><a href="#抽象类和接口：" class="headerlink" title="抽象类和接口："></a>抽象类和接口：</h2><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/abs1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="abs1"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/abs2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="abs2"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/abs3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="abs3"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/faceti.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="abs4"></p><p>接口的基础语法：接口也是一种引用数据类型</p><p>接口是完全抽象的，（抽象类是半抽象的）</p><p>定义：【修饰符列表】 interface 接口名{</p><p>}</p><p>【修饰符列表】class 类名{</p><p>}</p><p>【修饰符列表】abstract class 类名{</p><p>}</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/inter1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="inter1"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/inter2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="inter2"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/inter3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="inter3"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/inter4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="inter4"></p><p>抽象类和接口有什么区别？</p><p>在这里我们只说一下抽象类和接口在语法上的区别。</p><p>至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会/学习。</p><p>抽象类是半抽象的。</p><p>接口是完全抽象的。</p><p>抽象类中有构造方法。</p><p>接口中没有构造方法。（只有常量和抽象方法）</p><p>接口和接口之间支持多继承。</p><p>类和类之间只能单继承。</p><p>一个类可以同时实现多个接口。</p><p>一个抽象类只能继承一个类（单继承）。</p><p>接口中只允许出现常量和抽象方法。</p><p>这里先透露一个信息：</p><p>以后接口使用的比抽象类多。一般抽象类使用的还是少。</p><p>接口一般都是对“行为”的抽象。</p><p>接口的祖先也是object</p><h2 id="访问控制权限："><a href="#访问控制权限：" class="headerlink" title="访问控制权限："></a>访问控制权限：</h2><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/accessControal1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="accessControal1"></p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/accessControal2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="accessControal2"></p><h2 id="内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰"><a href="#内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰" class="headerlink" title="内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰"></a>内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰</h2><p>匿名内部类：是局部内部类的一种</p><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/inClass.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="inClass"></p><h2 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h2><img "" class="lazyload placeholder" data-original="/2021/07/27/java/stringConst.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="stringConst" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java/string1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="string1" style="zoom:200%;"><p>见双引号，字符串常量池中就有一份。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/string2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="string2" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java/string3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="string3" style="zoom:200%;"><p>构造方法：</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/string4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="string4" style="zoom:200%;"><p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/String6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="string6"></p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/string7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="string7" style="zoom:200%;"><img "" class="lazyload placeholder" data-original="/2021/07/27/java/string8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="string8" style="zoom:200%;"><h1 id="常见错误积累"><a href="#常见错误积累" class="headerlink" title="常见错误积累"></a>常见错误积累</h1><h6 id="1-空指针异常"><a href="#1-空指针异常" class="headerlink" title="1.空指针异常"></a>1.空指针异常</h6><p>空指针异常只有在空应用访问实例相关的才会出现</p><p>但是用空引用或者引用访问静态相关的，实际运行的时候还是会变成类名.的访问方式。</p><p>静态变量还可以有set get方法，通过set，get方法访问</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_四大组件</title>
      <link href="2021/07/26/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
      <url>2021/07/26/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h1><p>​        组件启动后，首先需要依赖进程，那么就需要先创建进程，系统需要记录每个进程，这便产生了ProcessRecord。 Android中，对于进程的概念被弱化，通过抽象后的四大组件。让开发者几乎感受不到进程的存在。 当应用退出时，进程也并非马上退出，而是成为cache/empty进程，下次该应用再启动的时候，可以不用 再创建进程直接初始化组件即可，提高启动速度。</p><p>​        Android系统中用于描述进程的数据结构是ProcessRecord对象，AMS便是管理进程的核心模块。四大组件 （Activity,Service, BroadcastReceiver, ContentProvider）定义在AndroidManifest.xml文件， 每一项都可以用属性android:process指定所运行的进程。同一个app可以运行在同一个进程，也可以运行在多个进程， 甚至多个app可以共享同一个进程</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_service</title>
      <link href="2021/07/26/android-service/"/>
      <url>2021/07/26/android-service/</url>
      
        <content type="html"><![CDATA[<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-26</title>
      <link href="2021/07/26/7-26/"/>
      <url>2021/07/26/7-26/</url>
      
        <content type="html"><![CDATA[<h1 id="1713-得到子序列的最少操作次数"><a href="#1713-得到子序列的最少操作次数" class="headerlink" title="1713.得到子序列的最少操作次数"></a>1713.得到子序列的最少操作次数</h1><p>给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。</p><p>每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。</p><p>请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。</p><p>一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。</p><p>示例 1：</p><p>输入：target = [5,1,3], arr = [9,4,2,3,4]<br>输出：2<br>解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。<br>示例 2：</p><p>输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]<br>输出：3</p><p>思路：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_binder</title>
      <link href="2021/07/25/android-binder/"/>
      <url>2021/07/25/android-binder/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_系统架构</title>
      <link href="2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
      <url>2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>​        Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/android-stack.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="android-stack"><p>​        Google提供的经典分层架构图，从下往上依次分为linux内核层、HAL、系统Native库和android运行时环境、java Framework、应用层。</p><p>​        从进程角度诠释android系统的全貌。</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/android-boot.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="android-boot"><p><strong>Loader层：</strong></p><ul><li>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片代码开始从固化在<code>ROM</code>里的预设代码开始执行，然后加载引导程序（BootLoader）到<code>RAM</code>；</li><li>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能，将操作系统OS拉起来并运行</li></ul><p><strong>Linux内核层：</strong>linux内核的安全机制为android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。</p><ul><li>swapper进程（pid=0）：又被称为idle进程，是系统初始化过程Kernel有无到有开创的第一个进程，用于初始化进程管理、内存管理、加载Display、Camera Driver、Binder Driver等工作。</li><li>kthreadd进程（pid=2）：是linux系统的内核进程，会创建内核工作线程kworkder、软中断线程ksoftirqd、thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。</li></ul><p><strong>硬件抽象层（HAL）：</strong></p><p>​        硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。</p><p><strong>Android Runtime 和 系统库：</strong></p><p>​        每个应用都在自己的进程中运行，都有自己的虚拟机实例。ART通过DEX文件可在设备运行多个虚拟机。DEX文件是一种专门为android设计的字节码格式文件。ART主要功能包括：预先（AOT）和即时编译（JIT），优化的垃圾回收（GC），以及相关调试的支持。</p><p>​        Native系统库主要包括init孵化来的用户空间的守护进程、HAL层、开机动画等。init进程是所有用户进程的鼻祖。</p><ul><li>init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</li><li>init进程还启动<code>servicemanager</code>(binder服务管家)、<code>bootanim</code>(开机动画)等重要服务</li><li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，<code>Zygote是所有Java进程的父进程</code>，Zygote进程本身是由init进程孵化而来的。</li></ul><p><strong>Framework层：</strong></p><p>​        （1）Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：</p><p>​        加载ZygoteInit类，注册Zygote Socket服务端套接字<br>​        加载虚拟机<br>​        提前加载类preloadClasses<br>​        提前加载资源preloadResouces</p><p>​        （2）System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。<br>​        （3）Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</p><p><strong>APP层：</strong></p><p>​        Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；</p><p>​        Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。<br>​        所有的App进程都是由Zygote进程fork生成的。</p><p><strong>Native与Kernel之间有一层系统调用SysCall层。</strong></p><p><strong>java层与Native层之间的纽带JNI。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_系统启动</title>
      <link href="2021/07/25/android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
      <url>2021/07/25/android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h1><p>​        Android系统底层基于Linux Kernel, 当Kernel启动过程会创建init进程, 该进程是所有用户空间的鼻祖, init进程会启动servicemanager(binder服务管家), Zygote进程(Java进程的鼻祖). Zygote进程会创建 system_server进程以及各种app进程，</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/android-booting.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="android-booting"><p><strong>swapper进程（pid=0）</strong>：又被称为idle进程，是系统初始化过程Kernel有无到有开创的第一个进程，用于初始化进程管理、内存管理、加载Display、Camera Driver、Binder Driver等工作。</p><p><strong>kthreadd进程（pid=2）</strong>：是linux系统的内核进程，会创建内核工作线程kworkder、软中断线程ksoftirqd、thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。</p><p>内核完成系统设置时，首先在系统文件中启动属性服务，并且启动Zygote进程。</p><p><strong>init进程：</strong></p><p>​        是什么？：init是linux系统中用户空间的第一个进程（pid=0）。</p><p>​        来源：kerner启动后会调用system/core/init/init.cpp文件中的main（）方法来启动init进程。由多个源文件组成，对应的源码目录在system/core/init中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    // 如果是初始化第一阶段，则需要执行下面的步骤1</span><br><span class="line">    if (is_first_stage) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 清理umask</span><br><span class="line">        umask(0);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 1、创建和挂载启动所需的文件目录</span><br><span class="line">        mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);</span><br><span class="line">        mkdir(&quot;/dev/pts&quot;, 0755);</span><br><span class="line">        mkdir(&quot;/dev/socket&quot;, 0755);</span><br><span class="line">        mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);</span><br><span class="line">        #define MAKE_STR(x) __STRING(x)</span><br><span class="line">        mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC));</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 初识化Kernel的Log，获取外界的Kernel日志</span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初识化Kernel的Log，获取外界的Kernel日志</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 2、初始化属性相关资源</span><br><span class="line">    property_init();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 创建epoll句柄</span><br><span class="line">    epoll_fd = epoll_createl(EPOLL_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 3、设置子信号处理函数</span><br><span class="line">    sigchld_handler_init();</span><br><span class="line"></span><br><span class="line">    // 导入默认的环境变量</span><br><span class="line">    property_load_boot_defaults();</span><br><span class="line"></span><br><span class="line">    // 4、启动属性服务</span><br><span class="line">    start_property_service();</span><br><span class="line">    set_usb_controller();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 加载引导脚本</span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line"></span><br><span class="line">    ...   </span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        if (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class="line">            // 内部会偏离执行每个action中携带的command对应的执行函数</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class="line">            if (!shutting_down) &#123;</span><br><span class="line">                // 重启死去的子进程</span><br><span class="line">                auto next_process_restart_time = RestartProcesses();</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If there&#x27;s more work to do, wake up again immediately.</span><br><span class="line">            if (am.HasMoreCommands()) epoll_timeout_ms = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        epoll_event ev;</span><br><span class="line">        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, epoll_timeout_ms));</span><br><span class="line">        if (nr == -1) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;epoll_wait failed&quot;;</span><br><span class="line">        &#125; else if (nr == 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void LoadBootScripts(ActionManager&amp;action_manager, ServiceList&amp; service_list) &#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    std::string bootscript = GetProperty(&quot;ro.boot.init_rc&quot;, &quot;&quot;);</span><br><span class="line">    // bootscript默认是空的</span><br><span class="line">    if (bootscript.empty()) &#123;</span><br><span class="line">        // 5、解析init.rc配置文件</span><br><span class="line">        parser.ParseConfig(&quot;/init.rc&quot;);</span><br><span class="line">        if (!parser.ParseConfig(&quot;/system/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/system/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/product/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/product/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/odm/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/odm/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/vendor/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/vendor/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        功能：主要是初始化和启动属性服务，并且启动Zygote进程。</p><ul><li>分析和运行所有init.rc文件</li></ul><p>这是Android初始化语言编写的一个非常重要的配置脚本文件。Android初始化语言主要包含5种类型的语句：Action（常用）、Service（常用）、Command、Option、Import</p><ul><li><p>生成设备驱动节点（通过rc文件创建）</p></li><li><p>创建和挂载启动所需的文件目录：挂载了tmpsf、devpts、proc、sysfs和selinuxfs共5种文件系统（它们均是系统运行时目录</p></li><li><p>处理子进程的终止（signal方式）</p></li></ul><p>设置子进程信号的处理函数，如果子进程（Zygote）异常退出，init进程会调用该函数中设定的信号处理函数—sigchld_handler_init()【防止子进程成为僵尸进程】。如果Zygote进程终止，sigchld_handler_init()会重启Zygote进程。</p><ul><li>对属性服务进行初始化（property service）：</li></ul><p>​        属性服务：Windows平台上有一个注册表管理器，注册表的内容采用键值对的形式来记录用户、软件等使用信息。如果系统或软件重启，还是能够根据这份注册表中的记录，进行相应的初识化工作。Android也提供了一个这样类型的机制，即属性服务。</p><p>​        init进程启动时会启动属性服务，并为其分配内存，用来存储这些属性，如果需要就可以直接读取，具体在代码里就是执行了property_init()函数中的__system_property_area_init()函数去初始化属性内存区域。</p><ul><li>启动属性服务：（启动servicemanager【binder服务管家】、bootanim【开机动画服务】）。</li></ul><p>system/core/init/property_service.cpp源码中的start_property_service()函数来启动服务。</p><p><strong>总结：1、创建和挂载启动所需的文件目录。2、初始化和启动属性服务。3、解析init.rc配置文件并启动Zygote进程</strong></p><p>​        <strong>补充：servicemanager进程</strong>：ServiceManager是Binder IPC通信过程中的守护进程，本身也是一个Binder服务，但并没有采用libbinder中的多线程模型来与Binder驱动通信，而是自行编写了binder.c直接和Binder驱动来通信，并且只有一个循环binder_loop来进行读取和处理事务，这样的好处是简单而高效。</p><p>​        ServiceManager本身工作相对简单，其功能：查询和注册服务。 对于Binder IPC通信过程中，其实更多的情形是BpBinder和BBinder之间的通信，比如ActivityManagerProxy和ActivityManagerService之间的通信等。</p><p>​        ServiceManger集中管理系统内的所有服务，通过权限控制进程是否有权注册服务,通过字符串名称来查找对应的Service; 由于ServiceManger进程建立跟所有向其注册服务的死亡通知, 那么当服务所在进程死亡后, 会只需告知ServiceManager. 每个Client通过查询ServiceManager可获取Server进程的情况，降低所有Client进程直接检测会导致负载过重。</p><p><strong>Zygote进程：</strong>由init进程启动。（进入java世界）</p><p>​        Zygote进程创建Java虚拟机,并注册JNI方法， 真正成为Java进程的母体，用于孵化Java进程. 在创建完system_server进程后,zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</p><p>​        Zygote是在init进程启动时创建的，它又称为孵化器，它可以通过fork（复制进程）的形式来创建应用程序进程和SystemServer进程。并且，Zygote进程在启动的时候回创建DVM或者ART，因此通过fork而创建的应用程序进程和SystemServer进程可以在内部获取一个DVM或者ART的实例副本。</p><p>​        Zygote进程的主要职责：</p><ul><li>1、创建AppRuntime，执行其start方法，启动Zygote进程。。</li><li>2、创建JVM并为JVM注册JNI方法。</li><li>3、使用JNI调用ZygoteInit的main函数进入Zygote的Java FrameWork层。</li><li>4、使用registerZygoteSocket方法创建服务器端Socket，并通过runSelectLoop方法等等AMS的请求去创建新的应用进程。</li><li>5、启动SystemServer进程。</li></ul><p><strong>System_server进程：</strong>Zygote通过fork后创建system_server进程。承载着framework的核心服务。</p><p>​        system_server进程中创建了SystemServerManager,作用是对系统服务进行创建、启动和声明周期管理。</p><p>​        通过startBootstarpServices()方法中使用SystemServiceManager启动了ActivityManagerService、PackageManagerService、PowerManagerService等引导服务。</p><p>​        通过startCoreServices()方法中则启动了BatteryService、WebViewUpdateService、DropBoxManagerService、UsageStatsService4个核心服务</p><p>​        通过startOtherServices()方法中启动了WindowManagerService、InputManagerService、CameraService等其它服务。这些服务的父类都是SystemService。</p><p>​        系统服务分为三类：引导服务、核心服务、其他服务。</p><p>​                引导服务：ActivityManagerService，负责四大组件的启动、切换、调度。</p><p>​                引导服务：PackageManagerService，负责对APK进行安装、解析、删除、卸载等操作。<br>​                引导服务：PowerManagerService，负责计算系统中与Power相关的计算，然后决定系统该如何反应。<br>​                核心服务：BatteryService，管理电池相关的服务。<br>​                其它服务：WindowManagerService，窗口管理服务。<br>​                其它服务：InputManagerService，管理输入事件。</p><p>SystemService进程被创建后，主要的处理如下：</p><ul><li>1、启动Binder线程池，这样就可以与其他进程进行Binder跨进程通信。</li><li>2、创建SystemServiceManager，它用来对系统服务进行创建、启动和生命周期管理。</li><li>3、启动各种系统服务：引导服务、核心服务、其他服务，共100多种。应用开发主要关注引导服务ActivityManagerService、PackageManagerService和其他服务WindowManagerService、InputManagerService即可。</li></ul><p><strong>Launcher进程：</strong>Android系统启动的最后一步就是启动了一个Launcher应用程序来显示系统中已经安装的应用程序。<strong>Launcher在启动的过程中会请求请求PMS返回系统中已安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，从而使得用户可以点击这些快捷图片来启动相应的应用程序。</strong></p><p>​        1.作为android系统的启动器，用于启动应用程序。</p><p>​        2.作为android系统的桌面，用于显示和管理应用程序的快捷图标或其他桌面组件。</p><p>​        <strong>Launcher启动：</strong>SystemServer进程在启动的过程中会启动PMS，PMS启动后会将系统中的应用程序安装完成，先前已经启动的AMS会将Launcher启动起来。在SystemServer的startOtherServices()方法中，调用了AMS的systemReady()方法，此即为Launcher的入口。</p><p>​        **Launcher应用图标的显示过程:**应用程序图标是进入应用程序的入口。Launcher是用工作区的形式来显示系统安装的应用程序快捷图标的，每一个工作区都是用来描述一个抽象桌面的，它由n个屏幕组成，每个屏幕又分为n个单元格，每个单元格用来显示一个应用程序的快捷图标。</p><p><strong>APP进程：</strong>普通的app进程跟system_server进程的启动有些类似，不同的是app进程是发消息给system_server进程，由system_server向zygote进程发出创建进程的请求。</p><p><strong>总结：</strong></p><p>1、启动电源以及系统启动：当电源按下时引导芯片从预定义的订房（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。<br>2、引导程序BootLoader：BootLoader是在Android系统开始运行前的一个小程序，主要用于把系统OS拉起来并运行。。<br>3、Linux内核启动：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当其完成系统设置时，会先在系统文件中寻找init.rc文件，并启动init进行。<br>4、init进程启动：初始化和启动属性服务，并且启动Zygote进程。<br>5、Zygote进程启动：创建JVM并为其注册JNI方法，创建服务器端Socket，启动SystemServer进程。<br>6、SystemServer进程启动：启动Binder线程池和SystemServiceManager，并且启动各种系统服务。<br>7、Launcher启动：被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到系统桌面上。</p><p><strong>Android系统启动流程</strong></p><p>​    Android系统的启动流程，从按power按键启动电源开始，到Launcher应用程序启动完成结束，这里大致可以分为如下7个步骤。</p><p> 1、开启电源执行BootLoader引导程序</p><p>​    当按下电源后，会引导芯片代码从预定义的地方开始执行（该预定义的地方固化在ROM中），将引导程序BootLoader加载到RAM中执行。ROM和RAM是内存的中的两个部分，前者是Read-Only-Memmory的缩写，顾名思义，就是只读的内存，这其中会预先存储一些信息，比如这里系统启动时需要的信息。后者是Random-Acess-Memmory的缩写，写入的内存，在程序运行过程中可以动态写入数据，系统关闭后，数据会被清除。</p><p> 2、BootLoader拉起并执行操作系统</p><p>​    BootLoader执行时，会拉起并运行操作系统。BootLoader是一个引导程序，是在Android操作系统开始运行前的一个小程序，它的作用就是拉起并运行操作系统。</p><p> 3、操作系统启动init进程</p><p>​    Android操作系统基于Linux内核实现，所以此时Linux内核开始启动，进行系统设置。当完成系统设置后，会首先在系统文件中寻找init.rc脚本文件，并启动init进程。</p><p> 4、init进程启动</p><p>​    init，通过名称可以判断它的作用是做一些初始化的工作。init进程是Android系统中用户空间的第一个进程，进程号为1，是Android系统启动中的一个关键进程，作为第一个进程，它被赋予了很多重要的职责，简单概括为：</p><p>   （1）创建和挂载启动系统所需要的文件目录。</p><p>   （2）初始化和启动属性服务。这里的属性服务，类似于Windows操作系统中的注册表管理器，用来记录用户、软件等的一些信息。</p><p>   （3）解析init.rc配置文件，并启动Zygote进程。</p><p> 5、Zygote进程启动</p><p>​    Zygote的中文翻译为“受精卵”，是生命的开始，从字面意思，我们大致可以领会到它在Android系统中的地位。Dalvik/ART，应用程序进程以及运行系统的关键服务SystemServer都是由Zygote进程创建的，所以一般也称它为孵化器。Zygote需要做很多工作，归纳起来大致有如下几条：</p><p>   （1）创建Dalvik/ART</p><p>   （2）从Native层进入到Java框架层。也就是说Zygote开创了Java框架层，这一步是通过Native层通过JNI方式调用ZygoteInit类的main方法来实现。Zygote的路径为：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><p>   （3）ZygoteInit的main方法中会创建一个Service端的Socket，名称为“zygote”，用于等待AMS请求Zygote创建新的应用程序进程。</p><p>   （4）ZygoteInit的main方法中还会通过fork方式创建并启动SystemServer进程。</p><p> 6、SytemServer进程启动</p><p>​    SytemServer是运行系统的关键服务，主要用于创建系统服务，比如AMS，WMS，PMS等。它的主要职责为：</p><p>   （1）启动Binder线程池。该过程主要通过ZygoteInit.nativeZygoteInit()来调用Native层的方法来实现启动Binder线程池的，这样SystemServer就可以使用Binder与其他进程进行通信。</p><p>   （2）创建SystemServerManager（SSM），并启动各种服务。这个过程是在SystemServer的main方法中调用实现的，可以参考如下的源码。SystemServerManager用于对系统的服务进行创建、启动和生命周期管理。这里启动的各种服务包括引导服务、核心服务、其他服务三类：引导服务包括AMS、PowerMS、PackageMS等；核心服务包括BatteryService等；其他服务包括WMS等，SystemUI也是在这里启动的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 1 //=========SystemServer.java=========</span><br><span class="line"> 2 public static void main(String[] args) &#123;</span><br><span class="line"> 3     new SystemServer().run();</span><br><span class="line"> 4 &#125;</span><br><span class="line"> 5 private void run() &#123;</span><br><span class="line"> 6     ......</span><br><span class="line"> 7     //创建消息Looper</span><br><span class="line"> 8     Looper.prepareMainLooper();</span><br><span class="line"> 9     // 加载动态库libandroid_servers.so，初始化native服务</span><br><span class="line">10     System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line">11     ......</span><br><span class="line">12     //初始化系统context</span><br><span class="line">13     createSystemContext();</span><br><span class="line">14     //创建SystemServiceManager</span><br><span class="line">15     mSystemServiceManager = new SystemServiceManager(mSystemContext);</span><br><span class="line">16     ......</span><br><span class="line">17     //启动引导服务，如AMS等</span><br><span class="line">18     startBootstrapServices();</span><br><span class="line">19     //启动核心服务</span><br><span class="line">20     startCoreServices();</span><br><span class="line">21     //启动其它服务，如WMS，SystemUI等</span><br><span class="line">22     startOtherServices();</span><br><span class="line">23     ....</span><br><span class="line">24 &#125;</span><br></pre></td></tr></table></figure><p>每一种服务类型包含哪些具体的服务，可以通过上述源码中第18、20、22行进入到对应的方法中查看。</p><p> 7、启动Launcher</p><p>​    系统启动的最后一步是启动一个应用程序来显示系统中已经安装的应用程序，这个应用程序就是Launcher。这一步由SystemServer创建的AMS来启动，前面第5点“Zygote进程启动”中讲过，创建一个Socket，来等待AMS请求Zygote创建新的应用程序。Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些图标来启动对应的应用程序。总结来说，就是两点：</p><p>   （1）作为Android系统的启动器，用于启动应用程序。</p><p>   （2）作为Android系统的桌面，用于显示和管理应用程序的快捷图标或者其它桌面组件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_activity</title>
      <link href="2021/07/25/android-activity/"/>
      <url>2021/07/25/android-activity/</url>
      
        <content type="html"><![CDATA[<h1 id="activity（应用）"><a href="#activity（应用）" class="headerlink" title="activity（应用）"></a>activity（应用）</h1><p>Activity：是一个应用程序组件（组件就是零件）、为应用程序提供了一个可视化界面（activity就是一个界面）、用户通过此页面与应用程序进行交互。activity是Context的子类，同时实现了window.callback和keyevent.callback，可以处理与窗体用户交互的事件。</p><p>启动activity要素：manifest.xml、MainActivity、layout</p><p>setContentView：为Activity添加所需要的设置的内容，传入指定的Layout所对应的id。activity和布局文件XML进行绑定</p><p>findViewById：获取控件的对象。</p><p>启动另一个Activity：findViewByid（），可以获得xml中的控件对象</p><p>​            设置监听器的四种方法。</p><p>​            显示：通过Intent启动另一个activity            </p><p>​            跳转到某一个网页：</p><p>​            隐式启动：配置action</p><h2 id="activity的生命周期："><a href="#activity的生命周期：" class="headerlink" title="activity的生命周期："></a>activity的生命周期：</h2><p>以下三种状态：长时间保持不变。</p><p>onResume（）：activity处在前台（任务栈的顶部），且用户可以交互。</p><p>onPause（）：Activity被在前台中处于半透明状态或者未覆盖全屏的其他Activity部分遮挡。 暂停的Activity不会接收用户输入，也无法执行任何代码。</p><p>onStop（）：Activity被完全隐藏，且对用户不可见；被视为后台Activity。 停止的Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码。</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-activity/activitylife.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="计算机生成了可选文字: 什么EActivity @直徭翻译为：" alt="活动而在android中申多的是 代表手机的屏已是android的四大组件之一，重 要的组成元，提供了与用户交互的可视化界面 （GUI)，大多的App都是由多个屏组成的 @andr0id*Ff#Task(W)F储Activity, 可以理解为A（tivity钱，即后透先出；当在一个 ActivityE动另一个ActivityBg,%二个Activity 压入第一个Activityfi#中．此时两个Activity 是放在同一个Task中的，当我们帻下回退第 二个从中出，第一个A（tivi呼回判钱顶，即显 示到当前屏皂 养廊c歹／万后出 生命周期图鰩忻 @当A（tivi呼首次帔创津时，会调用on（reate() 方法，吾当显示朋户调用onStart0，如里 要让A（tivity位于前台的话就需要调用 onResume()方*IttdjActivity4ü于饯顶 @当有另一个Activitßfiä前ActivityN.i* 个时候调用onPau“0方法，将前一个A（tivity 的据保存起来 @此时，如里你想让前一个A（tivity不会再显示 的话，调用onStop()方法停止该A（tivity；但是如 里你恁让他回到前台的重新获得焦点的话 可以调用onResume()方法 @on-Stop后，你可以调用onDestory()方法来 钅肖毁iA（tivi也是该众（tivity最后一次帔调 用了，可以iMÄfinish()关fiActivity 0当丙存资源不足的时候，就可能杀死处于 onPau0的A（tivity所在的进程，但是这种极 端的佶况很少会友生 由用户作返回该 Activity,iM*E*Eapp 透程帔杀死 内存低： 申高伉卉级的ap 需要内存 A（tivity的生命周期及回调方法 Activity开始 。nS0 Activityi$行中 用户了回灘 前一个Activi新获得焦点 另一个Activi转入该 Activi之前，获得焦点， 前一个Activi处可见 刖一个Activi呼已轻 不可见了 Activi呼完成了要元成的 工作或由系统消了 Activity*止 Activity再次回到前台 我们不能够去调用，我们 面的内容，什么候调用 只有丽曲0方该方 法用于关闭冥个 A确Y！"><p>一个页面启动另一个页面的生命周期：</p><p>​        第一步：A.一个activity被打开：onCreat—》onStart—-》onResume</p><p>​        第二步：从一个activity启动另一个activity：A onPause—》B onCreate—》B onStart—-》B onResume—-》A onStop（只要stop说明就不可见了）</p><p>​        也就是一开始A执行了onPause方法，然后B完全展现出来之后，A执行onStop。（这个B activity会完全遮盖住A activity）</p><p>​        当B不会完全遮盖A的时候，</p><p>​        <img "" class="lazyload placeholder" data-original="/2021/07/25/android-activity/clip_image001-16272835280171.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="clip_image001-16272835280171" style="zoom:200%;"></p><p>​        这个时候，A还是可见的。所以A没有执行onStop方法。</p><p>​        然后B对画框消失：</p><p>​        <img "" class="lazyload placeholder" data-original="/2021/07/25/android-activity/clip_image001-16272836096582.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="计算机生成了可选文字: 3Pau；0 A0》飞师e 3OnStOD" style="zoom:200%;"></p><h2 id="四种启动模式："><a href="#四种启动模式：" class="headerlink" title="四种启动模式："></a>四种启动模式：</h2><p>​        <img "" class="lazyload placeholder" data-original="/2021/07/25/android-activity/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="计算机生成了可选文字: standarc&t andard是默认的后动式，And℃id是便返回栈来管理活动的，下《每当后动一个新的活动，他就 系统不会在乎这个活动是否已经茌返回栈中存在每产 返回栈中入栈，葑处于栈顶的亻立舀对于便standard模式的活动 创亥活动的一的实例 stX嗵ard默，在不声行过内兄下，所0会凵心重叫抑扈。在aM3a 《认懦厩：下。孬当扈一个斯刊古，禎会伍屮入，再处于槿顶0．刈于叩snda閨」《活 鬲，衤不会在泫．±动岸百回中在．每欠0动都会釗亥±《一个新的． FirstActivity 启动新活动 D FirstActivity 启动新活动 0A山v叮 返回栈 singTopt*式 返回 返回 当活动的后动厦式指定为singTop，在宕动活动时如果发现返回栈的栈顶已经是该活动，则可以接便用它 的实例 当沽囟皂动僂式定为sig@T叩，在皂卉动时如顸回槿代顶已，处认可以自它，不会再 0建糟《动引．而0当0业、c肌岛于顶河，时的《眶t0彗，还巼0创新圈《。 不冉创建活动 检查栈顶判 是否需要 启动新活动 启动新活动 FirstActiVlty SecondActiV'ty FirstActivity 返回栈 返回 返回" style="zoom:200%;"></p><h1 id="activity启动流程"><a href="#activity启动流程" class="headerlink" title="activity启动流程"></a>activity启动流程</h1><p>启动activity的场景：</p><p>（1）点击Launcher中的快捷图标，这种方式进入的是根Activity；</p><p> （2）从其它应用跳转到某个应用的activity，这种场景下启动的可以是根Activity，也可以是其它Activity，如：从某些应用拨打电话、开启相机、打开浏览器等；</p><p>  （3）同一个应用种从某个组件中启动Activity。</p><p>   而启动某个Activity的时候，也可能有两种情形：</p><p>  （1）目标Activity所在应用程序进程不存在，也就是此时该应用还没有启动的情形；</p><p>  （2）目标Activity所在应用程序进程存在，也就是该应用之前启动过。</p><p>大致流程：主要涉及到4个进程的交互：Launcher所在应用进程、ActivityManagerService（后文简称AMS）所在的SystemServe系统进程、Zygote系统进程、目标根Activity所在的应用程序进程</p><p>（1）Launcher进程请求AMS创建根Activity。我们知道，在系统启动过程中，会启动SystemServer进程， AMS、PackageManagerService（后文简称PMS）也是在这个环节中启动的，所以AMS是运行在SystemServer进程当中的。应用的根Activity会在AndroidManifest.xml文件中注册，PMS解析出这些信息，并在Launcher中对这些包名、Activity路径及名称等信息进行封装，当点击快捷图标时，Launcher会调用startActivity方法去启动该图标所对应的根Activity。然后在Luancher进程中通过层层调用，直到通过Binder方式实现IPC，流程就进入到AMS中，也就是SystemServer进程中。</p><p> （2）AMS请求创建根Activity所在的进程。AMS收到Launcher进程启动根Activity的请求后，会先判断根Activity所在的进程是否已经创建过了，如果没有创建过，则会向Zygote进程请求创建该进程，我们目前讨论的情形就是根Activity所在进程没有创建过的情况。我们知道，Zygote进程在启动的时候，会作为服务端创建一个名为“zygote”的Socket，用于监听AMS发起的创建新应用进程请求，所以此时流程进入到Zygote进程中。</p><p> （3）Zygote进程fork出目标进程。Zygote收到AMS的请求后，会以fork的方式创建这个新的应用进程，此过程中会实例化一个ActivityThread对象，也就是一般所说的主线程，运行其入口main方法。</p><p> （4）AMS调度应用进程创建和启动根Activity。根Activity所在的应用程序进程被创建后，AMS在SystemServer进程中也经过层层调用，最终又通过Binder方式实现IPC，将启动Activity的任务交给应用程序进程中的ApplicationThread本地代理，此后，流程进入到根Activity所在的应用程序进程中。这部分流程中，SystemServer中所做的工作主要是根Actifity创建和启动前的一些准备工作，比如判单当前用户权限，判断目标进程是否存在，判断activity是否已经创建，判断启动模式，判断是否注册等。</p><p> （5）在应用进程中完成根Activity的创建和启动。在这里将创建根Activity实例、Applicaiton实例，调用各个生命周期方法，并将DecorView（布局文件中的View会添加到DecorView中）添加到Window中显示出来。 </p><p>如下图所示：</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-activity/start_activity_process.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="start_activity_process"><ol><li>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</li><li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li><li>Zygote进程fork出新的子进程，即App进程；</li><li>App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li><li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；</li><li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li><li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</li></ol><h1 id="activity问题"><a href="#activity问题" class="headerlink" title="activity问题"></a>activity问题</h1><h2 id="两个activity之间传递数据："><a href="#两个activity之间传递数据：" class="headerlink" title="两个activity之间传递数据："></a>两个activity之间传递数据：</h2><p>1、intent、broadcast receiver、content provider</p><p>2、利用static静态数据</p><p>3、利用外部存储进行传输，例如file文件存储。SP和Sqlite数据库</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-25</title>
      <link href="2021/07/25/7-25/"/>
      <url>2021/07/25/7-25/</url>
      
        <content type="html"><![CDATA[<h1 id="1743-从相邻元素对还原数组"><a href="#1743-从相邻元素对还原数组" class="headerlink" title="1743.从相邻元素对还原数组"></a>1743.从相邻元素对还原数组</h1><p>存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。</p><p>给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。</p><p>题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。</p><p>返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。</p><p>示例 1：</p><p>输入：adjacentPairs = [[2,1],[3,4],[3,2]]<br>输出：[1,2,3,4]<br>解释：数组的所有相邻元素对都在 adjacentPairs 中。<br>特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。<br>示例 2：</p><p>输入：adjacentPairs = [[4,-2],[1,4],[-3,1]]<br>输出：[-2,4,1,-3]<br>解释：数组中可能存在负数。<br>另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。<br>示例 3：</p><p>输入：adjacentPairs = [[100000,-100000]]<br>输出：[100000,-100000]</p><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static int[] restoreArray(int[][] adjPairs)&#123;</span><br><span class="line">    int n = adjPairs.length + 1;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; listHashMap = new HashMap&lt;&gt;();</span><br><span class="line">    for (int[] array : adjPairs)&#123;</span><br><span class="line">        int a = array[0];</span><br><span class="line">        int b = array[1];</span><br><span class="line">        hashMap.put(a, hashMap.getOrDefault(a, 0) + 1);</span><br><span class="line">        hashMap.put(b, hashMap.getOrDefault(b, 0) + 1);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt;  listA = listHashMap.getOrDefault(a, new ArrayList&lt;&gt;());</span><br><span class="line">        listA.add(b);</span><br><span class="line">        listHashMap.put(a, listA);</span><br><span class="line">        List&lt;Integer&gt; listB = listHashMap.getOrDefault(b, new ArrayList&lt;&gt;());</span><br><span class="line">        listB.add(a);</span><br><span class="line">        listHashMap.put(b, listB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int start = -1;</span><br><span class="line">    for (int i : hashMap.keySet())&#123;</span><br><span class="line">        if (hashMap.get(i) == 1)&#123;</span><br><span class="line">            start = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int[] ans = new int[n];</span><br><span class="line">    ans[0] = start;</span><br><span class="line">    ans[1] = listHashMap.get(start).get(0);</span><br><span class="line">    for (int i = 2; i &lt; n; i++)&#123;</span><br><span class="line">        int x = ans[i - 1];</span><br><span class="line">        List&lt;Integer&gt; list = listHashMap.get(x);</span><br><span class="line">        for (int j : list)&#123;</span><br><span class="line">            if (j != ans[i - 2])&#123;</span><br><span class="line">                ans[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-24</title>
      <link href="2021/07/24/7-24/"/>
      <url>2021/07/24/7-24/</url>
      
        <content type="html"><![CDATA[<h1 id="1736-替换隐藏数字得到的最晚时间"><a href="#1736-替换隐藏数字得到的最晚时间" class="headerlink" title="1736.替换隐藏数字得到的最晚时间"></a>1736.替换隐藏数字得到的最晚时间</h1><p>给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。</p><p>有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。</p><p>替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。</p><p>示例 1：</p><p>输入：time = “2?:?0”<br>输出：”23:50”<br>解释：以数字 ‘2’ 开头的最晚一小时是 23 ，以 ‘0’ 结尾的最晚一分钟是 50 。<br>示例 2：</p><p>输入：time = “0?:3?”<br>输出：”09:39”<br>示例 3：</p><p>输入：time = “1?:22”<br>输出：”19:22”</p><p>思路：我的想法就是枚举情况，注意点就是情况分类比较多需要注意。</p><p>第一位：如果需要被替换，优先替换为 2，当然前提是第二位不能超过 4。否则会出现 24:xx、25:xx 等；<br>第二位：如果需要被替换，根据第一位是什么，决定替换为 9 还是 3；<br>第三位：固定为 :；<br>第四位：如果需要被替换，替换为 5；<br>第五位：如果需要被替换，替换为 9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public String maximumTime(String time) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(time.charAt(0) == &#x27;?&#x27; ? (time.charAt(1) == &#x27;?&#x27; || time.charAt(1) &lt; &#x27;4&#x27;) ? &#x27;2&#x27; : &#x27;1&#x27; : time.charAt(0));</span><br><span class="line">        sb.append(time.charAt(1) == &#x27;?&#x27; ? sb.charAt(0) == &#x27;2&#x27; ? &#x27;3&#x27; : &#x27;9&#x27; : time.charAt(1));</span><br><span class="line">        sb.append(&#x27;:&#x27;);</span><br><span class="line">        sb.append(time.charAt(3) == &#x27;?&#x27; ? &#x27;5&#x27; : time.charAt(3));</span><br><span class="line">        sb.append(time.charAt(4) == &#x27;?&#x27; ? &#x27;9&#x27; : time.charAt(4));</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static String maximumTime(String time)&#123;</span><br><span class="line">    char[] timeChar = time.toCharArray();</span><br><span class="line">    if (timeChar[0] == &#x27;?&#x27;)&#123;</span><br><span class="line">       if (timeChar[1] == &#x27;?&#x27;)&#123;</span><br><span class="line">           timeChar[0] = &#x27;2&#x27;;</span><br><span class="line">       &#125;else if (timeChar[1] - &#x27;0&#x27; &gt;= 4)&#123;</span><br><span class="line">           timeChar[0] = &#x27;1&#x27;;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           timeChar[0] = &#x27;2&#x27;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeChar[1] == &#x27;?&#x27;)&#123;</span><br><span class="line">        if (timeChar[0] == &#x27;1&#x27;)&#123;</span><br><span class="line">            timeChar[1] = &#x27;9&#x27;;</span><br><span class="line">        &#125;else if (timeChar[0] == &#x27;2&#x27;)&#123;</span><br><span class="line">            timeChar[1] = &#x27;3&#x27;;</span><br><span class="line">        &#125;else if (timeChar[0] == &#x27;0&#x27;)&#123;</span><br><span class="line">            timeChar[1] = &#x27;9&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeChar[3] == &#x27;?&#x27;)&#123;</span><br><span class="line">        timeChar[3] = &#x27;5&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeChar[4] == &#x27;?&#x27;)&#123;</span><br><span class="line">        timeChar[4] = &#x27;9&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(timeChar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记day02</title>
      <link href="2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day02/"/>
      <url>2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day02/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记02"><a href="#操作系统笔记02" class="headerlink" title="操作系统笔记02"></a>操作系统笔记02</h1><p>操作系统课程图：</p><p>操作系统知识体系图：</p><h2 id="程序的运行过程-从代码到机器运行"><a href="#程序的运行过程-从代码到机器运行" class="headerlink" title="程序的运行过程:从代码到机器运行"></a>程序的运行过程:从代码到机器运行</h2><h4 id="程序的编译过程：使用GCC相关工具链"><a href="#程序的编译过程：使用GCC相关工具链" class="headerlink" title="程序的编译过程：使用GCC相关工具链"></a>程序的编译过程：使用GCC相关工具链</h4><p>gcc的编译过程：</p><img "" class="lazyload placeholder" data-original="/2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day02/GCC_CompilationProcess.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="GCC_CompilationProcess"><p>依次执行了：预处理（preprocessing）—&gt;编译（compilation）—-&gt;汇编（Assemble）—-&gt;链接（linking）。</p><p><strong>预处理</strong>：以“#”号开头的预处理指令如包含#include,宏定义制定#define等。在源程序中这些指令都放在函数之外，而且一般放在源文件的前面。</p><p>使用预处理器把源文件test.c经过预处理生成test.i文件。</p><p>预处理的命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i。</span><br></pre></td></tr></table></figure><p>上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p><p><strong>编译</strong>：这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理文件（test.i）之后的程序转换成特定汇编（test.s）代码的过程。</p><p>编译的命令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure><p>上述命令中-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名。编译过程完成后，将生成程序的汇编代码test.s，这也是文本文件。</p><p><strong>汇编：</strong>汇编过程将上一步的汇编代码转换成机器码，这一步产生的文件叫做目标文件，是二进制格式。</p><p>编译的命令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure><p><strong>链接</strong></p><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><p>链接过程的命令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>生成可执行程序过程为成四个步骤：</p><p>1、由.c文件到.i文件，这个过程叫预处理。<br>2、由.i文件到.s文件，这个过程叫编译。<br>3、由.s文件到.o文件，这个过程叫汇编。<br>4、由.o文件到可执行文件，这个过程叫链接。</p><p>源文件生成可执行文件：gcc test.c -o test</p><h2 id="程序装载执行："><a href="#程序装载执行：" class="headerlink" title="程序装载执行："></a>程序装载执行：</h2><h4 id="图灵机："><a href="#图灵机：" class="headerlink" title="图灵机："></a>图灵机：</h4><h4 id="冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。"><a href="#冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。" class="headerlink" title="冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。"></a>冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。</h4><p>根据冯诺依曼体系结构构成的计算机，必须具有如下功能：</p><p>把程序和数据装入到计算机中；</p><p>必须具有长期记住程序、数据的中间结果及最终运算结果；</p><p>完成各种算术、逻辑运算和数据传送等数据加工处理；</p><p>根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；</p><p>能够按照要求将处理的数据结果显示给用户。</p><p>为了完成上述的功能，计算机必须具备五大基本组成部件：</p><p>装载数据和程序的输入设备；</p><p>记住程序和数据的存储器；</p><p>完成数据加工处理的运算器；</p><p>控制程序执行的控制器；</p><p>显示处理结果的输出设备。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统、 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-23</title>
      <link href="2021/07/23/7-23/"/>
      <url>2021/07/23/7-23/</url>
      
        <content type="html"><![CDATA[<h1 id="1893-检查是否区域内所有整数都被覆盖"><a href="#1893-检查是否区域内所有整数都被覆盖" class="headerlink" title="1893.检查是否区域内所有整数都被覆盖"></a>1893.检查是否区域内所有整数都被覆盖</h1><p>给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。</p><p>如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。</p><p>已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti &lt;= x &lt;= endi ，那么我们称整数x 被覆盖了。</p><p>示例 1：</p><p>输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5<br>输出：true<br>解释：2 到 5 的每个整数都被覆盖了：</p><ul><li>2 被第一个区间覆盖。</li><li>3 和 4 被第二个区间覆盖。</li><li>5 被第三个区间覆盖。<br>示例 2：</li></ul><p>输入：ranges = [[1,10],[10,20]], left = 21, right = 21<br>输出：false<br>解释：21 没有被任何一个区间覆盖。</p><p>下边是两种暴力解法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* public static boolean isCovered(int[][] ranges, int left, int right)&#123;</span><br><span class="line">     for (int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">         boolean yesOrNor = false;</span><br><span class="line">         for (int j = 0; j &lt; ranges.length; j++)&#123;</span><br><span class="line">               if (i &gt;= ranges[j][0] &amp;&amp; i &lt;= ranges[j][ranges[0].length - 1])&#123;</span><br><span class="line">                   yesOrNor = true;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         if (yesOrNor == false)&#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;*/</span><br><span class="line"> public static boolean isCovered(int[][] ranges, int left, int right)&#123;</span><br><span class="line">     boolean[] flag = new boolean[51];</span><br><span class="line">     for (int[] range : ranges)&#123;</span><br><span class="line">         for (int i = range[0]; i &lt; range[ranges[0].length]; i++)&#123;</span><br><span class="line">             flag[i] = true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     for (int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">         if (flag[i] == false)&#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="2021/07/22/%E8%B4%AA%E5%BF%83/"/>
      <url>2021/07/22/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode树</title>
      <link href="2021/07/22/leetcode%E6%A0%91/"/>
      <url>2021/07/22/leetcode%E6%A0%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试题</title>
      <link href="2021/07/22/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>2021/07/22/%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="某为"><a href="#某为" class="headerlink" title="某为"></a>某为</h1><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p><p>输入：nums = [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLIS(int[] nums)&#123;</span><br><span class="line">       if (nums.length == 0)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int[] dp = new int[nums.length];</span><br><span class="line">       //这里结果赋值为1，因为如果长度不为零，至少有一个</span><br><span class="line">       int ans = 1;</span><br><span class="line">       dp[0] = 1;</span><br><span class="line">       for (int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">           //这里初始化为1也是必要的，因为当前位置至少有自己本身这个元素。</span><br><span class="line">           dp[i] = 1;</span><br><span class="line">           for (int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">               if (nums[i] &gt; nums[j])&#123;</span><br><span class="line">                   dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           ans = Math.max(ans, dp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="8-15的小美和小团"><a href="#8-15的小美和小团" class="headerlink" title="8.15的小美和小团"></a>8.15的小美和小团</h1><h2 id="1-小美的检查序列"><a href="#1-小美的检查序列" class="headerlink" title="1.小美的检查序列"></a>1.小美的检查序列</h2><p>​        小美给小团一个n个数字构成的数字序列，问小团能不能经过重新排列后形成1到n的排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class meituan01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        int T = input.nextInt();</span><br><span class="line">        String[] ans = new String[T];</span><br><span class="line">        for (int i = 0; i &lt; T; i++)&#123;</span><br><span class="line">            int n = input.nextInt();</span><br><span class="line">            int[] nums = new int[n];</span><br><span class="line">            for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                nums[j] = input.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = sort(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        for (String str : ans)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//方法用来判断输入的数组是否符合要求</span><br><span class="line">    //思路是放到hashmap中，然后重新遍历的时候，如果有的个数不为1，则输出</span><br><span class="line">    public static String sort(int[] nums)&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            hashMap.put(nums[i], hashMap.getOrDefault(nums[i], 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (hashMap.get(nums[i]) != 1)&#123;</span><br><span class="line">                return &quot;No&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Yes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-小美的回文串构建"><a href="#2-小美的回文串构建" class="headerlink" title="2.小美的回文串构建"></a>2.小美的回文串构建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class meituan02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        String sFromXiaoMei = input.next();</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder(sFromXiaoMei);</span><br><span class="line">        if (huiwen(stringBuilder.toString()))&#123;</span><br><span class="line">            System.out.println(0);</span><br><span class="line">        &#125;</span><br><span class="line">        //可以这样思考：如果添加了一个字符就成了回文串，说明添加的字符是原来字符串的第一个字符。同理如果添加了两个字符成立回文串，说明添加的字符分别为原字符串的第二个和第一个</span><br><span class="line">        for (int i = 0; i &lt; sFromXiaoMei.length(); i++)&#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            //所以在这里我首先进行添加字符串，然后判断是否为回文串</span><br><span class="line">            while (j &gt;= 0)&#123;</span><br><span class="line">                stringBuilder.append(sFromXiaoMei.charAt(j));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (huiwen(stringBuilder.toString()))&#123;</span><br><span class="line">                System.out.println(i + 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里如果添加失败，需要把之前添加的去掉。因为需要重新添加</span><br><span class="line">           stringBuilder.delete(sFromXiaoMei.length(), sFromXiaoMei.length() + i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//判断字符串是否为回文串的函数</span><br><span class="line">    public static boolean huiwen(String s)&#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int halfLen = 0;</span><br><span class="line">        if (len % 2 == 0)&#123;</span><br><span class="line">            halfLen = len / 2;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            halfLen = len / 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; halfLen; i++)&#123;</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">            if (stack.pop() != s.charAt(len - i - 1))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小美的机器人"><a href="#3-小美的机器人" class="headerlink" title="3.小美的机器人"></a>3.小美的机器人</h2><h2 id="4-小美的最快到达时间"><a href="#4-小美的最快到达时间" class="headerlink" title="4.小美的最快到达时间"></a>4.小美的最快到达时间</h2><h2 id="5-小美的水洼地冒险"><a href="#5-小美的水洼地冒险" class="headerlink" title="5.小美的水洼地冒险"></a>5.小美的水洼地冒险</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class meituan05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        int n = input.nextInt();</span><br><span class="line">        int p = input.nextInt();</span><br><span class="line">        String s = input.next();</span><br><span class="line">        char[] paths = s.toCharArray();</span><br><span class="line">        int[] cost = new int[p];</span><br><span class="line">        for (int i = 0; i &lt; p; i++)&#123;</span><br><span class="line">            cost[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(costEnergy(n, p, paths, cost));</span><br><span class="line">    &#125;</span><br><span class="line">    //第一步确定dp数组以及下标含义</span><br><span class="line">    //递推公式</span><br><span class="line">    //dp数组如何初始化</span><br><span class="line">    //确定遍历顺序</span><br><span class="line">    //举例推导dp数组</span><br><span class="line">    public static int costEnergy(int n, int p, char[] paths, int[] cost)&#123;</span><br><span class="line">        int[] dp = new int[n];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            if (paths[i] == &#x27;x&#x27;)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            for (int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">                if (paths[j] == &#x27;o&#x27; &amp;&amp; (i - j) &lt;= p)&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j] + cost[i - j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> code the world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-22</title>
      <link href="2021/07/22/7-22/"/>
      <url>2021/07/22/7-22/</url>
      
        <content type="html"><![CDATA[<h1 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138.复制带随机指针的链表"></a>138.复制带随机指针的链表</h1><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><p>思路：先遍历原链表，遍历过程中创建的新节点和对应的老节点用map保留着对应关系。第二次遍历的时候把next和random关系给补上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static Node copyRandomList(Node head)&#123;</span><br><span class="line">      HashMap&lt;Node, Node&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">      Node temp = head;</span><br><span class="line">      while (temp != null)&#123;</span><br><span class="line">          Node newNode = new Node(temp.val);</span><br><span class="line">          hashMap.put(temp, newNode);</span><br><span class="line">          temp = temp.next;</span><br><span class="line">      &#125;</span><br><span class="line">      temp = head;</span><br><span class="line">      while (temp != null)&#123;</span><br><span class="line">          Node newNode = hashMap.get(temp);</span><br><span class="line">          if (temp.next != null)&#123;</span><br><span class="line">              newNode.next = hashMap.get(temp.next);</span><br><span class="line">          &#125;</span><br><span class="line">          if (temp.random != null)&#123;</span><br><span class="line">              newNode.random = hashMap.get(temp.random);</span><br><span class="line">          &#125;</span><br><span class="line">          temp = temp.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return hashMap.get(head);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>宫水三叶大佬的原地算法：显然时间复杂度上无法优化，考虑如何降低空间（不使用「哈希表」）。</p><p>我们使用「哈希表」的目的为了实现原节点和新节点的映射关系，更进一步的是为了快速找到某个节点 random 在新链表的位置。</p><p>那么我们可以利用原链表的 next 做一个临时中转，从而实现映射。</p><p>具体的，我们可以按照如下流程进行：</p><p>对原链表的每个节点节点进行复制，并追加到原节点的后面；<br>完成 11 操作之后，链表的奇数位置代表了原链表节点，链表的偶数位置代表了新链表节点，且每个原节点的 next 指针执行了对应的新节点。这时候，我们需要构造新链表的 random 指针关系，可以利用 link[i + 1].random = link[i].random.next，ii 为奇数下标，含义为 新链表节点的 random 指针指向旧链表对应节点的 random 指针的下一个值；<br>对链表进行拆分操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Node copyRandomList(Node head) &#123;</span><br><span class="line">       if (head == null) return null;</span><br><span class="line">       Node dummy = new Node(-1);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       while (head != null) &#123;</span><br><span class="line">           Node node = new Node(head.val);</span><br><span class="line">           node.next = head.next;</span><br><span class="line">           head.next = node;</span><br><span class="line">           head = node.next;</span><br><span class="line">       &#125;</span><br><span class="line">       head = dummy.next;</span><br><span class="line">       while (head != null) &#123;</span><br><span class="line">           if (head.random != null) &#123;</span><br><span class="line">               head.next.random = head.random.next;</span><br><span class="line">           &#125;</span><br><span class="line">           head = head.next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       head = dummy.next;</span><br><span class="line">       Node ans = head.next;</span><br><span class="line">       while (head != null) &#123;</span><br><span class="line">           Node tmp = head.next;</span><br><span class="line">           if (head.next != null) head.next = head.next.next;</span><br><span class="line">           head = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS2~DDS</title>
      <link href="2021/07/21/ROS2-DDS/"/>
      <url>2021/07/21/ROS2-DDS/</url>
      
        <content type="html"><![CDATA[<h1 id="DDS"><a href="#DDS" class="headerlink" title="DDS"></a>DDS</h1><p>DDS（数据分发服务）：是由OMG发布的分布式通信规范，采用了订阅发布模型，以中间件的形式提供通信服务，并提供多种QoS策略，保障数据进行实时、高效、灵活的分发。</p><p>订阅发布：DDS是基于发布/订阅模式的以数据为中心的通信模型。发布订阅功能使应用程序（发布者）将消息按照特定的主题进行分发，应用程序（订阅者）也可以根据主题接收到所需要的信息。</p><img "" class="lazyload placeholder" data-original="/2021/07/21/ROS2-DDS/DDS.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class title="DDS"><h1 id="DCPS"><a href="#DCPS" class="headerlink" title="DCPS"></a>DCPS</h1><p>DCPS定义了应用程序的功能，以发布和订阅数据的值。</p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专题</title>
      <link href="2021/07/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
      <url>2021/07/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>这种解法是：在当前节点中存入值，在不确定后边还有没有节点情况就创建节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ListNode l3Head = null;</span><br><span class="line">ListNode l3 = null;</span><br><span class="line">l3Head = l3;</span><br><span class="line">int lingwai = 0;</span><br><span class="line">while (l1 != null || l2 != null)&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    if (l1 != null)&#123;</span><br><span class="line">        a = l1.val;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        a = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 != null)&#123;</span><br><span class="line">        b = l2.val;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        b = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int c = a + b + lingwai;</span><br><span class="line">    int temp = c;</span><br><span class="line">    c = temp % 10;</span><br><span class="line">    lingwai = temp / 10;</span><br><span class="line">    l3.val = c;</span><br><span class="line">    ListNode next = new ListNode();</span><br><span class="line">    l3.next = next;</span><br><span class="line">    l3 = l3.next;</span><br><span class="line">&#125;</span><br><span class="line">if (lingwai != 0)&#123;</span><br><span class="line">    l3.val = lingwai;</span><br><span class="line">&#125;</span><br><span class="line">return l3Head;</span><br></pre></td></tr></table></figure><p>咋办呢？就只能想方设法知道最后的位置。设置一个ListNode节点，当</p><p>if (l1 == null &amp;&amp; l2 == null){<br>           text = l3;<br>   }这个时候，保存住最后的位置。</p><p>在这也需要特殊判断。</p><p> if (lingwai != 0){<br>       l3.val = lingwai;<br>   }else {<br>       text.next = null;<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode addTwoNums(ListNode l1, ListNode l2)&#123;</span><br><span class="line">   ListNode l3Head = null;</span><br><span class="line">   ListNode l3 = null;</span><br><span class="line">   ListNode text = new ListNode();</span><br><span class="line">   l3Head = l3;</span><br><span class="line">   int lingwai = 0;</span><br><span class="line">   while (l1 != null || l2 != null)&#123;</span><br><span class="line">       int a, b;</span><br><span class="line">       if (l1 != null)&#123;</span><br><span class="line">           a = l1.val;</span><br><span class="line">           l1 = l1.next;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           a = 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (l2 != null)&#123;</span><br><span class="line">           b = l2.val;</span><br><span class="line">           l2 = l2.next;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           b = 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int c = a + b + lingwai;</span><br><span class="line">       int temp = c;</span><br><span class="line">       c = temp % 10;</span><br><span class="line">       lingwai = temp / 10;</span><br><span class="line">       l3.val = c;</span><br><span class="line">       ListNode next = new ListNode();</span><br><span class="line">       l3.next = next;</span><br><span class="line">       if (l1 == null &amp;&amp; l2 == null)&#123;</span><br><span class="line">           text = l3;</span><br><span class="line">       &#125;</span><br><span class="line">       l3 = l3.next;</span><br><span class="line">   &#125;</span><br><span class="line">   if (lingwai != 0)&#123;</span><br><span class="line">       l3.val = lingwai;</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">       text.next = null;</span><br><span class="line">   &#125;</span><br><span class="line">   return l3Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想别这么绞尽脑汁，需要的是。如果有值需要加入的时候才创建节点加入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ListNode head = new ListNode();</span><br><span class="line">ListNode current = head;</span><br><span class="line">int carry = 0;</span><br><span class="line">    while (l1 != null || l2 != null)&#123;</span><br><span class="line">    int val1 = l1 != null ? l1.val : 0;</span><br><span class="line">    int val2 = l2 != null ? l2.val : 0;</span><br><span class="line">    int sum = val1 +val2 + carry;</span><br><span class="line">    current.next = new ListNode(sum % 10);</span><br><span class="line">    current = current.next;</span><br><span class="line">    carry = sum / 10;</span><br><span class="line">    if (l1 != null)</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    if (l2 != null)</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line">    if (carry &gt; 0 )&#123;</span><br><span class="line">    current.next = new ListNode(carry);</span><br><span class="line">    current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">    return head.next;</span><br></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h1 id="链表某个题"><a href="#链表某个题" class="headerlink" title="链表某个题"></a>链表某个题</h1><p>意思：一个链表转换成：1–&gt;n–&gt;2–&gt;n-1–&gt;3…这个意思。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-21</title>
      <link href="2021/07/21/7-21/"/>
      <url>2021/07/21/7-21/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer52"><a href="#剑指offer52" class="headerlink" title="剑指offer52."></a>剑指offer52.</h1><p>输入两个链表找出他们的第一个公共节点</p><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p><p>大家注意一点，这里的公共节点是两个节点的内存地址一样，并不知道节点所存储的val相等就是公共节点。</p><p>解法一：栈解法，将两个链表分别压栈。对于两个栈的操作为，一起出栈然后判断出栈的元素是否equals。并且需要保存前一个出栈的元素。第一个弹栈元素不相等的前一个元素就是公共节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stackA = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;ListNode&gt; stackB = new Stack&lt;&gt;();</span><br><span class="line">    while (headA != null)&#123;</span><br><span class="line">        stackA.push(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (headB != null)&#123;</span><br><span class="line">        stackB.push(headB);</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode ans = null;</span><br><span class="line">    while (!stackA.isEmpty() &amp;&amp; !stackB.isEmpty())&#123;</span><br><span class="line">        ListNode a = stackA.pop();</span><br><span class="line">        ListNode b = stackB.pop();</span><br><span class="line">        if (a.equals(b))&#123;</span><br><span class="line">            ans = a;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：数学解法，两个链表的分别长度为lengthA和lengthB.将两个链表连接起来，也就是链表A后边连接上链表B，链表B后边连接上链表A。这样长度就相等了，可以从头开始按顺序遍历了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line"></span><br><span class="line">       if (headA == null || headB == null)&#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode A = headA;</span><br><span class="line">       ListNode B = headB;</span><br><span class="line">       while (A != B)&#123;</span><br><span class="line">           A = A != null ? A.next : headB;</span><br><span class="line">           B = B != null ? B.next : headA;</span><br><span class="line">       &#125;</span><br><span class="line">       return A;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>数学解法二：先对两条链表扫描一遍，取得两者长度，然后让长的链表先走「两者的长度差值」，然后再同时走，遇到第一个节点即是答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    int lengthA = 0, lengthB = 0;</span><br><span class="line">    ListNode a = headA, b = headB;</span><br><span class="line">    while (a != null)&#123;</span><br><span class="line">        a = a.next;</span><br><span class="line">        lengthA++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (b != null)&#123;</span><br><span class="line">        b = b.next;</span><br><span class="line">        lengthB++;</span><br><span class="line">    &#125;</span><br><span class="line">    int abs = Math.abs(lengthA - lengthB);</span><br><span class="line">    while (abs &gt; 0)&#123;</span><br><span class="line">        if (lengthA &gt; lengthB)&#123;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        abs--;</span><br><span class="line">    &#125;</span><br><span class="line">    while (headA != null &amp;&amp; headB != null)&#123;</span><br><span class="line">        if (headA.equals(headB))&#123;</span><br><span class="line">            return headA;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法三：哈希表。先将链表A放入哈希表中，然后遍历链表B，判断节点是否存在，不存在的话继续遍历。存在就返回此节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    HashMap&lt;ListNode, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">    while (headA != null)&#123;</span><br><span class="line">        hashMap.put(headA, hashMap.getOrDefault(headA, 0) + 1);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (headB != null)&#123;</span><br><span class="line">        if (hashMap.containsKey(headB))&#123;</span><br><span class="line">            return headB;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTP和HTTPS</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8AHTTP%E5%92%8CHTTPS/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8AHTTP%E5%92%8CHTTPS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTPS</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8AHTTPS/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8AHTTPS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTP/1.1</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8AHTTP-1-1/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8AHTTP-1-1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h1><h3 id="HTTP（全称超文本传输协议，英文全称HyperText-Transfer-Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。"><a href="#HTTP（全称超文本传输协议，英文全称HyperText-Transfer-Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。" class="headerlink" title="HTTP（全称超文本传输协议，英文全称HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。"></a>HTTP（全称超文本传输协议，英文全称HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。</p><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\http.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="http"></p><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p><p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p><h3 id="HTTP工作过程："><a href="#HTTP工作过程：" class="headerlink" title="HTTP工作过程："></a>HTTP工作过程：</h3><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\http请求响应模型.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="http请求模型"></p><ul><li>***1）***建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</li><li>***2）***客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：GET/sample/hello.jsp HTTP/1.1；</li><li>***3）***客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</li><li>***4）***服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： HTTP/1.1 200 OK<br>响应的第一部分是协议的版本号和响应状态码；</li><li>***5）***服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</li><li>***6）***服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</li><li>***7）***服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ul><h4 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h4><p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p><h4 id="HTTP协议是不保存状态的协议"><a href="#HTTP协议是不保存状态的协议" class="headerlink" title="HTTP协议是不保存状态的协议"></a>HTTP协议是不保存状态的协议</h4><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h4 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h4><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img "" class="lazyload placeholder" data-original="/2021/07/20/%E7%9E%8E%E8%81%8AHTTP-1-1/images/cookie.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Cookie状态管理"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊网络</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8A%E7%BD%91%E7%BB%9C/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8A%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>以五层结构为例：</p><p><strong>1）应用层：</strong>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。”应用层”的作用，就是规定应用程序的数据格式。如http协议，它实际上是定义了如何包装和解析数据。</p><p><strong>2）运输层：</strong>我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。</p><p>运输层有TCP和UDP两种协议，分别对应可靠的运输和不可靠的运输，如TCP因为要提供可靠的传输，所以内部要解决如何建立连接、如何保证传输是可靠的不丢数据、如何调节流量控制和拥塞控制。关于这一层，我们平常一般都是和Socket打交道，Socket是一组封装的编程调用接口，通过它，我们就能操作TCP、UDP进行连接的建立等。我们平常使用Socket进行连接建立的时候，一般都要指定端口号,所以这一层指定了把数据送到对应的端口号。</p><p><strong>3）网络层：</strong>作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。——–IP协议</p><p>为什么需要网络层：以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是不合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>IP数据包：把IP数据包直接放进以太网数据包的数据部分</p><p><strong>4）数据链路层：</strong>在物理层的基础上，确定了0和1的分组方式。以太网协议规定，一组电信号构成一个数据包，叫做帧。每一帧分成两个部分：标头和数据。以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p><strong>定义地址只是第一步，后面还有更多的步骤：</strong></p><ul><li><strong>1）首先：</strong>一块网卡怎么会知道另一块网卡的MAC地址？<br>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</li><li><strong>2）其次：</strong>就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</li></ul><p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”数据链路层”就可以在多台计算机之间传送数据了。</p><p><strong>5）物理层：</strong>用光缆、电缆、双绞线、无线电波的方式将计算机组网，进行数据传输。主要规定了网络的电气特性，作用是负责传送0和1的电信号。</p><p>所以通过上面五层的各司其职，实现物理传输介质–MAC地址–IP地址–端口号–获取到数据根据应用层协议解析数据最终实现了网络通信和数据传输。</p><p>发送这个包需要知道两个地址：对方的MAC地址、对方的IP地址。</p><table><thead><tr><th><strong>场景</strong></th><th><strong>数据包地址</strong></th></tr></thead><tbody><tr><td>同一个子网络</td><td>对方的MAC地址，对方的IP地址</td></tr><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr></tbody></table><h1 id="快速理解网络通信协议"><a href="#快速理解网络通信协议" class="headerlink" title="快速理解网络通信协议"></a>快速理解网络通信协议</h1><h2 id="五层模型：（当然还有七层和四层的）"><a href="#五层模型：（当然还有七层和四层的）" class="headerlink" title="五层模型：（当然还有七层和四层的）"></a>五层模型：（当然还有七层和四层的）</h2><img "" class="lazyload placeholder" data-original="/2021/07/20/%E7%9E%8E%E8%81%8A%E7%BD%91%E7%BB%9C/model.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="model" style="zoom:200%;"><p>重点看五层模型：从下到上分别为，物理层、数据链路层、网络层、传输层、应用层。</p><h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><p>​        用光缆、电缆、双绞线、无线电波的方式将计算机组网，进行数据传输。主要规定了网络的电气特性，作用是负责传送0和1的电信号。</p><h3 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h3><p>​        定义：在物理层的基础上，确定0和1的分组方式。</p><p>​        早期时候，每家公司有自己的电信号分组方式。逐渐，一种叫“以太网的协议”，占据了主导地位。以太网规定，一组电信号构成一个数据包，叫做帧。每个帧分成两个部分：标头（head）和数据（Data）。</p><p>​        “标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>​        “标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p>​        以太网数据包（64-1518字节） = 标头（18-46字节）+ 数据（46-1500字节）</p><p>​        MAC地址：以太网规定，连入网络的所有设备，都必须具有网卡接口。数据必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送和接收地址，被称为MAC地址。MAC地址长度为48个二进制位，有了网卡就可以定位网卡和数据包的路径。</p><p>​        数据链路层能够在计算机之间传送数据:数据包的定义+网卡的MAC地址+广播的发送方式。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>​        前提：互联网是无数子网络共同组成的巨型网络。只有MAC地址无法在不同的子网络广播。从而引入网络层，作用是引进一套新的地址，使得区分不同的计算机是否属于同一个子网络。网络地址让我们确定计算机所在的子网络，MAC地址将数据包送到子网络中的目标网卡。</p><p>​        IP数据包（65535字节） = 标头（20-60字节）+数据，放入到以太网数据包中（65515-65475字节）。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>​        传输层的功能是，建立端口到端口的通信。</p><p>​        UDP数据包（8-65535）= 标头（8字节）+ 数据部分</p><p>​        TCP数据包：没有长度限制，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，确保单个TCP数据包不必再分割。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>​        应用层用来规定格式，进行传输层的数据进行解读。</p><p>​        以太网数据包 = 以太网标头 + IP标头 + TCP标头 + 应用户层数据包</p><p><strong>从上到下：</strong>DNS-&gt;子网掩码判断是不是同一个子网络-&gt;应用层协议（构造应用层内容，被嵌入到TCP数据包）-&gt;TCP协议（TCP数据包需要设置端口，TCP数据包嵌入到IP数据包）-&gt;IP协议（设置双方的IP地址，IP数据包嵌入到以太网数据包）-&gt;以太网数据包需要设置MAC地址</p><h1 id="硬件设施"><a href="#硬件设施" class="headerlink" title="硬件设施"></a>硬件设施</h1><p>​        集线器：起到一个将网线集结起来的作用，实现最初级的网络互通。集线器是通过网线直接传送数据的，工作在物理层。</p><p>​        交换机：根据网口地址传送信息，比网线直接传送多了一个步骤，交换机工作在数据链路层。实现了任意两台电脑间的互联，提升了网络间的传输速度。</p><p>​        路由器：工作在IP层，通过IP地址寻址</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-20</title>
      <link href="2021/07/20/7-20/"/>
      <url>2021/07/20/7-20/</url>
      
        <content type="html"><![CDATA[<h1 id="1877：数组中最大数对和的最小值"><a href="#1877：数组中最大数对和的最小值" class="headerlink" title="1877：数组中最大数对和的最小值"></a>1877：数组中最大数对和的最小值</h1><p>一个数对 (a,b) 的 数对和 等于 a + b 。6最大数对和 是一个数对数组中最大的 数对和 。</p><p>比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。<br>给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得：</p><p>nums 中每个元素 恰好 在 一个 数对中，且<br>最大数对和 的值 最小 。<br>请你在最优数对划分的方案下，返回最小的 最大数对和 。</p><p>示例 1：</p><p>输入：nums = [3,5,2,3]<br>输出：7<br>解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。<br>最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。<br>示例 2：</p><p>输入：nums = [3,5,4,2,4,6]<br>输出：8<br>解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。<br>最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。</p><p>思路：第一反应就是最大和最小的配对。证明过程可以参考leetcode官方题解，反证法。<a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/solution/shu-zu-zhong-zui-da-shu-dui-he-de-zui-xi-cvll/">https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/solution/shu-zu-zhong-zui-da-shu-dui-he-de-zui-xi-cvll/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line">     int ans = Integer.MIN_VALUE;</span><br><span class="line">     int left = 0, right = nums.length - 1;</span><br><span class="line">     while (left &lt; right)&#123;</span><br><span class="line">         int now = nums[left] +nums[right];</span><br><span class="line">         ans = Math.max(ans, now);</span><br><span class="line">         left++;</span><br><span class="line">         right--;</span><br><span class="line">     &#125;</span><br><span class="line">     return ans;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试</title>
      <link href="2021/07/19/java%E9%9D%A2%E8%AF%95/"/>
      <url>2021/07/19/java%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="环境变量CLASSPATH的作用"><a href="#环境变量CLASSPATH的作用" class="headerlink" title="环境变量CLASSPATH的作用"></a>环境变量CLASSPATH的作用</h1><p>考点：classpath环境变量的作用、类的搜索和加载原理。</p><p>classpath环境变量是在编译java源码和运行程序时使用的，为java程序所依赖的接口、类等指定一个搜索路径。</p><p>java程序不仅在classpath中去搜索类，还会在jre/lib/rt.jar中找到jar文件。搜索顺序为先rt.jar，然后classpath指定的路径。</p><h1 id="变量及其作用范围"><a href="#变量及其作用范围" class="headerlink" title="变量及其作用范围"></a>变量及其作用范围</h1><p>​        在java中，变量根据生命周期（定义位置）的不同可以分为静态变量、成员变量和局部变量。</p><p>​        静态变量：类中使用static修饰的变量，生存周期由类决定，当类加载的时候，生成并初始化。</p><p>​        成员变量：在类中没有使用static修饰的变量，属于某个对象。随着对象的加载而生成并初始化，随着对象被垃圾回收器回收而消失。</p><p>​        局部变量：定义在方法中的变量或方法的参数，随着方法的调用（入栈）而创建，随着方法的执行结束（出栈）而消失。局部变量的定义可以和实例变量、静态变量的定义同名。</p><h1 id="哪两种数据类型"><a href="#哪两种数据类型" class="headerlink" title="哪两种数据类型"></a>哪两种数据类型</h1><p>基本数据类型和引用数据类型。区别在于引用数据类型存放的是数据所在的地址，基本数据类型则是直接存放数据的值。</p><h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><p>基本数据类型的变量转换成包装类：Interger.valueOf（）静态方法。</p><p>包装类转换成基本数据类型：调用包装类对象的intValue（）。</p><p>装箱和拆箱指的是基本数据类型和包装类型的自动相互转换，自动转换的过程在编译阶段。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="2021/07/19/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>2021/07/19/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>找关键字。比如题目中有连续，就应该条件反射想到滑动窗口和前缀和。比如题目求最大最小就想到动态规划和贪心等等。想到之后，就可以和题目信息对比快速排除错误的算法，找到可行解。这个思考的时间会随着你的题感增加而降低。</p><p>先写出暴力解，然后找暴力解的瓶颈， 根据瓶颈就很容易知道应该用什么数据结构和算法去优化。</p><h1 id="1480：一维数组的动态和"><a href="#1480：一维数组的动态和" class="headerlink" title="1480：一维数组的动态和"></a>1480：一维数组的动态和</h1><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p><p>请返回 nums 的动态和。</p><p>示例 1：</p><p>输入：nums = [1,2,3,4]<br>输出：[1,3,6,10]<br>解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。<br>示例 2：</p><p>输入：nums = [1,1,1,1,1]<br>输出：[1,2,3,4,5]<br>解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。<br>示例 3：</p><p>输入：nums = [3,1,2,10,1]<br>输出：[3,4,6,16,17]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int[] runningSum(int[] nums)&#123;</span><br><span class="line">    int[] numsSum = new int[nums.length];</span><br><span class="line">    if (nums.length &lt;= 0)&#123;</span><br><span class="line">        return numsSum;</span><br><span class="line">    &#125;</span><br><span class="line">    numsSum[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        numsSum[i] = numsSum[i - 1] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return numsSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="母题1"><a href="#母题1" class="headerlink" title="母题1"></a>母题1</h1><p>如果让你求一个数组的连续子数组总个数，你会如何求？其中连续指的是数组的索引连续。 比如 [1,3,4]，其连续子数组有：<code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，你需要返回 6。</p><p>一种思路是总的连续子数组个数等于：<strong>以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数</strong>，这无疑是完备的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int lianXuZiShuZu(int[] nums)&#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int pre = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            pre = pre + 1;</span><br><span class="line">            ans = ans + pre;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="母题2"><a href="#母题2" class="headerlink" title="母题2"></a>母题2</h1><p>求一个数组相邻差为 1 连续子数组的总个数呢？其实就是<strong>索引差 1 的同时，值也差 1。</strong>和上面思路类似，无非就是增加差值的判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int qianZhui(int[] nums)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int pre = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)&#123;</span><br><span class="line">        if (nums[i + 1] - nums[i] == 1)&#123;</span><br><span class="line">            pre = pre + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pre = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="母题3"><a href="#母题3" class="headerlink" title="母题3"></a>母题3</h1><p>求出不大于 k 的子数组的个数呢？不大于 k 指的是子数组的全部元素都不大于 k。 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，不大于 3 的子数组有 <code>[1], [3], [1,3]</code> ，那么 [1,3,4] 不大于 3 的子数组个数就是 3。 实现函数 atMostK(k, nums)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int atMostK(int[] nums, int k)&#123;</span><br><span class="line">    int ans = 0, pre = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if (nums[i] &lt;= k)&#123;</span><br><span class="line">            pre += 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pre = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += pre;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="母题4"><a href="#母题4" class="headerlink" title="母题4"></a>母题4</h1><p>求出子数组最大值刚好是 k 的子数组的个数呢？ 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，子数组最大值刚好是 3 的子数组有 <code>[3], [1,3]</code> ，那么 [1,3,4] 子数组最大值刚好是 3 的子数组个数就是 2。实现函数 exactK(k, nums)。</p><p>实际上是 exactK 可以直接利用 atMostK，即 atMostK(k) - atMostK(k - 1)，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public static int exactK(int[] nums, int k)&#123;</span><br><span class="line">        return atMostK(nums, k) - atMostK(nums, k -  1);</span><br><span class="line">    &#125;</span><br><span class="line">//</span><br><span class="line">    public static int atMostK(int[] nums, int k)&#123;</span><br><span class="line">        int ans = 0, pre = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (nums[i] &lt;= k)&#123;</span><br><span class="line">                pre += 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                pre = 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += pre;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="母题5"><a href="#母题5" class="headerlink" title="母题5"></a>母题5</h1><p>求出子数组最大值刚好是 介于 k1 和 k2 的子数组的个数呢？实现函数 betweenK(k1, k2, nums)。</p><p>实际上是 betweenK 可以直接利用 atMostK，即 atMostK(k1, nums) - atMostK(k2 - 1, nums)，其中 k1 &gt; k2。前提是值是离散的， 比如上面我出的题都是整数。 因此我可以直接 减 1，因为 <strong>1 是两个整数最小的间隔</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int betweenK(int k1, int k2, int[] nums)&#123;</span><br><span class="line">    return atMostK(nums, k1) - atMostK(nums, k2 - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int atMostK(int[] nums, int k)&#123;</span><br><span class="line">    int ans = 0, pre = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if (nums[i] &lt;= k)&#123;</span><br><span class="line">            pre += 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pre = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += pre;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724.寻找数组的中心下标"></a>724.寻找数组的中心下标</h1><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><p>示例 1：</p><p>输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>中心下标是 3 。<br>左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，<br>右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。<br>示例 2：</p><p>输入：nums = [1, 2, 3]<br>输出：-1<br>解释：<br>数组中不存在满足此条件的中心下标。</p><p>思路：前缀和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int pivotIndex(int[] nums)&#123;</span><br><span class="line">    int[] sum = new int[nums.length];</span><br><span class="line">    sum[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        sum[i] = sum[i - 1] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int leftRight = 0;</span><br><span class="line">    if (leftRight == sum[sum.length - 1] - sum[0])&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; sum.length - 1; i++)&#123;</span><br><span class="line">        if (sum[i - 1] == sum[sum.length - 1] - sum[i])&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum[sum.length - 2] == leftRight)&#123;</span><br><span class="line">        return sum.length - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="除自身以外数组的乘机"><a href="#除自身以外数组的乘机" class="headerlink" title="除自身以外数组的乘机"></a>除自身以外数组的乘机</h1><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><p>示例:</p><p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int length = nums.length;</span><br><span class="line">int[] left = new int[nums.length];</span><br><span class="line">int[] right = new int[nums.length];</span><br><span class="line">int[] outputs = new int[nums.length];</span><br><span class="line">left[0] = 1;</span><br><span class="line">right[length - 1] = 1;</span><br><span class="line">//当前索引为i的左侧乘机</span><br><span class="line">for (int i = 1; i &lt; length; i++)&#123;</span><br><span class="line">    left[i] = nums[i - 1] * left[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = length - 2; i &gt;= 0; i--)&#123;</span><br><span class="line">    right[i] = right[i + 1] * nums[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">    outputs[i] = left[i] * right[i];</span><br><span class="line">&#125;</span><br><span class="line">return outputs;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空间复杂度为o（1）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int[] productExceptSelf(int[] nums)&#123;</span><br><span class="line">    int length = nums.length;</span><br><span class="line">    int[] outputs = new int[nums.length];</span><br><span class="line">    outputs[0] = 1;</span><br><span class="line">    //当前索引为i的左侧乘机</span><br><span class="line">    for (int i = 1; i &lt; length; i++)&#123;</span><br><span class="line">        outputs[i] = nums[i - 1] * outputs[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int R = 1;</span><br><span class="line">    for (int i = length - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">        outputs[i] = outputs[i] * R;</span><br><span class="line">        R = R * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return outputs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="467-环绕字符串中唯一的字字符串"><a href="#467-环绕字符串中唯一的字字符串" class="headerlink" title="467.环绕字符串中唯一的字字符串"></a>467.环绕字符串中唯一的字字符串</h1><p>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”. </p><p>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 </p><p>注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。</p><p>示例 1:</p><p>输入: “a”<br>输出: 1<br>解释: 字符串 S 中只有一个”a”子字符。</p><p>示例 2:</p><p>输入: “cac”<br>输出: 2<br>解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.</p><p>示例 3:</p><p>输入: “zab”<br>输出: 6<br>解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter实战Day02</title>
      <link href="2021/07/19/Flutter%E5%AE%9E%E6%88%98Day02/"/>
      <url>2021/07/19/Flutter%E5%AE%9E%E6%88%98Day02/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章：基础组件"><a href="#第三章：基础组件" class="headerlink" title="第三章：基础组件"></a>第三章：基础组件</h1><h2 id="Widget："><a href="#Widget：" class="headerlink" title="Widget："></a>Widget：</h2><p>在Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 <code>GestureDetector</code> widget、用于APP主题数据传递的<code>Theme</code>等等，而原生开发中的控件通常只是指UI元素。</p><h3 id="Widget和Element"><a href="#Widget和Element" class="headerlink" title="Widget和Element"></a>Widget和Element</h3><p>在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而它只是描述显示元素的一个配置数据。</p><p>实际上，Flutter中真正代表屏幕上显示元素的类是<code>Element</code>，也就是说Widget只是描述<code>Element</code>的配置数据！有关<code>Element</code>的详细介绍我们将在本书后面的高级部分深入介绍，现在，读者只需要知道：**Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个<code>Element</code>**。这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个<code>Element</code>节点都会对应一个Widget对象。总结一下：</p><ul><li><p>Widget实际上就是<code>Element</code>的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由<code>Element</code>构成；不过，由于<code>Element</code>是通过Widget生成的，所以它们之间有对应关系，在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</p></li><li><p>一个Widget对象可以对应多个<code>Element</code>对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</p><h4 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h4></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line">  <span class="keyword">final</span> Key key;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toStringShort() &#123;</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="string">&#x27;<span class="subst">$runtimeType</span>&#x27;</span> : <span class="string">&#x27;<span class="subst">$runtimeType</span>-<span class="subst">$key</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Widget</code>类继承自<code>DiagnosticableTree</code>，<code>DiagnosticableTree</code>即“诊断树”，主要作用是提供调试信息。</li><li><code>Key</code>: 这个<code>key</code>属性类似于React/Vue中的<code>key</code>，主要的作用是决定是否在下一次<code>build</code>时复用旧的widget，决定的条件在<code>canUpdate()</code>方法中。</li><li><code>createElement()</code>：正如前文所述“一个Widget可以对应多个<code>Element</code>”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的<code>Element</code>对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。</li><li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li><li><code>canUpdate(...)</code>是一个静态方法，它主要用于在Widget树重新<code>build</code>时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的<code>Element</code>对象的配置；通过其源码我们可以看到，只要<code>newWidget</code>与<code>oldWidget</code>的<code>runtimeType</code>和<code>key</code>同时相等时就会用<code>newWidget</code>去更新<code>Element</code>对象的配置，否则就会创建新的<code>Element</code>。</li></ul><p>另外<code>Widget</code>类本身是一个抽象类，其中最核心的就是定义了<code>createElement()</code>接口，在Flutter开发中，我们一般都不用直接继承<code>Widget</code>类来实现一个新组件，相反，我们通常会通过继承<code>StatelessWidget</code>或<code>StatefulWidget</code>来间接继承<code>Widget</code>类来实现。<code>StatelessWidget</code>和<code>StatefulWidget</code>都是直接继承自<code>Widget</code>类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型，接下来我们将重点介绍一下这两个类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-19</title>
      <link href="2021/07/19/7-19/"/>
      <url>2021/07/19/7-19/</url>
      
        <content type="html"><![CDATA[<h1 id="1838：最高频元素的频数"><a href="#1838：最高频元素的频数" class="headerlink" title="1838：最高频元素的频数"></a>1838：最高频元素的频数</h1><p>元素的 频数 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。</p><p>执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。</p><p>示例 1：</p><p>输入：nums = [1,2,4], k = 5<br>输出：3<br>解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。<br>4 是数组中最高频元素，频数是 3 。<br>示例 2：</p><p>输入：nums = [1,4,8,13], k = 5<br>输出：2<br>解释：存在多种最优解决方案：</p><ul><li>对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。</li><li>对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。</li><li>对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。<br>示例 3：</li></ul><p>输入：nums = [3,9,6], k = 2<br>输出：1</p><p>思路：我写的排序+滑动窗口（但是时间超时了，测试用例都能通过）。想法是先对数组进行排序，滑动窗口内的是，每个数增加到最右侧所需要的的差值。判断该差值和k的关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int maxFrequency(int[] nums, int k)&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    int ans = 1;</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    while (right &lt;= nums.length - 1)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            sum = sum + (nums[right] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum &lt;= k)&#123;</span><br><span class="line">            ans = Math.max(ans, right - left + 1);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对如何求取差值做了优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int maxFrequency(int[] nums, int k)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int ans = 1;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int left = 0, right = 1;</span><br><span class="line">        while (right &lt; nums.length)&#123;</span><br><span class="line">            sum = sum + (nums[right] - nums[right - 1]) * (right - left);</span><br><span class="line">            if (sum &lt;= k)&#123;</span><br><span class="line">                ans = Math.max(ans, right - left + 1);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                sum = sum - (nums[right] - nums[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-18</title>
      <link href="2021/07/18/7-18/"/>
      <url>2021/07/18/7-18/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题10-02-变位词组"><a href="#面试题10-02-变位词组" class="headerlink" title="面试题10.02.变位词组"></a>面试题10.02.变位词组</h1><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p><p>注意：本题相对原题稍作修改</p><p>示例:</p><p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p><p>思路：变位词是指字母相同，排列不同的字符串。我们可以对同一类的变位词排序，将排序之后的（同一类的当然key相同）key作为map的key，用同一个list保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;String&gt;&gt; group(String[] strs)&#123;</span><br><span class="line">     HashMap&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">     for (String ss : strs)&#123;</span><br><span class="line">         char[] c = ss.toCharArray();</span><br><span class="line">         Arrays.sort(c);</span><br><span class="line">         String key = new String(c);</span><br><span class="line">         System.out.println(key);</span><br><span class="line">         System.out.println(&quot;===&quot;);</span><br><span class="line">         List&lt;String&gt; list = hashMap.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class="line">         list.add(ss);</span><br><span class="line">         hashMap.put(key, list);</span><br><span class="line">     &#125;</span><br><span class="line">     return new ArrayList&lt;&gt;(hashMap.values());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路2：一样的原理，同一类变位词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">     List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">     Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">     for (String s : strs) &#123;</span><br><span class="line">         int[] cnts = new int[26];</span><br><span class="line">         for (char c : s.toCharArray()) cnts[c - &#x27;a&#x27;]++;</span><br><span class="line">         StringBuilder sb = new StringBuilder();</span><br><span class="line">         for (int i : cnts) sb.append(i + &quot;_&quot;);</span><br><span class="line">         String key = sb.toString();</span><br><span class="line">         List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class="line">         list.add(s);</span><br><span class="line">         map.put(key, list);</span><br><span class="line">     &#125;</span><br><span class="line">     for (String key : map.keySet()) ans.add(map.get(key));</span><br><span class="line">     return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-17</title>
      <link href="2021/07/17/7-17/"/>
      <url>2021/07/17/7-17/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer42：连续子数组的最大和"><a href="#剑指offer42：连续子数组的最大和" class="headerlink" title="剑指offer42：连续子数组的最大和"></a>剑指offer42：连续子数组的最大和</h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>暴力递归：遍历数组，以i为子数组开始的所有子数组。并且比较大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">    int ans = Integer.MIN_VALUE;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        for (int j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum = sum + nums[j];</span><br><span class="line">            if (sum &gt; ans)&#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>如果当前子数组加上下一位变小了，说明需要重新选择子数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">        int currSum = 0;</span><br><span class="line">        int maxSum = Integer.MIN_VALUE;       //全负情况，返回最大数</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            currSum = (nums[j] &gt; currSum + nums[j]) ? nums[j] : currSum + nums[j];</span><br><span class="line">            maxSum = (maxSum &gt; currSum) ? maxSum : currSum;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转换成动态规划的过程：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        for(int j = 1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(dp[j-1]&gt;0)&#123;</span><br><span class="line">                dp[j] = dp[j-1]+nums[j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[j] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            if(dp[i]&gt;max)</span><br><span class="line">                max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-16</title>
      <link href="2021/07/17/7-16/"/>
      <url>2021/07/17/7-16/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer53：在排序数组中查找数字1"><a href="#剑指offer53：在排序数组中查找数字1" class="headerlink" title="剑指offer53：在排序数组中查找数字1"></a>剑指offer53：在排序数组中查找数字1</h1><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6</p><p>第一种可以放在一个map中，第二种可以遍历。这两种的时间复杂度都是o（n）的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target)&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            hashMap.put(nums[i], hashMap.getOrDefault(nums[i], 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return hashMap.get(target) != null ? hashMap.get(target) : 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>利用数组已经排序的特点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记day01</title>
      <link href="2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/"/>
      <url>2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记01"><a href="#操作系统笔记01" class="headerlink" title="操作系统笔记01"></a>操作系统笔记01</h1><h2 id="Hello-OS："><a href="#Hello-OS：" class="headerlink" title="Hello OS："></a>Hello OS：</h2><p>引导程序：机器加电启动后，整个计算机第一个启动的程序就是固化在PC主板上的BIOS固件，它启动之后检测系统参数，如内存的大小、日期和时间、磁盘设备以及这些磁盘设备用来引导的顺序。BIOS寻找用于装载操作系统的指令。装载操作系统的这个程序就是boot loader。Linux系统默认的boot loader就是GRUB（GRand Unified Bootloader），于是PC上电以后系统启动流程如下。<br><img "" class="lazyload placeholder" data-original="/2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/MyBolgWindows\blog\source\images\操作引导图.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="lable"></p><p>接下来我们要做的就是写一个由GRUB引导的“操作系统”——它会在屏幕上显示“Hello OS“。**注：**其实操作系统归根结底也是一个程序，只不过它在开机之后已经运行，并且权限和功能高的吓人，你可以将它看成是整个计算机应用的**管家角色**。</p><p>1.下载源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/lmos/cosmos/tree/master/</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="/2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/MyBolgWindows\blog\source\images\helloOs代码结构.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="lable"></p><p>entry.asm:汇编代码，用作GRUB引导调用，关掉中断，设定CPU工作模式，初始化寄存器及c语言运行环境。</p><p>hello.lds:进行链接调用。</p><p>install.md:需要将这个文件里的内容复制到GRUB的cfg配置文件中，才能使电脑开机时找到我们的HelloOS</p><p>main.c:HelloOS的主函数，注意printf不是c语言函数库，而是自己实现的printf也就是vgastr.h。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//彭东 @ 2021.01.09</span><br><span class="line">#include &quot;vgastr.h&quot;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello OS!&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vgastr.h:控制计算机屏幕VGABIOS固件程序显示特定的字符</p><p>Makefile：利用make工具来实现编译源代码主要是将entry.asm、main.c、vgastr.h编译并链接。</p><h2 id="编译操作系统：Makefile文件中已经写了如何编译-操作系统，只是自己目前看不懂。"><a href="#编译操作系统：Makefile文件中已经写了如何编译-操作系统，只是自己目前看不懂。" class="headerlink" title="编译操作系统：Makefile文件中已经写了如何编译 操作系统，只是自己目前看不懂。"></a>编译操作系统：Makefile文件中已经写了如何编译 操作系统，只是自己目前看不懂。</h2><p><img "" class="lazyload placeholder" data-original="/2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/MyBolgWindows\blog\source\images\编译过程.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-15</title>
      <link href="2021/07/15/7-15/"/>
      <url>2021/07/15/7-15/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2021/07/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2021/07/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找算法的应用范围："><a href="#二分查找算法的应用范围：" class="headerlink" title="二分查找算法的应用范围："></a>二分查找算法的应用范围：</h2><p>​        在有序数组中进行查找一个数（二分下标）:数组和有序</p><p>​        在整数范围内查找一个整数（二分答案）：</p><h2 id="二分查找的两种思路："><a href="#二分查找的两种思路：" class="headerlink" title="二分查找的两种思路："></a>二分查找的两种思路：</h2><p>​        <strong>思路一：在循环体中查找元素</strong></p><p>​        <strong>思路二：在循环体中排除目标元素一定不存在的区间</strong></p><h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//升序数组，数组中元素不重复</span><br><span class="line">    public static int binarySearch(int[] nums, int target)&#123;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        //条件是left &lt;= right，表示表示区间只有一个元素的时候，也需要判断。</span><br><span class="line">        //对应了二分查找算法的思路1，在循环体中查找元素</span><br><span class="line">        while (left &lt;= right)&#123;</span><br><span class="line">            //ind mid = (left + right) / 2，会发生溢出</span><br><span class="line">            //int mid = (left + right) &gt;&gt; 1.是等价的，位运算比整除运算要快一点。</span><br><span class="line">            //int mid = (left + right) &gt;&gt;&gt; 1.无符号右移，当发生整形溢出的时候，右移一位由于高位补0，结果依然正确。</span><br><span class="line">            //第一种思路里边，int mid = (left + right) / 2和 int mid = (left + right + 1) / 2都可以</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] == target)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;else if (nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                left = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="704-二分查找（另外一种写法）"><a href="#704-二分查找（另外一种写法）" class="headerlink" title="704.二分查找（另外一种写法）"></a>704.二分查找（另外一种写法）</h1><p>​        思路二：在循环体中排除目标一定不存在的区间，循环可以继续的条件是while（left &lt; right）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int search(int[] nums, int target) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line"></span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = len - 1;</span><br><span class="line">        // 目标元素可能存在在区间 [left, right]</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] &lt; target) &#123;</span><br><span class="line">                // 下一轮搜索区间是 [mid + 1, right]</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 下一轮搜索区间是 [left, mid]</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nums[left] == target) &#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int search(int[] nums, int target) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line"></span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = len - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid = left + (right - left + 1) / 2;</span><br><span class="line">            if (nums[mid] &gt; target) &#123;</span><br><span class="line">                // 下一轮搜索区间是 [left, mid - 1]</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 下一轮搜索区间是 [mid, right]</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nums[left] == target) &#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>循环条件是while（left &lt; right）表明当left==right的时候就退出了循环。有可能需要在退出循环的时候单独判断一次。</p><h3 id="为什么需要向上取整"><a href="#为什么需要向上取整" class="headerlink" title="为什么需要向上取整"></a>为什么需要向上取整</h3><p>mid 被分到左边区间<br>这个时候区分被分为两部分：[left, mid] 与 [mid + 1, right]，对应设置边界的代码为 right = mid 和 left = mid + 1;</p><p>mid 被分到右边区间<br>这个时候区分被分为两部分： [left, mid - 1] 与 [mid, right]，对应设置边界的代码为 right = mid - 1 和 left = mid。</p><p>注意：这种情况下，当搜索区间里只剩下两个元素的时候，一定要将取中间数的行为改成上取整，也就是在括号里加 1。</p><p>这是因为 [left, right] 区间里只剩下两个元素的时候，如果是取中间数 mid 是下取整，一旦进入 left = mid 这个分支，区间就不会再缩小，下一轮搜索的区间还是 [left, right] ，下一次循环取 mid 还是看到了 left ，由于逻辑和上一轮循环一样，因此搜索区间不会缩小，就这样一直下去，这是一个死循环。</p><p>解决方案也很简单，在最后一次循环的时候，把取中间数的时候修改为上取整。那么是不是要做一次判断，什么时候到了最后一轮循环呢？没有必要，整个循环体内，上取整就可以了。这个结论很重要，希望大家能够理解这里上取整的原因。根据循环体里，中位数被分到哪个区间，来决定取中间数的时候是否上取整。</p><h3 id="编码要点"><a href="#编码要点" class="headerlink" title="编码要点"></a>编码要点</h3><p>循环终止条件写成：while (left &lt; right) ，表示退出循环的时候只剩下一个元素；<br>在循环体内考虑如何缩减待搜索区间，也可以认为是在待搜索区间里排除一定不存在目标元素的区间；<br>根据中间数被分到左边和右边区间，来调整取中间数的行为；<br>如何缩小待搜索区间，一个有效的办法是：从 nums[mid] 满足什么条件的时候一定不是目标元素去考虑，进而考虑 mid 的左边元素和右边元素哪一边可能存在目标元素。一个结论是：当看到 left = mid 的时候，取中间数需要上取整，这一点是为了避免死循环；<br>退出循环的时候，根据题意看是否需要单独判断最后剩下的那个数是不是目标元素。<br>边界设置的两种写法：</p><p>right = mid 和 left = mid + 1 和 int mid = left + (right - left) / 2; 一定是配对出现的；<br>right = mid - 1 和 left = mid 和 int mid = left + (right - left + 1) / 2; 一定是配对出现的。</p><img "" class="lazyload placeholder" data-original="/2021/07/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/binarySearch.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="binarySearch" style="zoom:200%;"><p>这一点不需要记忆，大家只要一直思考目标元素可能存在的区间就可以了。就像我们在代码注释里展示给大家的一样。因为下一轮搜索的区间是 [left, mid] 所以这个时候设置 right = mid 。当前这条性质不满足的时候，既然整个区间是 [left, right] 区间里，第一种情况所在区间是 [left, mid] ，那么另外一种情况对应的区间是 [mid + 1, right] ，两个区间合起来就是整个区间 [left, right] 。同理，去理解 right = mid - 1 和 left = mid 这两个边界设置。</p><h1 id="704-二分查找（第三种写法）"><a href="#704-二分查找（第三种写法）" class="headerlink" title="704.二分查找（第三种写法）"></a>704.二分查找（第三种写法）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int search(int[] nums, int target) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line"></span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = len - 1;</span><br><span class="line">        // 目标元素可能存在在区间 [left, right]</span><br><span class="line">        while (left + 1 &lt; right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nums[left] == target) &#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nums[right] == target) &#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种思路循环可以继续的条件是 while (left + 1 &lt; right) ，在待搜索区间剩下两个元素的时候，退出循环，所以它不需要考虑死循环的问题；但是正是由于退出循环的时候区间里有 22 个元素，所以在退出循环的时候一定得做判断；</p><p>在循环体内分为 3 个分支，这一点和思路 1 是一样的；在循环体内，就没有 mid + 1 和 mid - 1 这样的表达式了。把中间数 mid 全部纳入下一轮要考虑的范围里。</p><p>这种写法，我们不建议大家这样写，理由如下：</p><p>left + 1 &lt; right 这种写法不是很自然；<br>退出循环的时候，一定要处理两个元素区间是两个元素的逻辑，这一步是附加的逻辑，是有可能出错的，相对于思路 2 是不太好的做法；<br>对于 mid 是不是在下一轮要考虑的区间里，这件事情只要思路清晰，是可以准确得出结论的，而这种写法恰好屏蔽了这些细节。</p><h1 id="题型一：二分下标（在数组中查找符合条件的元素的下标）"><a href="#题型一：二分下标（在数组中查找符合条件的元素的下标）" class="headerlink" title="题型一：二分下标（在数组中查找符合条件的元素的下标）"></a>题型一：二分下标（在数组中查找符合条件的元素的下标）</h1><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>示例 1:</p><p>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:</p><p>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:</p><p>输入: nums = [1,3,5,6], target = 7<br>输出: 4<br>示例 4:</p><p>输入: nums = [1,3,5,6], target = 0<br>输出: 0<br>示例 5:</p><p>输入: nums = [1], target = 0<br>输出: 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//寻找下标的题目。需要寻找的下标是第一个大于等于target的位置</span><br><span class="line">    public static int searchInsert(int[] nums, int target)&#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        if (nums[len - 1] &lt;= target)&#123;</span><br><span class="line">            return len;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[0] &gt;= target)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left = 0, right = len - 1;</span><br><span class="line">        while (left &lt; right)&#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个位置和最后一个位置"><a href="#34-在排序数组中查找元素的第一个位置和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个位置和最后一个位置"></a>34.在排序数组中查找元素的第一个位置和最后一个位置</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>示例 1：</p><p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums = [], target = 0<br>输出：[-1,-1]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//寻找下标的题目，是第一个和最后一个位置</span><br><span class="line">    public static int[] searchRange(int[] nums, int target)&#123;</span><br><span class="line">        int[] ans = &#123;-1, -1&#125;;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        int firstIndex = -1, endIndex = -1;</span><br><span class="line">        firstIndex = searchFirstIndex(nums, target);</span><br><span class="line">        if (firstIndex == -1)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[0] = firstIndex;</span><br><span class="line">        endIndex = searchLastIndex(nums, target);</span><br><span class="line">        ans[1] = endIndex;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int searchFirstIndex(int[] nums, int target)&#123;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        while (left &lt; right)&#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[left] == target)&#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int searchLastIndex(int[] nums, int target)&#123;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        while (left &lt; right)&#123;</span><br><span class="line">            int mid = left + (right - left + 1) / 2;</span><br><span class="line">            if (nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode33：搜索旋转排序数组"><a href="#leetcode33：搜索旋转排序数组" class="headerlink" title="leetcode33：搜索旋转排序数组"></a>leetcode33：搜索旋转排序数组</h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br>示例 2：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br>示例 3：</p><p>输入：nums = [1], target = 0<br>输出：-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target)&#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    int left = 0, right = nums.length;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)&#123;</span><br><span class="line">        if (nums[i] &gt; nums[i + 1])&#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = binarySearch(0, index, target, nums);</span><br><span class="line">    if (ans != -1)&#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    if (index + 1 &lt; nums.length)&#123;</span><br><span class="line">        ans = binarySearch(index + 1, nums.length - 1, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//区间为[]</span><br><span class="line">private static int binarySearch(int left, int right, int target, int[] nums) &#123;</span><br><span class="line">    while (left &lt;= right)&#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分不是单纯的指从有序数组中快速找到某个数，这只是二分的一份应用。</p><p>二分的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质就可以用二分。</p><h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a>287.寻找重复数</h2><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p><p>你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。</p><p>示例 1：</p><p>输入：nums = [1,3,4,2,2]<br>输出：2<br>示例 2：</p><p>输入：nums = [3,1,3,4,2]<br>输出：3<br>示例 3：</p><p>输入：nums = [1,1]<br>输出：1<br>示例 4：</p><p>输入：nums = [1,1,2]<br>输出：1</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter实战</title>
      <link href="2021/07/14/Flutter%E5%AE%9E%E6%88%98/"/>
      <url>2021/07/14/Flutter%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.flutterchina.club/">https://book.flutterchina.club/</a></p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h5 id="原生开发："><a href="#原生开发：" class="headerlink" title="原生开发："></a>原生开发：</h5><p>原生应用程序是指某一个移动平台（比如iOS或安卓）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。原生开发有以下主要优势：</p><ul><li>可访问平台全部功能（GPS、摄像头）；</li><li>速度快、性能高、可以实现复杂动画及绘制，整体用户体验好；</li></ul><p>主要缺点：</p><ul><li>平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大；</li><li>内容固定，动态化弱，大多数情况下，有新功能更新时只能发版；</li></ul><p>在移动互联网发展初期，业务场景并不复杂，原生开发还可以应对产品需求迭代。 但近几年，随着物联网时代到来、移动互联网高歌猛进，日新月异，在很多业务场景中，传统的纯原生开发已经不能满足日益增长的业务需求。主要表现在：</p><ul><li>动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，所以，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。</li><li>业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。</li></ul><p>总结一下，纯原生开发主要面临动态化和开发成本两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。</p><h5 id="跨平台技术"><a href="#跨平台技术" class="headerlink" title="跨平台技术"></a>跨平台技术</h5><p>针对原生开发面临问题，人们一直都在努力寻找好的解决方案，而时至今日，已经有很多跨平台框架(注意，本书中所指的“跨平台”若无特殊说明，即特指Android和iOS两个平台)，根据其原理，主要分为三类：</p><ul><li>H5+原生（Cordova、Ionic、微信小程序）</li><li>JavaScript开发+原生渲染 （React Native、Weex、快应用）</li><li>自绘UI+原生(QT for mobile、Flutter)</li></ul><p>Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。那么，我们会担心，QT mobile面对的问题Flutter是否也一样，Flutter会不会步入QT mobile后尘，成为另一个烈士？要回到这个问题，我们先来看看Flutter诞生过程：</p><ul><li>2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架——Flutter。</li><li>2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。</li><li>2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。</li></ul><p>观其发展，在2018年5月份，Flutter 进入了 GitHub stars 排行榜前 100 名，已有 27k star。而今天(2019年5月29日)，已经有65K的Star。经历了短短2年多的时间，Flutter 生态系统得以快速增长，由此可见，Flutter在开发者中受到了热烈的欢迎，其未来发展值得期待！</p><p>现在，我们来和QT mobile做一个对比：</p><ol><li>生态：从Github上来看，目前Flutter活跃用户正在高速增长。从Stackoverflow上提问来看，Flutter社区现在已经很庞大。Flutter的文档、资源也越来越丰富，开发过程中遇到的很多问题都可以在Stackoverflow或其github issue中找到答案。</li><li>技术支持：现在Google正在大力推广Flutter，Flutter的作者中很多人都是来自Chromium团队，并且github上活跃度很高。另一个角度，从今年上半年Flutter频繁的版本发布也可以看出Google对Flutter的投入的资源不小，所以在官方技术支持这方面，大可不必担心。</li><li>开发效率：Flutter的热重载可帮助开发者快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以实现毫秒级热重载，并且不会丢失状态。这真的很棒，相信我，如果你是一名原生开发者，体验了Flutter开发流后，很可能就不想重新回去做原生了，毕竟很少有人不吐槽原生开发的编译速度。</li></ol><h5 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h5><p>Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。</p><h6 id="跨平台自绘引擎"><a href="#跨平台自绘引擎" class="headerlink" title="#跨平台自绘引擎"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%87%AA%E7%BB%98%E5%BC%95%E6%93%8E">#</a>跨平台自绘引擎</h6><p>Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。</p><p>Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。</p><p>目前Flutter默认支持iOS、Android、Fuchsia（Google新的自研操作系统）三个移动平台。但Flutter亦可支持Web开发（Flutter for web）和PC开发，本书的示例和介绍主要是基于iOS和Android平台的，其它平台读者可以自行了解。</p><h6 id="高性能"><a href="#高性能" class="headerlink" title="#高性能"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E9%AB%98%E6%80%A7%E8%83%BD">#</a>高性能</h6><p>Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。</p><h6 id="采用Dart语言开发"><a href="#采用Dart语言开发" class="headerlink" title="#采用Dart语言开发"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E9%87%87%E7%94%A8dart%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91">#</a>采用Dart语言开发</h6><p>这是一个很有意思，但也很有争议的问题，在了解Flutter为什么选择了 Dart而不是 JavaScript之前我们先来介绍两个概念：JIT和AOT。</p><p>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。</p><p>现在我们看看Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）：</p><ol><li><p><strong>开发效率高</strong></p><p>Dart运行时和编译器支持Flutter的两个关键特性的组合：</p><p><strong>基于JIT的快速开发周期</strong>：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</p><p><strong>基于AOT的发布包</strong>: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。</p></li><li><p><strong>高性能</strong></p><p>Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。</p></li><li><p><strong>快速内存分配</strong></p><p>Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。</p></li><li><p><strong>类型安全</strong></p><p>由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。</p></li></ol><h6 id="Flutter框架结构"><a href="#Flutter框架结构" class="headerlink" title="Flutter框架结构"></a>Flutter框架结构</h6><p><img "" class="lazyload placeholder" data-original="/2021/07/14/Flutter%E5%AE%9E%E6%88%98/MyBolgWindows\blog\source_posts\flutter.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="flutter"></p><h6 id="Flutter-Framework：这是一个纯-Dart实现的-SDK，它实现了一套基础库，自底向上，我们来简单介绍一下："><a href="#Flutter-Framework：这是一个纯-Dart实现的-SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：" class="headerlink" title="Flutter Framework：这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下："></a>Flutter Framework：这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：</h6><ul><li>底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的<code>dart:ui</code>包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。</li><li>Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。</li><li>Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而<strong>我们Flutter开发的大多数场景，只是和这两层打交道</strong>。</li></ul><h6 id="Flutter-Engine"><a href="#Flutter-Engine" class="headerlink" title="Flutter Engine"></a>Flutter Engine</h6><p>这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 <code>dart:ui</code>库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。</p><h1 id="计数器应用示例"><a href="#计数器应用示例" class="headerlink" title="计数器应用示例"></a>计数器应用示例</h1><p>计数器示例中，每点击一次右下角+号，屏幕中央的数字就会加一。Dart的代码主要在lib/main.dart文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//导入Material UI组件库，Material是一种</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">//flutter应用中main函数作为应用程序的入口。main函数调用了runApp方法，</span><br><span class="line">//功能是启动Flutter应用，接收一个Widget参数。</span><br><span class="line">//=&gt;是Dart中单行函数或方法的简写</span><br><span class="line">//MyApp（）是flutter应用的根组件</span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &#x27;Flutter Demo&#x27;,</span><br><span class="line">      theme: new ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: new MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//首页</span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  MyHomePage(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line">  final String title;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; new _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//_MyHomePageState是MyHomePage类对应的状态类</span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  //维护了一个点击次数计数器</span><br><span class="line">  int _counter = 0;</span><br><span class="line">  //设置状态的自增函数，函数会先自增_counter，然后调用setState方法</span><br><span class="line">  //setState方法的作用是通知Flutter框架，有状态发生了改变，Flutter框架收到通知后，会执行build方法来根据新的状态重新构建界面， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget。</span><br><span class="line">  void _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">//构建UI界面的逻辑在build方法中，当MyHomePage第一次创建时，_MyHomePageState类会被创建，当初始化完成后，Flutter框架会调用Widget的build方法来构建widget树，最终将widget树渲染到设备屏幕上</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Scaffold(</span><br><span class="line">      appBar: new AppBar(</span><br><span class="line">        title: new Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: new Center(</span><br><span class="line">        child: new Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            new Text(</span><br><span class="line">              &#x27;You have pushed the button this many times:&#x27;,</span><br><span class="line">            ),</span><br><span class="line">            new Text(</span><br><span class="line">              &#x27;$_counter&#x27;,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: new FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: &#x27;Increment&#x27;,</span><br><span class="line">        child: new Icon(Icons.add),</span><br><span class="line">      ), // This trailing comma makes auto-formatting nicer for build methods.</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    MyApp类代表Flutter应用，它继承了 StatelessWidget类，这也就意味着应用本身也是一个widget。<br>​    在Flutter中，大多数东西都是widget（后同“组件”或“部件”），包括对齐(alignment)、填充(padding)和布局(layout)等，它们都是以widget的形式提供。<br>​    Flutter在构建页面时，会调用组件的build方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。<br>​    MaterialApp 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。MaterialApp也是一个widget。<br>​    home 为Flutter应用的首页，它也是一个widget。</p><p>​    <code>MyHomePage</code> 是Flutter应用的首页，它继承自<code>StatefulWidget</code>类，表示它是一个有状态的组件（Stateful widget）。关于Stateful widget我们将在第三章“Widget简介”一节仔细介绍，现在我们只需简单认为有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同：</p><ol><li><p>Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。</p></li><li><p>Stateful widget至少由两个类组成：</p><ul><li>一个<code>StatefulWidget</code>类。</li><li>一个 <code>State</code>类； <code>StatefulWidget</code>类本身是不变的，但是<code>State</code>类中持有的状态在widget生命周期中可能会发生变化。</li></ul><p><code>_MyHomePageState</code>类是<code>MyHomePage</code>类对应的状态类。看到这里，读者可能已经发现：和<code>MyApp</code> 类不同， <code>MyHomePage</code>类中并没有<code>build</code>方法，取而代之的是，<code>build</code>方法被挪到了<code>_MyHomePageState</code>方法中，</p></li></ol><p><code>Scaffold</code> 是 Material 库中提供的页面脚手架，它提供了默认的导航栏、标题和包含主屏幕widget树（后同“组件树”或“部件树”）的<code>body</code>属性，组件树可以很复杂。本书后面示例中，路由默认都是通过<code>Scaffold</code>创建。</p><p><code>body</code>的组件树中包含了一个<code>Center</code> 组件，<code>Center</code> 可以将其子组件树对齐到屏幕中心。此例中， <code>Center</code> 子组件是一个<code>Column</code> 组件，<code>Column</code>的作用是将其所有子组件沿屏幕垂直方向依次排列； 此例中<code>Column</code>子组件是两个 <code>Text</code>，第一个<code>Text</code> 显示固定文本 “You have pushed the button this many times:”，第二个<code>Text</code> 显示<code>_counter</code>状态的数值。</p><p><code>floatingActionButton</code>是页面右下角的带“+”的悬浮按钮，它的<code>onPressed</code>属性接受一个回调函数，代表它被点击后的处理器，本例中直接将<code>_incrementCounter</code>方法作为其处理函数。</p><p>整个计数器执行流程串起来：当右下角的<code>floatingActionButton</code>按钮被点击之后，会调用<code>_incrementCounter</code>方法。在<code>_incrementCounter</code>方法中，首先会自增<code>_counter</code>计数器（状态），然后<code>setState</code>会通知Flutter框架状态发生变化，接着，Flutter框架会调用<code>build</code>方法以新的状态重新构建UI，最终显示在设备屏幕上</p><h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><p>​        路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。Flutter中的路由管理和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p><h2 id="MaterialPageRoute"><a href="#MaterialPageRoute" class="headerlink" title="MaterialPageRoute"></a>MaterialPageRoute</h2><p><code>MaterialPageRoute</code>继承自<code>PageRoute</code>类，<code>PageRoute</code>类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。<code>MaterialPageRoute</code> 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画：</p><ul><li>对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。</li><li>对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  MaterialPageRoute(&#123;</span><br><span class="line">    WidgetBuilder builder,</span><br><span class="line">    RouteSettings settings,</span><br><span class="line">    bool maintainState = true,</span><br><span class="line">    bool fullscreenDialog = false,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">//builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。</span><br><span class="line">//settings 包含路由的配置信息，如路由名称、是否初始路由（首页）。</span><br><span class="line">//maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。</span><br><span class="line">//fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。</span><br></pre></td></tr></table></figure><h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator:"></a>Navigator:</h2><p><code>Navigator</code>是一个路由管理的组件，它提供了打开和退出路由页方法。<code>Navigator</code>通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。<code>Navigator</code>提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：</p><h3 id="Future-push-BuildContext-context-Route-route"><a href="#Future-push-BuildContext-context-Route-route" class="headerlink" title="Future push(BuildContext context, Route route)"></a>Future push(BuildContext context, Route route)</h3><p>将给定的路由入栈（即打开新的页面），返回值是一个<code>Future</code>对象，用以接收新路由出栈（即关闭）时的返回数据。</p><h3 id="bool-pop-BuildContext-context-result"><a href="#bool-pop-BuildContext-context-result" class="headerlink" title="#bool pop(BuildContext context, [ result ])"></a><a href="https://book.flutterchina.club/chapter2/flutter_router.html#bool-pop-buildcontext-context-result">#</a>bool pop(BuildContext context, [ result ])</h3><p>将栈顶路由出栈，<code>result</code>为页面关闭时返回给上一个页面的数据。</p><p><code>Navigator</code> 还有很多其它方法，如<code>Navigator.replace</code>、<code>Navigator.popUntil</code>等，详情请参考API文档或SDK源码注释，在此不再赘述。</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>Navigator类中第一个参数为context的<strong>静态方法</strong>都对应一个Navigator的<strong>实例方法</strong>， 比如<code>Navigator.push(BuildContext context, Route route)</code>等价于<code>Navigator.of(context).push(Route route)</code></p><h2 id="路由传值："><a href="#路由传值：" class="headerlink" title="路由传值："></a>路由传值：</h2><h3 id="命名路由传值：命名路由”（Named-Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。"><a href="#命名路由传值：命名路由”（Named-Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。" class="headerlink" title="命名路由传值：命名路由”（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。"></a>命名路由传值：命名路由”（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。</h3><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。其实注册路由表就是给路由起名字，路由表的定义如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, WidgetBuilder&gt; routes;</span><br></pre></td></tr></table></figure><p>它是一个<code>Map</code>，key为路由的名字，是个字符串；value是个<code>builder</code>回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的<code>WidgetBuilder</code>回调函数，然后调用该回调函数生成路由widget并返回</p><h3 id="注册路由表："><a href="#注册路由表：" class="headerlink" title="注册路由表："></a>注册路由表：</h3><p><code>MyApp</code>类的<code>build</code>方法中找到<code>MaterialApp</code>，添加<code>routes</code>属性，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: &#x27;Flutter Demo&#x27;,</span><br><span class="line">  theme: ThemeData(</span><br><span class="line">    primarySwatch: Colors.blue,</span><br><span class="line">  ),</span><br><span class="line">  //注册路由表</span><br><span class="line">  routes:&#123;</span><br><span class="line">   &quot;new_page&quot;:(context) =&gt; NewRoute(),</span><br><span class="line">    ... // 省略其它路由注册信息</span><br><span class="line">  &#125; ,</span><br><span class="line">  home: MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>将home注册为命名路由：只需在路由表中注册一下<code>MyHomePage</code>路由，然后将其名字作为<code>MaterialApp</code>的<code>initialRoute</code>属性值即可，该属性决定应用的初始路由页是哪一个命名路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: &#x27;Flutter Demo&#x27;,</span><br><span class="line">  initialRoute:&quot;/&quot;, //名为&quot;/&quot;的路由作为应用的home(首页)</span><br><span class="line">  theme: ThemeData(</span><br><span class="line">    primarySwatch: Colors.blue,</span><br><span class="line">  ),</span><br><span class="line">  //注册路由表</span><br><span class="line">  routes:&#123;</span><br><span class="line">   &quot;new_page&quot;:(context) =&gt; NewRoute(),</span><br><span class="line">   &quot;/&quot;:(context) =&gt; MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;), //注册首页路由</span><br><span class="line">  &#125; </span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-14</title>
      <link href="2021/07/14/7-14/"/>
      <url>2021/07/14/7-14/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode1818：绝对差值和"><a href="#leetcode1818：绝对差值和" class="headerlink" title="leetcode1818：绝对差值和"></a>leetcode1818：绝对差值和</h1><p>给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。</p><p>数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。</p><p>你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。</p><p>|x| 定义为：</p><p>如果 x &gt;= 0 ，值为 x ，或者<br>如果 x &lt;= 0 ，值为 -x</p><p>示例 1：</p><p>输入：nums1 = [1,7,5], nums2 = [2,3,5]<br>输出：3<br>解释：有两种可能的最优方案：</p><ul><li>将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者</li><li>将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]<br>两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3<br>示例 2：</li></ul><p>输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]<br>输出：0<br>解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0<br>示例 3：</p><p>输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]<br>输出：20<br>解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] =&gt; [10,10,4,4,2,7]<br>绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20</p><p>解析：这竟然是一道二分查找的题，难道因为刚睡醒一点思路也没有。<img "" class="lazyload placeholder" data-original="file:///C:\Users\ydhc\AppData\Local\Temp\SGPicFaceTpBq\13032\0F7E7DE0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-13</title>
      <link href="2021/07/13/7-13/"/>
      <url>2021/07/13/7-13/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode218天际线问题"><a href="#leetcode218天际线问题" class="headerlink" title="leetcode218天际线问题"></a>leetcode218天际线问题</h1><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p><p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br>righti 是第 i 座建筑物右边缘的 x 坐标。<br>heighti 是第 i 座建筑物的高度。<br>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p><p>具体题目请看<a href="https://leetcode-cn.com/problems/the-skyline-problem/">https://leetcode-cn.com/problems/the-skyline-problem/</a></p><h6 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h6>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter</title>
      <link href="2021/07/13/Flutter/"/>
      <url>2021/07/13/Flutter/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter完整开发实战详解系列"><a href="#Flutter完整开发实战详解系列" class="headerlink" title="Flutter完整开发实战详解系列"></a>Flutter完整开发实战详解系列</h1><p>flutter中所有的组件都是类。</p><h5 id="Flutter-Widget："><a href="#Flutter-Widget：" class="headerlink" title="Flutter Widget："></a>Flutter Widget：</h5><p>在flutter中一切的显示都是widget，widget是一切的基础，利用响应式模式进行渲染。可以修改数据，再用setState设置数据，Flutter会自动通过绑定的数据更新Widget，所以开发者需要做的就是实现Widget，并且和数据绑定。</p><p>Widget分为有状态和无状态两种，在Flutter中每个页面都是一帧，无状态就是保持在那一帧，有状态的Widget当数据更新时，其实是创建了新的Widget，只是State实现了跨帧的数据同步保存。</p><h6 id="无状态的StatelessWidget"><a href="#无状态的StatelessWidget" class="headerlink" title="无状态的StatelessWidget"></a>无状态的StatelessWidget</h6><p>自定义的Widget（类），继承StatelessWidget（抽象类）。通过build方法返回一个布局好的控件。Widget和Widget之间通过child进行嵌套，有的Widget只能有一个child（比如container），有的可以有多个child（比如Column布局）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class DemoWidget extends StatelessWidget&#123;</span><br><span class="line">  //数据可以通过构造方法传递进来</span><br><span class="line">  final String? text;</span><br><span class="line">  DemoWidget(this.text);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    //throw UnimplementedError();</span><br><span class="line">    //这里返回需要的控件</span><br><span class="line">    return Container(</span><br><span class="line">      //蓝色背景</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">      //在Dart语法中，？？表示如果text为空，返回尾号后的内容</span><br><span class="line">      child: Text(text ?? &quot;这就是无状态的Demo&quot;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="有状态的StatefulWidget"><a href="#有状态的StatefulWidget" class="headerlink" title="有状态的StatefulWidget"></a>有状态的StatefulWidget</h6><p>需要创建管理的主要是State，通过State的build方法构建控件。在State中可以动态改变数据，在setState之后，改变的数据会触发Widget重新构建刷新</p><p>State中的声明周期有：initState：初始化，理论上只有一次，有特殊情况。</p><p>didChangeDependencies：在initState之后调用，此时可以获取其他State</p><p>dispose：销毁，只会调用一次</p><p>综上：flutter中的关注点：创建StatelessWidget或者StatefulWidget，需要的就是在build中堆积你的布局，然后把数据添加到Widget中，最后通过setState改变数据，实现画面变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:async&#x27;;</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class DemoStateWidget extends StatefulWidget&#123;</span><br><span class="line">  //通过构造方法传值</span><br><span class="line">  final String text;</span><br><span class="line">  DemoStateWidget(this.text);</span><br><span class="line"></span><br><span class="line">  //主要是负责创建state</span><br><span class="line">  @override</span><br><span class="line">  _DemoStateWidgetState createState() &#123;</span><br><span class="line">    // TODO: implement createState</span><br><span class="line">    throw UnimplementedError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _DemoStateWidgetState extends State&lt;DemoStateWidget&gt;&#123;</span><br><span class="line">  //同样通过构造方法传值</span><br><span class="line">  String text;</span><br><span class="line">  _DemoStateWidgetState(this.text);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    //初始化，这个函数在声明周期中只调用一次</span><br><span class="line">    // TODO: implement initState</span><br><span class="line">    super.initState();</span><br><span class="line">    //定时一秒</span><br><span class="line">    new Future.delayed(const Duration(seconds: 1),())&#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        text = &quot;这就遍历数值&quot;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    //销毁</span><br><span class="line">    // TODO: implement dispose</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void didChangeDependencies() &#123;</span><br><span class="line">    //在initState之后</span><br><span class="line">    // TODO: implement didChangeDependencies</span><br><span class="line">    super.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    //throw UnimplementedError();</span><br><span class="line">    return Container(</span><br><span class="line">      child: Text(text ?? &quot;这就是有状态的Demo&quot;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Flutter布局"><a href="#Flutter布局" class="headerlink" title="Flutter布局"></a>Flutter布局</h5><p>Flutter 中拥有需要将近 30 种内置的 布局 Widget ，其中常⽤有Container 、<br>Padding 、 Center 、 Flex 、 Stack 、 Row 、 Column 、 ListView 等，</p><h6 id="Container：只有⼀个⼦Widget-。默认充满，包含了-padding-、"><a href="#Container：只有⼀个⼦Widget-。默认充满，包含了-padding-、" class="headerlink" title="Container：只有⼀个⼦Widget 。默认充满，包含了 padding 、"></a>Container：只有⼀个⼦Widget 。默认充满，包含了 padding 、</h6><p>margin 、 color 、宽⾼、 decoration 等配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">最常⽤的默认控件，但是实际上它是由多个内置控件组</span><br><span class="line">成的模版，只能包含⼀个child ，⽀持padding,margin,color, 宽</span><br><span class="line">⾼ ,decoration （⼀般配置边框和阴影）等配置，在Flutter 中，不是</span><br><span class="line">所有的控件都有宽⾼、 padding 、 margin 、 color 等属性，所以才会</span><br><span class="line">有Padding 、 Center 等Widget 的存在。</span><br><span class="line"></span><br><span class="line">new Container(</span><br><span class="line">/// 四周 10 ⼤⼩的 maring</span><br><span class="line">margin: EdgeInsets.all(10.0),</span><br><span class="line">height: 120.0,</span><br><span class="line">width: 500.0,</span><br><span class="line">/// 透明⿊⾊遮罩</span><br><span class="line">decoration: new BoxDecoration(</span><br><span class="line">/// 弧度为 4.0</span><br><span class="line">borderRadius: BorderRadius.all(Radius.circula</span><br><span class="line">/// 设置了 decoration 的 color ，就不能设置 Container 的</span><br><span class="line">color: Colors.black,</span><br><span class="line">/// 边框</span><br><span class="line">border: new Border.all(color: Color(GSYColors</span><br><span class="line">child:new Text(&quot;666666&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Padding：只有⼀个⼦Widget-。只⽤于设置-Padding-，常⽤于嵌"><a href="#Padding：只有⼀个⼦Widget-。只⽤于设置-Padding-，常⽤于嵌" class="headerlink" title="Padding：只有⼀个⼦Widget 。只⽤于设置 Padding ，常⽤于嵌"></a>Padding：只有⼀个⼦Widget 。只⽤于设置 Padding ，常⽤于嵌</h6><p>套 child ，给 child 设置 padding </p><h6 id="Center：只有⼀个⼦Widget-。只⽤于居中显示，常⽤于嵌套"><a href="#Center：只有⼀个⼦Widget-。只⽤于居中显示，常⽤于嵌套" class="headerlink" title="Center：只有⼀个⼦Widget 。只⽤于居中显示，常⽤于嵌套"></a>Center：只有⼀个⼦Widget 。只⽤于居中显示，常⽤于嵌套</h6><p>child ，给 child 设置居中</p><h6 id="Stack：可以有多个⼦Widget-。⼦-Widget-堆叠在⼀起。"><a href="#Stack：可以有多个⼦Widget-。⼦-Widget-堆叠在⼀起。" class="headerlink" title="Stack：可以有多个⼦Widget 。⼦ Widget 堆叠在⼀起。"></a>Stack：可以有多个⼦Widget 。⼦ Widget 堆叠在⼀起。</h6><h6 id="Column：可以有多个⼦Widget-。垂直布局"><a href="#Column：可以有多个⼦Widget-。垂直布局" class="headerlink" title="Column：可以有多个⼦Widget 。垂直布局"></a>Column：可以有多个⼦Widget 。垂直布局</h6><h6 id="Row：可以有多个⼦Widget-。⽔平布局"><a href="#Row：可以有多个⼦Widget-。⽔平布局" class="headerlink" title="Row：可以有多个⼦Widget 。⽔平布局"></a>Row：可以有多个⼦Widget 。⽔平布局</h6><p>Column 、 Row 绝对是必备布局， 横竖布局也是⽇常中最常⻅的场<br>景。如下⽅所示，它们常⽤的有这些属性配置：主轴⽅向是 start 或<br>center 等；副轴⽅向⽅向是start 或center 等； mainAxisSize 是充满<br>最⼤尺⼨，或者只根据⼦Widget 显示最⼩尺⼨</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 主轴⽅向， Column 的竖向、 Row 我的横向</span><br><span class="line">mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">// 默认是最⼤充满、还是根据 child 显示最⼩⼤⼩</span><br><span class="line">mainAxisSize: MainAxisSize.max,</span><br><span class="line">// 副轴⽅向， Column 的横向、 Row 我的竖向</span><br><span class="line">crossAxisAlignment :CrossAxisAlignment.center,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Expanded：只有⼀个⼦Widget-。在Column-和Row-中充满。"><a href="#Expanded：只有⼀个⼦Widget-。在Column-和Row-中充满。" class="headerlink" title="Expanded：只有⼀个⼦Widget 。在Column 和Row 中充满。"></a>Expanded：只有⼀个⼦Widget 。在Column 和Row 中充满。</h6><p>Expanded 在Column 和Row 中代表着平均充满的作⽤，当有两个存在的时候默认均分充满。同时⻚可以设置flex 属性决定⽐例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Column(</span><br><span class="line">/// 主轴居中 , 即是竖直向居中</span><br><span class="line">mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">/// ⼤⼩按照最⼩显示</span><br><span class="line">mainAxisSize : MainAxisSize.min,</span><br><span class="line">/// 横向也居中</span><br><span class="line">crossAxisAlignment : CrossAxisAlignment.center,</span><br><span class="line">children: &lt;Widget&gt;[</span><br><span class="line">///flex 默认为 1</span><br><span class="line">new Expanded(child: new Text(&quot;1111&quot;), flex: 2,),</span><br><span class="line">new Expanded(child: new Text(&quot;2222&quot;)),</span><br><span class="line">],</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="ListView：可以有多个子Widget"><a href="#ListView：可以有多个子Widget" class="headerlink" title="ListView：可以有多个子Widget"></a>ListView：可以有多个子Widget</h6><h5 id="Flutter页面"><a href="#Flutter页面" class="headerlink" title="Flutter页面"></a>Flutter页面</h5><p>Flutter 中除了布局的Widget ，还有交互显示的Widget 和完整⻚⾯呈现的<br>Widget ，其中常⻅的有MaterialApp 、 Scaffold 、 Appbar 、 Text 、 Image 、FlatButton 等</p><h6 id="MaterialApp：⼀般作为-APP-顶层的主⻚⼊⼝，可配置主题，多语"><a href="#MaterialApp：⼀般作为-APP-顶层的主⻚⼊⼝，可配置主题，多语" class="headerlink" title="MaterialApp：⼀般作为 APP 顶层的主⻚⼊⼝，可配置主题，多语"></a>MaterialApp：⼀般作为 APP 顶层的主⻚⼊⼝，可配置主题，多语</h6><p>⾔，路由等</p><h6 id="Scaffold：⼀般⽤户⻚⾯的承载-Widget-，包含-appbar-、snackbar-、-drawer-等-material-design-的设定"><a href="#Scaffold：⼀般⽤户⻚⾯的承载-Widget-，包含-appbar-、snackbar-、-drawer-等-material-design-的设定" class="headerlink" title="Scaffold：⼀般⽤户⻚⾯的承载 Widget ，包含 appbar 、snackbar 、 drawer 等 material design 的设定"></a>Scaffold：⼀般⽤户⻚⾯的承载 Widget ，包含 appbar 、snackbar 、 drawer 等 material design 的设定</h6><h6 id="Appbar：⼀般⽤于-Scaffold-的-appbar-，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些，-tabbar-等也会需要它"><a href="#Appbar：⼀般⽤于-Scaffold-的-appbar-，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些，-tabbar-等也会需要它" class="headerlink" title="Appbar：⼀般⽤于 Scaffold 的 appbar ，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些， tabbar 等也会需要它"></a>Appbar：⼀般⽤于 Scaffold 的 appbar ，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些， tabbar 等也会需要它</h6><h6 id="Text：显示⽂本，⼏乎都会⽤到，主要是通过-style-设置TextStyle-来设置字体样式等"><a href="#Text：显示⽂本，⼏乎都会⽤到，主要是通过-style-设置TextStyle-来设置字体样式等" class="headerlink" title="Text：显示⽂本，⼏乎都会⽤到，主要是通过 style 设置TextStyle 来设置字体样式等"></a>Text：显示⽂本，⼏乎都会⽤到，主要是通过 style 设置TextStyle 来设置字体样式等</h6><h6 id="RichText：富⽂本，通过设置TextSpan-，可以拼接出富⽂本场景。"><a href="#RichText：富⽂本，通过设置TextSpan-，可以拼接出富⽂本场景。" class="headerlink" title="RichText：富⽂本，通过设置TextSpan ，可以拼接出富⽂本场景。"></a>RichText：富⽂本，通过设置TextSpan ，可以拼接出富⽂本场景。</h6><h6 id="TextField：⽂本输⼊框-：new-TextField-controller-⽂本控制器-obscureText-“hint-⽂本-“"><a href="#TextField：⽂本输⼊框-：new-TextField-controller-⽂本控制器-obscureText-“hint-⽂本-“" class="headerlink" title="TextField：⽂本输⼊框 ：new TextField(controller: // ⽂本控制器 , obscureText: “hint ⽂本 “);"></a>TextField：⽂本输⼊框 ：new TextField(controller: // ⽂本控制器 , obscureText: “hint ⽂本 “);</h6><h6 id="Image：图⽚加载-new-FadeInImage-assetNetwork"><a href="#Image：图⽚加载-new-FadeInImage-assetNetwork" class="headerlink" title="Image：图⽚加载 : new FadeInImage.assetNetwork("></a>Image：图⽚加载 : new FadeInImage.assetNetwork(</h6><p>placeholder: “ 预览图 “, </p><p>fit:BoxFit.fitWidth, </p><p>image: “url”);</p><h6 id="FlatButton：按键点击-new-FlatButton-onPressed-child-new-Container"><a href="#FlatButton：按键点击-new-FlatButton-onPressed-child-new-Container" class="headerlink" title="FlatButton：按键点击 : new FlatButton(onPressed: (){},child: new Container());"></a>FlatButton：按键点击 : new FlatButton(onPressed: (){},child: new Container());</h6>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DartDay2</title>
      <link href="2021/07/12/DartDay2/"/>
      <url>2021/07/12/DartDay2/</url>
      
        <content type="html"><![CDATA[<h1 id="DartDay2"><a href="#DartDay2" class="headerlink" title="DartDay2"></a>DartDay2</h1><h6 id="静态属性和静态方法，可以通过类来访问不用通过实例"><a href="#静态属性和静态方法，可以通过类来访问不用通过实例" class="headerlink" title="静态属性和静态方法，可以通过类来访问不用通过实例"></a>静态属性和静态方法，可以通过类来访问不用通过实例</h6><p>Dart中的静态成员:</p><p>  1、使用static 关键字来实现类级别的变量和函数</p><p>  2、静态方法不能访问非静态成员，非静态方法可以访问静态成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// class Person &#123;</span><br><span class="line">//   static String name = &#x27;张三&#x27;;</span><br><span class="line">//   static void show() &#123;</span><br><span class="line">//     print(name);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// main()&#123;</span><br><span class="line">//   print(Person.name);</span><br><span class="line">//   Person.show();  </span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  static String name = &#x27;张三&#x27;;</span><br><span class="line">  int age=20;  </span><br><span class="line">  static void show() &#123;</span><br><span class="line">    print(name);</span><br><span class="line">  &#125;</span><br><span class="line">  void printInfo()&#123;  /*非静态方法可以访问静态成员以及非静态成员*/</span><br><span class="line">      // print(name);  //访问静态属性</span><br><span class="line">      // print(this.age);  //访问非静态属性</span><br><span class="line">      show();   //调用静态方法</span><br><span class="line">  &#125;</span><br><span class="line">  static void printUserInfo()&#123;//静态方法</span><br><span class="line">        print(name);   //静态属性</span><br><span class="line">        show();        //静态方法</span><br><span class="line"></span><br><span class="line">        //print(this.age);     //静态方法没法访问非静态的属性</span><br><span class="line">        // this.printInfo();   //静态方法没法访问非静态的方法</span><br><span class="line">        // printInfo();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对象操作符："><a href="#对象操作符：" class="headerlink" title="对象操作符："></a>对象操作符：</h6><p>/*<br>Dart中的对象操作符:</p><pre><code>?     条件运算符 （了解）   https://dart.dev/tools/diagnostic-messages#invalid_null_aware_operator        as    类型转换is    类型判断..    级联操作 （连缀）  (记住)</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age;</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">？用法</span><br><span class="line">main() &#123;</span><br><span class="line">  // Person p;</span><br><span class="line">  // p?.printInfo();   //已被最新的dart废弃 了解</span><br><span class="line"></span><br><span class="line">  //  Person p=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  //  p?.printInfo();   //已被最新的dart废弃 了解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">is用法</span><br><span class="line">  // Person p=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  // if(p is Person)&#123;</span><br><span class="line">  //     p.name=&quot;李四&quot;;</span><br><span class="line">  // &#125;</span><br><span class="line">  // p.printInfo();</span><br><span class="line">  // print(p is Object);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">as用法</span><br><span class="line">  // var p1;</span><br><span class="line"></span><br><span class="line">  // p1=&#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">  // p1=new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  // // p1.printInfo();</span><br><span class="line">  // (p1 as Person).printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">级联操作</span><br><span class="line">  //  Person p1=new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  //  p1.printInfo();</span><br><span class="line"></span><br><span class="line">  //  p1.name=&#x27;张三222&#x27;;</span><br><span class="line">  //  p1.age=40;</span><br><span class="line">  //  p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Person p1 = new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line">  p1.printInfo();</span><br><span class="line">  p1</span><br><span class="line">    ..name = &quot;李四&quot;</span><br><span class="line">    ..age = 30</span><br><span class="line">    ..printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">面向对象的三大特性：封装 、继承、多态</span><br><span class="line"></span><br><span class="line">Dart中的类的继承：  </span><br><span class="line">    1、子类使用extends关键词来继承父类</span><br><span class="line">    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数</span><br><span class="line">    3、子类能复写父类的方法 getter和setter</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为父类构造函数无法继承</span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  // Person p=new Person(&#x27;李四&#x27;,20);</span><br><span class="line">  // p.printInfo();</span><br><span class="line"></span><br><span class="line">  // Person p1=new Person(&#x27;张三&#x27;,20);</span><br><span class="line">  // p1.printInfo();</span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;张三&#x27;, 12);</span><br><span class="line">  w.printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">面向对象的三大特性：封装 、继承、多态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dart中的类的继承：  </span><br><span class="line">    1、子类使用extends关键词来继承父类</span><br><span class="line">    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数</span><br><span class="line">    3、子类能复写父类的方法 getter和setter</span><br><span class="line"></span><br><span class="line">   注意:最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">在子类中扩展属性和方法</span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  late String sex;</span><br><span class="line">  Web(String name, num age,String sex) : super(name, age)&#123;</span><br><span class="line">    this.sex=sex;</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">   print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;--$&#123;this.sex&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  // Person p=new Person(&#x27;李四&#x27;,20);</span><br><span class="line">  // p.printInfo();</span><br><span class="line"></span><br><span class="line">  // Person p1=new Person(&#x27;张三&#x27;,20);</span><br><span class="line">  // p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;张三&#x27;, 12,&quot;男&quot;);</span><br><span class="line"></span><br><span class="line">  w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给匿名的构造函数传参</span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age;</span><br><span class="line">  //给匿名的构造函数传参</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  Person.xxx(this.name, this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person &#123;</span><br><span class="line">  late String sex;</span><br><span class="line">  Web(String name, num age, String sex) : super.xxx(name, age) &#123;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;--$&#123;this.sex&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中重写父类的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">  work()&#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;在工作...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age);</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">    super.work();  //自类调用父类的方法</span><br><span class="line">  &#125;</span><br><span class="line">  //覆写父类的方法</span><br><span class="line">  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override </span><br><span class="line">  void printInfo()&#123;</span><br><span class="line">     print(&quot;姓名：$&#123;this.name&#125;---年龄：$&#123;this.age&#125;&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;李四&#x27;,20);</span><br><span class="line"></span><br><span class="line">  // w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.run();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类中调用父类的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">  work()&#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;在工作...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age);</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">    super.work();  //自类调用父类的方法</span><br><span class="line">  &#125;</span><br><span class="line">  //覆写父类的方法</span><br><span class="line">  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override </span><br><span class="line">  void printInfo()&#123;</span><br><span class="line">     print(&quot;姓名：$&#123;this.name&#125;---年龄：$&#123;this.age&#125;&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h6><p>/*<br>Dart中抽象类: Dart抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。</p><p>  1、抽象类通过abstract 关键字来定义</p><p>  2、Dart中的抽象方法不能用abstract声明，Dart中没有方法体的方法我们称为抽象方法。</p><p>  3、如果子类继承抽象类必须得实现里面的抽象方法</p><p>  4、如果把抽象类当做接口实现的话必须得实现抽象类里面定义的所有属性和方法。</p><p>  5、抽象类不能被实例化，只有继承它的子类可以</p><p>extends抽象类 和 implements的区别：</p><p>  1、如果要复用抽象类里面的方法，并且要用抽象方法约束自类的话我们就用extends继承抽象类</p><p>  2、如果只是把抽象类当做标准的话我们就用implements实现抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">案例：定义一个Animal 类要求它的子类必须包含eat方法</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">  eat();   //抽象方法</span><br><span class="line">  run();  //抽象方法  </span><br><span class="line">  printInfo()&#123;  //非抽象方法</span><br><span class="line">    print(&#x27;我是一个抽象类里面的普通方法&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">     print(&#x27;小狗在吃骨头&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    // TODO: implement run</span><br><span class="line">    print(&#x27;小狗在跑&#x27;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">    // TODO: implement eat</span><br><span class="line">    print(&#x27;小猫在吃老鼠&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    // TODO: implement run</span><br><span class="line">    print(&#x27;小猫在跑&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">  Dog d=new Dog();</span><br><span class="line">  d.eat();</span><br><span class="line">  d.printInfo();</span><br><span class="line"></span><br><span class="line">   Cat c=new Cat();</span><br><span class="line">  c.eat();</span><br><span class="line">  c.printInfo();</span><br><span class="line"></span><br><span class="line">  // Animal a=new Animal();   //抽象类没法直接被实例化</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Datr中的多态：</span><br><span class="line">    允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。</span><br><span class="line"></span><br><span class="line">    子类的实例赋值给父类的引用。</span><br><span class="line">    </span><br><span class="line">    多态就是父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">  eat();   //抽象方法 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">     print(&#x27;小狗在吃骨头&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;   </span><br><span class="line">    print(&#x27;小猫在吃老鼠&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">  // Dog d=new Dog();</span><br><span class="line">  // d.eat();</span><br><span class="line">  // d.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Cat c=new Cat();</span><br><span class="line">  // c.eat();</span><br><span class="line"></span><br><span class="line">  Animal d=new Dog();</span><br><span class="line"></span><br><span class="line">  d.eat();</span><br><span class="line">  Animal c=new Cat();</span><br><span class="line"></span><br><span class="line">  c.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="接口：进行文件分离"><a href="#接口：进行文件分离" class="headerlink" title="接口：进行文件分离"></a>接口：进行文件分离</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">和Java一样，dart也有接口，但是和Java还是有区别的。</span><br><span class="line"></span><br><span class="line">  首先，dart的接口没有interface关键字定义接口，而是普通类或抽象类都可以作为接口被实现。</span><br><span class="line"></span><br><span class="line">  同样使用implements关键字进行实现。</span><br><span class="line"></span><br><span class="line">  但是dart的接口有点奇怪，如果实现的类是普通类，会将普通类和抽象中的属性的方法全部需要覆写一遍。</span><br><span class="line">  </span><br><span class="line">  而因为抽象类可以定义抽象方法，普通类不可以，所以一般如果要实现像Java接口那样的方式，一般会使用抽象类。</span><br><span class="line"></span><br><span class="line">  建议使用抽象类定义接口。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">定义一个DB库 支持 mysql  mssql  mongodb</span><br><span class="line"></span><br><span class="line">mysql  mssql  mongodb三个类里面都有同样的方法</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Db&#123;   //当做接口   接口：就是约定 、规范</span><br><span class="line">    late String uri;      //数据库的链接地址</span><br><span class="line">    add(String data);</span><br><span class="line">    save();</span><br><span class="line">    delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mysql implements Db&#123;</span><br><span class="line">  </span><br><span class="line">  @override</span><br><span class="line">  String uri;</span><br><span class="line"></span><br><span class="line">  Mysql(this.uri);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  add(data) &#123;</span><br><span class="line">    // TODO: implement add</span><br><span class="line">    print(&#x27;这是mysql的add方法&#x27;+data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  delete() &#123;</span><br><span class="line">    // TODO: implement delete</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  save() &#123;</span><br><span class="line">    // TODO: implement save</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove()&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MsSql implements Db&#123;</span><br><span class="line">  @override</span><br><span class="line">  late String uri;</span><br><span class="line">  @override</span><br><span class="line">  add(String data) &#123;</span><br><span class="line">    print(&#x27;这是mssql的add方法&#x27;+data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  delete() &#123;</span><br><span class="line">    // TODO: implement delete</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  save() &#123;</span><br><span class="line">    // TODO: implement save</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">  Mysql mysql=new Mysql(&#x27;xxxxxx&#x27;);</span><br><span class="line"></span><br><span class="line">  mysql.add(&#x27;1243214&#x27;);</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="Dart中一个类实现多个接口"><a href="#Dart中一个类实现多个接口" class="headerlink" title="Dart中一个类实现多个接口"></a>Dart中一个类实现多个接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Dart中一个类实现多个接口：</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">abstract class A&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  printA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class B&#123;</span><br><span class="line">  printB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implements A,B&#123;  </span><br><span class="line">  @override</span><br><span class="line">  late String name;  </span><br><span class="line">  @override</span><br><span class="line">  printA() &#123;</span><br><span class="line">    print(&#x27;printA&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  printB() &#123;</span><br><span class="line">    // TODO: implement printB</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  C c=new C();</span><br><span class="line">  c.printA();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mixins："><a href="#mixins：" class="headerlink" title="mixins："></a>mixins：</h6><p>/*<br>mixins的中文意思是混入，就是在类中混入其他功能。</p><p>在Dart中可以使用mixins实现类似多继承的功能</p><p>因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.x中使用mixins的条件：</p><p>  1、作为mixins的类只能继承自Object，不能继承其他类<br>  2、作为mixins的类不能有构造函数<br>  3、一个类可以mixins多个mixins类<br>  4、mixins绝不是继承，也不是接口，而是一种全新的特性<br>*/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  String info=&quot;this is A&quot;;</span><br><span class="line">  void printA()&#123;</span><br><span class="line">    print(&quot;A&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  void printB()&#123;</span><br><span class="line">    print(&quot;B&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C with A,B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  var c=new C();  </span><br><span class="line">  c.printA();</span><br><span class="line">  c.printB();</span><br><span class="line">  print(c.info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">mixins的实例类型是什么？</span><br><span class="line"></span><br><span class="line">很简单，mixins的类型就是其超类的子类型。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  String info=&quot;this is A&quot;;</span><br><span class="line">  void printA()&#123;</span><br><span class="line">    print(&quot;A&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  void printB()&#123;</span><br><span class="line">    print(&quot;B&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C with A,B&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;  </span><br><span class="line">   var c=new C();  </span><br><span class="line">   </span><br><span class="line">  print(c is C);    //true</span><br><span class="line">  print(c is A);    //true</span><br><span class="line">  print(c is B);   //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // var a=new A();</span><br><span class="line"></span><br><span class="line">  // print(a is Object);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h6><p>通俗理解：泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持(类型校验)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//只能返回string类型的数据</span><br><span class="line"></span><br><span class="line">  // String getData(String value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//同时支持返回 string类型 和int类型  （代码冗余）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String getData1(String value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // int getData2(int value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//同时返回 string类型 和number类型       不指定类型可以解决这个问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // getData(value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//不指定类型放弃了类型检查。我们现在想实现的是传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型</span><br><span class="line"> 对传入参数和返回参数校验</span><br><span class="line">  // T getData&lt;T&gt;(T value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line">只对传入参数校验</span><br><span class="line">  getData&lt;T&gt;(T value)&#123;</span><br><span class="line">      return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">    // print(getData(21));</span><br><span class="line"></span><br><span class="line">    // print(getData(&#x27;xxx&#x27;));</span><br><span class="line"></span><br><span class="line">    // getData&lt;String&gt;(&#x27;你好&#x27;);</span><br><span class="line"></span><br><span class="line">    print(getData&lt;int&gt;(12));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//集合List 泛型类的用法</span><br><span class="line"></span><br><span class="line">//案例：把下面类转换成泛型类，要求MyList里面可以增加int类型的数据，也可以增加String类型的数据。但是每次调用增加的类型要统一</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">class MyList &#123;</span><br><span class="line">  List list = &lt;int&gt;[];</span><br><span class="line">  void add(int value) &#123;</span><br><span class="line">    this.list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">  List getList() &#123;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyList l = new MyList();</span><br><span class="line">l.add(1);</span><br><span class="line">l.add(12);</span><br><span class="line">l.add(5);</span><br><span class="line">print(l.getList());</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class MyList&lt;T&gt; &#123;</span><br><span class="line">  List list = &lt;T&gt;[];</span><br><span class="line">  void add(T value) &#123;</span><br><span class="line">    this.list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List getList() &#123;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  // MyList l1=new MyList();</span><br><span class="line">  // l1.add(&quot;张三&quot;);</span><br><span class="line">  // l1.add(12);</span><br><span class="line">  // l1.add(true);</span><br><span class="line">  // print(l1.getList());</span><br><span class="line"></span><br><span class="line">  // MyList l2 = new MyList&lt;String&gt;();</span><br><span class="line">  // l2.add(&quot;张三1&quot;);</span><br><span class="line">  // // l2.add(11);  //错误的写法</span><br><span class="line">  // print(l2.getList());</span><br><span class="line"></span><br><span class="line">  MyList l3 = new MyList&lt;int&gt;();</span><br><span class="line">  l3.add(11);</span><br><span class="line">  l3.add(12);</span><br><span class="line">  l3.add(&quot;aaaa&quot;);</span><br><span class="line">  print(l3.getList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // List list = List.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  // List list = new List.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三1&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  // List list = new List&lt;String&gt;.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三1&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  //  List list2 = new List&lt;int&gt;.filled(2, 0);</span><br><span class="line">  //   list2[0] = 12;</span><br><span class="line">  //   list2[1] = 13;</span><br><span class="line">  //   print(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型接口："><a href="#泛型接口：" class="headerlink" title="泛型接口："></a>泛型接口：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Dart中的泛型接口:</span><br><span class="line"></span><br><span class="line">    实现数据缓存的功能：有文件缓存、和内存缓存。内存缓存和文件缓存按照接口约束实现。</span><br><span class="line"></span><br><span class="line">    1、定义一个泛型接口 约束实现它的子类必须有getByKey(key) 和 setByKey(key,value)</span><br><span class="line"></span><br><span class="line">    2、要求setByKey的时候的value的类型和实例化子类的时候指定的类型一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // abstract class ObjectCache &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, Object value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // abstract class StringCache &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, String value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // abstract class Cache&lt;T&gt; &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, T value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Cache&lt;T&gt;&#123;</span><br><span class="line">  getByKey(String key);</span><br><span class="line">  void setByKey(String key, T value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlieCache&lt;T&gt; implements Cache&lt;T&gt;&#123;</span><br><span class="line">  @override</span><br><span class="line">  getByKey(String key) &#123;    </span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void setByKey(String key, T value) &#123;</span><br><span class="line">   print(&quot;我是文件缓存 把key=$&#123;key&#125;  value=$&#123;value&#125;的数据写入到了文件中&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MemoryCache&lt;T&gt; implements Cache&lt;T&gt;&#123;</span><br><span class="line">  @override</span><br><span class="line">  getByKey(String key) &#123;   </span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void setByKey(String key, T value) &#123;</span><br><span class="line">       print(&quot;我是内存缓存 把key=$&#123;key&#125;  value=$&#123;value&#125; -写入到了内存中&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // MemoryCache m=new MemoryCache&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    //  m.setByKey(&#x27;index&#x27;, &#x27;首页数据&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     MemoryCache m=new MemoryCache&lt;Map&gt;();</span><br><span class="line"></span><br><span class="line">     m.setByKey(&#x27;index&#x27;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:20&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Dart中的库"><a href="#Dart中的库" class="headerlink" title="Dart中的库"></a>Dart中的库</h6><p>/*</p><p>前面介绍Dart基础知识的时候基本上都是在一个文件里面编写Dart代码的，但实际开发中不可能这么写，模块化很重要，所以这就需要使用到库的概念。</p><p>在Dart中，库的使用时通过import关键字引入的。</p><p>library指令可以创建一个库，每个Dart文件都是一个库，即使没有使用library指令来指定。</p><p>Dart中的库主要有三种：</p><pre><code>1、我们自定义的库           import &#39;lib/xxx.dart&#39;;2、系统内置库             import &#39;dart:math&#39;;          import &#39;dart:io&#39;;       import &#39;dart:convert&#39;;3、Pub包管理系统中的库      https://pub.dev/packages    https://pub.flutter-io.cn/packages    https://pub.dartlang.org/flutter/    1、需要在自己想项目根目录新建一个pubspec.yaml    2、在pubspec.yaml文件 然后配置名称 、描述、依赖等信息    3、然后运行 pub get 获取包下载到本地      4、项目中引入库 import &#39;package:http/http.dart&#39; as http; 看文档使用</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导入自己的本地库：</span><br><span class="line">import &#x27;lib/Animal.dart&#x27;;</span><br><span class="line">main()&#123;</span><br><span class="line">  var a=new Animal(&#x27;小黑狗&#x27;, 20);</span><br><span class="line">  print(a.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">导入系统库 </span><br><span class="line">// import &#x27;dart:io&#x27;;</span><br><span class="line">import &quot;dart:math&quot;;</span><br><span class="line">main()&#123;</span><br><span class="line"> </span><br><span class="line">    print(min(12,23));</span><br><span class="line"></span><br><span class="line">    print(max(12,25));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &#x27;dart:io&#x27;;</span><br><span class="line">import &#x27;dart:convert&#x27;;</span><br><span class="line">void main() async&#123;</span><br><span class="line">  var result = await getDataFromZhihuAPI();</span><br><span class="line">  print(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//api接口： http://news-at.zhihu.com/api/3/stories/latest</span><br><span class="line">getDataFromZhihuAPI() async&#123;  //async异步方法</span><br><span class="line">  //1、创建HttpClient对象</span><br><span class="line">  var httpClient = new HttpClient();  </span><br><span class="line">  //2、创建Uri对象</span><br><span class="line">  var uri = new Uri.http(&#x27;news-at.zhihu.com&#x27;,&#x27;/api/3/stories/latest&#x27;);</span><br><span class="line">  //3、发起请求，等待请求</span><br><span class="line">  var request = await httpClient.getUrl(uri);</span><br><span class="line">  //4、关闭请求，等待响应</span><br><span class="line">  var response = await request.close();</span><br><span class="line">  //5、解码响应的内容</span><br><span class="line">  return await response.transform(utf8.decoder).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">async和await</span><br><span class="line">  这两个关键字的使用只需要记住两点：</span><br><span class="line">    只有async方法才能使用await关键字调用方法</span><br><span class="line">    如果调用别的async方法必须使用await关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async是让方法变成异步。</span><br><span class="line">await是等待异步方法执行完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void main() async&#123;</span><br><span class="line">  var result = await testAsync();</span><br><span class="line">  print(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步方法</span><br><span class="line">testAsync() async&#123;</span><br><span class="line">  return &#x27;Hello async&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">导入pub包管理系统中的库</span><br><span class="line">/*</span><br><span class="line">pub包管理系统:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、从下面网址找到要用的库</span><br><span class="line">        https://pub.dev/packages</span><br><span class="line">        https://pub.flutter-io.cn/packages</span><br><span class="line">        https://pub.dartlang.org/flutter/</span><br><span class="line"></span><br><span class="line">2、创建一个pubspec.yaml文件，内容如下</span><br><span class="line"></span><br><span class="line">    name: xxx</span><br><span class="line">    description: A new flutter module project.</span><br><span class="line">    dependencies:  </span><br><span class="line">        http: ^0.12.0+2</span><br><span class="line">        date_format: ^1.0.6</span><br><span class="line"></span><br><span class="line">3、配置dependencies</span><br><span class="line"></span><br><span class="line">4、运行pub get 获取远程库</span><br><span class="line"></span><br><span class="line">5、看文档引入库使用</span><br><span class="line">*/</span><br><span class="line">import &#x27;dart:convert&#x27; as convert;</span><br><span class="line">import &#x27;package:http/http.dart&#x27; as http;</span><br><span class="line">import &#x27;package:date_format/date_format.dart&#x27;;</span><br><span class="line"></span><br><span class="line">main() async &#123;</span><br><span class="line">  // var url = &quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&quot;;</span><br><span class="line"></span><br><span class="line">  //   // Await the http get response, then decode the json-formatted responce.</span><br><span class="line">  //   var response = await http.get(url);</span><br><span class="line">  //   if (response.statusCode == 200) &#123;</span><br><span class="line">  //     var jsonResponse = convert.jsonDecode(response.body);</span><br><span class="line">     </span><br><span class="line">  //     print(jsonResponse);</span><br><span class="line">  //   &#125; else &#123;</span><br><span class="line">  //     print(&quot;Request failed with status: $&#123;response.statusCode&#125;.&quot;);</span><br><span class="line">  //   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    print(formatDate(DateTime(1989, 2, 21), [yyyy, &#x27;*&#x27;, mm, &#x27;*&#x27;, dd]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1、冲突解决</span><br><span class="line">当引入两个库中有相同名称标识符的时候，如果是java通常我们通过写上完整的包名路径来指定使用的具体标识符，甚至不用import都可以，但是Dart里面是必须import的。当冲突的时候，可以使用as关键字来指定库的前缀。如下例子所示：</span><br><span class="line"></span><br><span class="line">    import &#x27;package:lib1/lib1.dart&#x27;;</span><br><span class="line">    import &#x27;package:lib2/lib2.dart&#x27; as lib2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Element element1 = new Element();           // Uses Element from lib1.</span><br><span class="line">    lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;lib/Person1.dart&#x27;;</span><br><span class="line">import &#x27;lib/Person2.dart&#x27; as lib;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  Person p1=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  lib.Person p2=new lib.Person(&#x27;李四&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  p2.printInfo();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">部分导入</span><br><span class="line">  如果只需要导入库的一部分，有两种模式：</span><br><span class="line"></span><br><span class="line">     模式一：只导入需要的部分，使用show关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">      import &#x27;package:lib1/lib1.dart&#x27; show foo;</span><br><span class="line"></span><br><span class="line">     模式二：隐藏不需要的部分，使用hide关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">      import &#x27;package:lib2/lib2.dart&#x27; hide foo;      </span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// import &#x27;lib/myMath.dart&#x27; show getAge;</span><br><span class="line"></span><br><span class="line"> import &#x27;lib/myMath.dart&#x27; hide getName;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">//  getName();</span><br><span class="line">  getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">延迟加载</span><br><span class="line"></span><br><span class="line">    也称为懒加载，可以在需要的时候再进行加载。</span><br><span class="line">    懒加载的最大好处是可以减少APP的启动时间。</span><br><span class="line"></span><br><span class="line">    懒加载使用deferred as关键字来指定，如下例子所示：</span><br><span class="line"></span><br><span class="line">    import &#x27;package:deferred/hello.dart&#x27; deferred as hello;</span><br><span class="line"></span><br><span class="line">    当需要使用的时候，需要使用loadLibrary()方法来加载：</span><br><span class="line"></span><br><span class="line">    greet() async &#123;</span><br><span class="line">      await hello.loadLibrary();</span><br><span class="line">      hello.printGreeting();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Null安全"><a href="#Null安全" class="headerlink" title="Null安全"></a>Null安全</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">  null safety 可以帮助开发者避免一些日常开发中很难被发现的错误，并且额外的好处是可以改善性能。</span><br><span class="line"></span><br><span class="line">  Flutter2.2.0（2021年5月19日发布） 之后的版本都要求使用null safety。</span><br><span class="line"></span><br><span class="line">  ? 可空类型</span><br><span class="line"></span><br><span class="line">  ! 类型断言</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">String? getData(apiUrl)&#123;</span><br><span class="line">  if(apiUrl!=null)&#123;</span><br><span class="line">    return &quot;this is server data&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// void printLength(String? str)&#123;</span><br><span class="line">//   // print(str!.length);</span><br><span class="line">//   if (str!=null)&#123;</span><br><span class="line">//     print(str.length);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">void printLength(String? str)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    print(str!.length); </span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">     print(&quot;str is null&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line"></span><br><span class="line">//1、 ? 可空类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int a=123;</span><br><span class="line">  // print(a);</span><br><span class="line">  </span><br><span class="line">  // String username=&quot;张三&quot;;</span><br><span class="line">  // print(username);</span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt; l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // print(l1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int a=123;  //非空的int类型</span><br><span class="line">  // a=null;  //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;int&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String username=&quot;张三&quot;;  //非空的String类型</span><br><span class="line">  // username=null;   //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;String&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String? username=&quot;张三&quot;;   // String?  表示username是一个可空类型</span><br><span class="line">  // username=null;</span><br><span class="line">  // print(username);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int? a=123;  //  int? 表示a是一个可空类型</span><br><span class="line">  // a=null; </span><br><span class="line">  // print(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt; l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // l1=null;  //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;List&lt;String&gt;&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt;? l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // l1=null;  </span><br><span class="line">  // print(l1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //调用方法</span><br><span class="line">  // print(getData(&quot;http://www.itying.com&quot;));</span><br><span class="line"></span><br><span class="line">  // print(getData(null));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ! 类型断言</span><br><span class="line"></span><br><span class="line">  // String? str=&quot;this is str&quot;;</span><br><span class="line"></span><br><span class="line">  // str=null;</span><br><span class="line"></span><br><span class="line">  // print(str!.length);  </span><br><span class="line">  </span><br><span class="line">   //类型断言: 如果str不等于null 会打印str的长度，如果等于null会抛出异常</span><br><span class="line"></span><br><span class="line">  //  printLength(&quot;str&quot;);</span><br><span class="line">  </span><br><span class="line">   printLength(null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">late 关键字主要用于延迟初始化。</span><br><span class="line">Dart2.13之后</span><br><span class="line">*/</span><br><span class="line">class Person &#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  void setName(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">  Person p = new Person();</span><br><span class="line">  p.setName(&quot;张三&quot;, 20);</span><br><span class="line">  print(p.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">String printUserInfo(String username, &#123;int age=10, String sex=&quot;男&quot;&#125;) &#123;//行参    </span><br><span class="line">  return &quot;姓名:$username---性别:$sex--年龄:$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line">不指定默认值的时候需要加个required，必须要传入的参数</span><br><span class="line">String printInfo(String username, &#123;required int age, required String sex&#125;) &#123;//行参    </span><br><span class="line">  return &quot;姓名:$username---性别:$sex--年龄:$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">    print(printUserInfo(&#x27;张三&#x27;));</span><br><span class="line"></span><br><span class="line">    print(printUserInfo(&#x27;张三&#x27;,age: 20,sex: &quot;女&quot;));</span><br><span class="line">    </span><br><span class="line">    //age 和 sex必须传入</span><br><span class="line">    print(printInfo(&#x27;张三&#x27;,age: 22,sex: &quot;女&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//表示 name 和age 是必须传入的命名参数</span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  Person(&#123;required this.name,required this.age&#125;);  //表示 name 和age 必须传入</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">   Person p=new Person(</span><br><span class="line">     name: &quot;张三&quot;,</span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// name 可以传入也可以不传入   age必须传入</span><br><span class="line">class Person &#123;</span><br><span class="line">  String? name;   //可空属性</span><br><span class="line">  int age;</span><br><span class="line">  Person(&#123;this.name,required this.age&#125;);  //表示 name 和age 必须传入</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">   Person p=new Person(</span><br><span class="line">     name: &quot;张三&quot;,</span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p.getName());  //张三---20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Person p1=new Person(    </span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p1.getName());  //null---20</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTP发展</title>
      <link href="2021/07/12/%E7%9E%8E%E8%81%8AHTTP%E5%8F%91%E5%B1%95/"/>
      <url>2021/07/12/%E7%9E%8E%E8%81%8AHTTP%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-0-9到HTTP-2"><a href="#HTTP-0-9到HTTP-2" class="headerlink" title="HTTP/0.9到HTTP/2"></a>HTTP/0.9到HTTP/2</h1><p><strong>HTTP（</strong>HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。自 Tim Berners-Lee 博士和他的团队在1989-1991年间创造出它以来，HTTP已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和3D效果的现代复杂互联网协议。</p><h2 id="万维网的出现："><a href="#万维网的出现：" class="headerlink" title="万维网的出现："></a>万维网的出现：</h2><p>1989年， 当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 <em>Mesh</em>，在随后的1990年项目实施期间被更名为万维网（<em>World Wide Web）。</em>它在现有的TCP和IP协议基础之上建立，由四个部分组成：</p><ul><li>一个用来表示超文本文档的文本格式，*<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">超文本标记语言</a>*（HTML）。</li><li>一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。</li><li>一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 <em>WorldWideWeb。</em></li><li>一个服务器用于提供可访问的文档，即 <em>httpd</em> 的前身。</li></ul><p>这四个部分完成于1990年底，且第一批服务器已经在1991年初在CERN以外的地方运行了。 1991年8月16日，Tim Berners-Lee 在公开的超文本新闻组上发表的文章被视为是万维网公共项目的开始。</p><p>HTTP在应用的早期阶段非常简单，后来被称为HTTP/0.9，有时也叫做单行（one-line）协议。</p><h1 id="HTTP-0-9-单行协议"><a href="#HTTP-0-9-单行协议" class="headerlink" title="HTTP/0.9-单行协议"></a>HTTP/0.9-单行协议</h1><p>HTTP是基于TCP/IP的应用层协议，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p><strong>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET：</strong></p><p>GET /index.html</p><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p><p><strong>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式：</strong></p><html> <body>Hello World</body></html><p>服务器发送完毕，就关闭TCP连接</p><h1 id="HTTP协议-1-0"><a href="#HTTP协议-1-0" class="headerlink" title="HTTP协议/1.0"></a>HTTP协议/1.0</h1><p>1996年5月，HTTP/1.0 版本发布，内容大大增加（详见 <a href="https://tools.ietf.org/html/rfc1945">RFC1945</a>）。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p><strong>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段：</strong></p><p>Connection: keep-alive<br>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。</p><p><strong>服务器同样回应这个字段：</strong></p><p>Connection: keep-alive一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h1 id="HTTP协议-1-1版本"><a href="#HTTP协议-1-1版本" class="headerlink" title="HTTP协议/1.1版本"></a>HTTP协议/1.1版本</h1><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。</p><p><strong>持久连接：</strong>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。</p><p>不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接：</p><p>Connection: close</p><p><strong>管到机制</strong>：1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><p><strong>Content-Length</strong>：一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度：</p><p>Content-Length: 3495<br>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><p><strong>分块传输编码</strong>：使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用Content-Length字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">“分块传输编码”</a>（chunked transfer encoding）。</p><p>只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成：</p><p>Transfer-Encoding: chunked</p><p><strong>其他功能</strong>：1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名：</p><p>Host: example.com<br>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><p><strong>缺点</strong>：虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">“队头堵塞”</a>（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h1 id="SPDY协议"><a href="#SPDY协议" class="headerlink" title="SPDY协议"></a>SPDY协议</h1><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><p>2015年，<a href="https://http2.github.io/http2-spec/">HTTP/2</a> 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3</p><p><strong>二进制协议</strong>：HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧</p><p><strong>多工</strong>：HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><p><strong>数据流</strong>：因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><p><strong>头信息压缩</strong>：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><p><strong>服务器推送</strong>：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊TCP/UDP</title>
      <link href="2021/07/12/%E7%9E%8E%E8%81%8ATCP-UDP/"/>
      <url>2021/07/12/%E7%9E%8E%E8%81%8ATCP-UDP/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-12</title>
      <link href="2021/07/12/7-12/"/>
      <url>2021/07/12/7-12/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer链表</title>
      <link href="2021/07/11/%E5%89%91%E6%8C%87offer%E9%93%BE%E8%A1%A8/"/>
      <url>2021/07/11/%E5%89%91%E6%8C%87offer%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer链表题目一"><a href="#剑指offer链表题目一" class="headerlink" title="剑指offer链表题目一"></a>剑指offer链表题目一</h1><h6 id="题目：offer06：-从尾到头打印链表"><a href="#题目：offer06：-从尾到头打印链表" class="headerlink" title="题目：offer06： 从尾到头打印链表"></a>题目：offer06： 从尾到头打印链表</h6><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p><p>解析：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-11</title>
      <link href="2021/07/11/7-11/"/>
      <url>2021/07/11/7-11/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-10</title>
      <link href="2021/07/11/7-10/"/>
      <url>2021/07/11/7-10/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-9</title>
      <link href="2021/07/11/7-9/"/>
      <url>2021/07/11/7-9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="2021/07/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>2021/07/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>滑动窗口是一种解决问题的思路和方法，通常用来解决一些连续问题。比如：求解“连续子串XXX”，连续子数组“XXXX”。</p><p>从类型上说：</p><p>​        1.固定窗口大小</p><p>​        2.窗口大小不固定，求解最大的满足条件的窗口</p><p>​        3.窗口大小不固定，求解最小的满足条件的窗口</p><p>对于固定窗口大小，只需要固定初始化左右指针l和r，分别表示窗口的左右顶点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、l 初始化为 0</span><br><span class="line">二、初始化 r，使得 r - l + 1 等于窗口大小</span><br><span class="line">三、同时移动 l 和 r</span><br><span class="line">四、判断窗口内的连续元素是否满足题目限定的条件</span><br><span class="line">4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解</span><br><span class="line">4.2 如果不满足，则继续。</span><br></pre></td></tr></table></figure><p>可变窗口大小，同样固定初始化左右指针l和r，分别表示窗口的左右顶点，需要保证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、l 和 r 都初始化为 0</span><br><span class="line">二、r 指针移动一步</span><br><span class="line">三、判断窗口内的连续元素是否满足题目限定的条件</span><br><span class="line">3.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 l 指针缩小窗口大小。循环执行 3.1</span><br><span class="line">3.2 如果不满足，则继续。</span><br><span class="line">形象地来看的话，就是 r 指针不停向右移动，l 指针仅仅在窗口满足条件之后才会移动，起到窗口收缩的效果。</span><br></pre></td></tr></table></figure><h1 id="练习题目1：leetcode209，长度最小的子数组"><a href="#练习题目1：leetcode209，长度最小的子数组" class="headerlink" title="练习题目1：leetcode209，长度最小的子数组"></a>练习题目1：leetcode209，长度最小的子数组</h1><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p><p>输入：target = 4, nums = [1,4,4]<br>输出：1<br>示例 3：</p><p>输入：target = 11, nums = [1,1,1,1,1,1,1,1]<br>输出：0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int minSubArrayLen(int[] nums, int target)&#123;</span><br><span class="line">       int l = 0, r = 0;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       int ans = Integer.MAX_VALUE;</span><br><span class="line">       //窗口结束条件</span><br><span class="line">       while (r &lt; nums.length)&#123;</span><br><span class="line">           //更新右边界并更新窗口状态</span><br><span class="line">           sum =sum +nums[r];</span><br><span class="line">           //窗口达到什么状态需要收缩</span><br><span class="line">           while (sum &gt;= target)&#123;</span><br><span class="line">               //缩小左边界并更新窗口状态</span><br><span class="line">               ans = Math.min(ans, r - l +1);</span><br><span class="line">               sum = sum - nums[l];</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           r++;</span><br><span class="line">       &#125;</span><br><span class="line">      return ans == Integer.MAX_VALUE ? 0 : ans;</span><br></pre></td></tr></table></figure><h1 id="题目2：leetcode-76，最小覆盖子串"><a href="#题目2：leetcode-76，最小覆盖子串" class="headerlink" title="题目2：leetcode 76，最小覆盖子串"></a>题目2：leetcode 76，最小覆盖子串</h1><p>题目：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：</p><p>输入：s = “a”, t = “a”<br>输出：”a”</p><h1 id="题目3：无重复字符的最长子串"><a href="#题目3：无重复字符的最长子串" class="headerlink" title="题目3：无重复字符的最长子串"></a>题目3：无重复字符的最长子串</h1><p>题目：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s = “”<br>输出: 0</p><p>思路：不固定窗口大小。用map存储字符和个数，当有字符个数大于1的情况说明含有重复字符，此时应该移动左边的字符直至出现的相同字符个数小于等于1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int  lengthOfLongestSubstring(String s)&#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">       for (int left = 0, right = 0; right &lt; s.length(); right++)&#123;</span><br><span class="line">           char rightChar = s.charAt(right);</span><br><span class="line">           hashMap.put(rightChar, hashMap.getOrDefault(rightChar, 0) + 1);</span><br><span class="line">           while (hashMap.get(rightChar) &gt; 1)&#123;</span><br><span class="line">               char leftChar = s.charAt(left);</span><br><span class="line">               hashMap.put(leftChar, hashMap.get(leftChar) - 1);</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ans = Math.max(ans, right - left + 1);</span><br><span class="line">       &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="题目四：找到字符串中所有字母异位词"><a href="#题目四：找到字符串中所有字母异位词" class="headerlink" title="题目四：找到字符串中所有字母异位词"></a>题目四：找到字符串中所有字母异位词</h1><p>题目：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:</p><p>输入:<br>s: “cbaebabacd” p: “abc”</p><p>输出:<br>[0, 6]</p><p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。<br> 示例 2:</p><p>输入:<br>s: “abab” p: “ab”</p><p>输出:<br>[0, 1, 2]</p><p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">比较两个map里面的内容是否相等：</span><br><span class="line">Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map2 = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">比较方法一：map1.equals(map2))</span><br><span class="line">比较方法二：</span><br><span class="line">Iterator&lt;Entry&lt;String, Integer&gt;&gt; it1 = map1.entrySet().iterator();</span><br><span class="line">while(it1.hasNext())&#123;</span><br><span class="line">Entry&lt;String, Integer&gt; entry1 = it1.next();</span><br><span class="line">Integer integer2 = tempMap.get(entry1.getKey());</span><br><span class="line">if(integer2 == null||(!integer2.equals(entry1.getValue())))&#123;</span><br><span class="line">b = false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个超出时间限制：我的想法是固定滑动窗口，先把p字符串放到map中，有什么字符和对应的个数。然后长的字符串s，用一个固定窗口在s上滑动。每个窗口中字符放到map中，比较两个map 是否相等。相等的话，每次窗口的left放到list中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findAnagrams(String s, String p)&#123;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap_P = new HashMap&lt;&gt;();</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap_S = new HashMap&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">       int revIndex = 0;</span><br><span class="line">       for (int i = 0; i &lt; p.length(); i++)&#123;</span><br><span class="line">           char charOfP = p.charAt(i);</span><br><span class="line">           hashMap_P.put(charOfP, hashMap_P.getOrDefault(charOfP, 0) + 1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for (int j = 0; j &lt;= s.length() - p.length(); j++)&#123;</span><br><span class="line">           int left = j;</span><br><span class="line">           int right = j + p.length() - 1;</span><br><span class="line">           for (int k = left; k &lt;= right; k++)&#123;</span><br><span class="line">               char charOfS = s.charAt(k);</span><br><span class="line">               hashMap_S.put(charOfS, hashMap_S.getOrDefault(charOfS, 0) + 1);</span><br><span class="line">           &#125;</span><br><span class="line">          if (hashMap_S.equals(hashMap_P))&#123;</span><br><span class="line">              list.add(left);</span><br><span class="line">          &#125;</span><br><span class="line">          hashMap_S.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>考虑怎么样优化：我上边的时间复杂度o(s.length*p.length)，要优化到怎么一次遍历就可以完成。把时间复杂度降到0（s.length）。通过常量flag来判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findAnagrams(String s, String p)&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMapOfS = new HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMapOfP = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char c:p.toCharArray()) hashMapOfP.put(c, hashMapOfP.getOrDefault(c, 0) + 1);</span><br><span class="line">        int left = 0, right = 0, flag = 0;</span><br><span class="line">        while (right &lt; s.length())&#123;</span><br><span class="line">            char c = s.charAt(right);</span><br><span class="line">            if (hashMapOfP.containsKey(c))&#123;</span><br><span class="line">                hashMapOfS.put(c, hashMapOfS.getOrDefault(c, 0) + 1);</span><br><span class="line">                if (hashMapOfS.get(c).equals(hashMapOfP.get(c)))&#123;</span><br><span class="line">                    flag++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (p.length() == right - left + 1)&#123;</span><br><span class="line">                if (flag == p.length())&#123;</span><br><span class="line">                    list.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                char c1 = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                if (hashMapOfP.containsKey(c1))&#123;</span><br><span class="line">                    if (hashMapOfS.get(c1).equals(hashMapOfP.get(c1)))&#123;</span><br><span class="line">                        flag--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hashMapOfS.put(c1, hashMapOfS.getOrDefault(c1, 0) - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为只有26个小写字母，所以可以利用26位长度的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">         List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(s.length() == 0 || p.length() == 0)</span><br><span class="line">            return ans;</span><br><span class="line">        int[] dict = new int[26];</span><br><span class="line">        for(int i = 0;i&lt;p.length();i++)&#123;</span><br><span class="line">            dict[p.charAt(i)-&#x27;a&#x27;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        int[] window = new int[26];</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = 0;</span><br><span class="line">        while(right&lt;s.length())&#123;</span><br><span class="line">            int curR = s.charAt(right)-&#x27;a&#x27;;</span><br><span class="line">            right++;</span><br><span class="line">            window[curR] += 1;</span><br><span class="line">            while(window[curR] &gt; dict[curR])&#123;</span><br><span class="line">                int curL = s.charAt(left)-&#x27;a&#x27;;</span><br><span class="line">                window[curL] -= 1;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(right - left == p.length())&#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="leetcode水果成篮904"><a href="#leetcode水果成篮904" class="headerlink" title="leetcode水果成篮904"></a>leetcode水果成篮904</h1><p>在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>你可以从你选择的任何树开始，然后重复执行以下步骤：</p><p>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。<br>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。<br>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p><p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p><p>用这个程序你能收集的水果树的最大总量是多少？ </p><p>示例 1：</p><p>输入：[1,2,1]<br>输出：3<br>解释：我们可以收集 [1,2,1]。<br>示例 2：</p><p>输入：[0,1,2,2]<br>输出：3<br>解释：我们可以收集 [1,2,2]<br>如果我们从第一棵树开始，我们将只能收集到 [0, 1]。<br>示例 3：</p><p>输入：[1,2,3,2,2]<br>输出：4<br>解释：我们可以收集 [2,3,2,2]<br>如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</p><p>解析：理解题目也就是两种类型的水果，求最多的数量。我们可以用一个map来存储类型和数量。何时left移动？当map的size大于2，也就是此时map中存在不止两种类型水果时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int totalFruit(int[] fruits)&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">       int left = 0, right = 0;</span><br><span class="line">       int ans = 0;</span><br><span class="line">       while (right &lt; fruits.length)&#123;</span><br><span class="line">           int fruit = fruits[right];</span><br><span class="line">           hashMap.put(fruit, hashMap.getOrDefault(fruit, 0) + 1);</span><br><span class="line">           while (hashMap.size() &gt; 2)&#123;</span><br><span class="line">               int leftFruit = fruits[left];</span><br><span class="line">               hashMap.put(leftFruit, hashMap.get(leftFruit) - 1);</span><br><span class="line">               if (hashMap.get(leftFruit) == 0)&#123;</span><br><span class="line">                   hashMap.remove(leftFruit);</span><br><span class="line">               &#125;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           ans = Math.max(ans, right - left + 1);</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode930-：和相同的二元子数组"><a href="#leetcode930-：和相同的二元子数组" class="headerlink" title="leetcode930,：和相同的二元子数组"></a>leetcode930,：和相同的二元子数组</h1><p>给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。</p><p>子数组 是数组的一段连续部分。</p><p>示例 1：</p><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]<br>示例 2：</p><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-8</title>
      <link href="2021/07/08/7-8/"/>
      <url>2021/07/08/7-8/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode930：和相同的二元子数组"><a href="#leetcode930：和相同的二元子数组" class="headerlink" title="leetcode930：和相同的二元子数组"></a>leetcode930：和相同的二元子数组</h1><p>题目描述：给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。</p><p>子数组 是数组的一段连续部分。</p><p>示例 1：</p><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>示例 2：</p><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p><p>解析：有点滑动窗口的味道。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart</title>
      <link href="2021/07/08/Dart/"/>
      <url>2021/07/08/Dart/</url>
      
        <content type="html"><![CDATA[<h1 id="Dart介绍"><a href="#Dart介绍" class="headerlink" title="Dart介绍"></a>Dart介绍</h1><p>Dart是由谷歌开发的计算机编程语言,它可以被用于web、服务器、移动应用 和物联网等领域的开发。Dart诞生于2011年，号称要取代JavaScript。但是过去的几年中一直不温不火。直到Flutter的出现现在被人们重新重视。要学Flutter的话我们必须首先得会Dart。</p><h1 id="Dart入口方法、变量、常量、命名规则"><a href="#Dart入口方法、变量、常量、命名规则" class="headerlink" title="Dart入口方法、变量、常量、命名规则"></a>Dart入口方法、变量、常量、命名规则</h1><h6 id="Dart变量："><a href="#Dart变量：" class="headerlink" title="Dart变量："></a>Dart变量：</h6><p>dart是一个强大的脚本类语言，可以不预先定义变量类型 ，自动会类型推倒。  dart中定义变量可以通过var关键字可以通过类型来申明变量，也可以直接通过变量类型进行定义。</p><p>Dart有类型校验：就是定义的字符串不能赋其他类型的值。</p><p>注意： var 后就不要写类型 ，  写了类型 不要var   两者都写   var  a int  = 5;  报错</p><h6 id="Dart常量：-final-和-const修饰符"><a href="#Dart常量：-final-和-const修饰符" class="headerlink" title="Dart常量： final 和 const修饰符"></a>Dart常量： final 和 const修饰符</h6><p>const值不变 一开始就得赋值， </p><p>final 可以开始不赋值 只能赋一次 ;</p><p>而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final a=new DateTime.now();</span><br><span class="line">print(a);   //2019-05-10 15:59:02.966122</span><br><span class="line"></span><br><span class="line">//const a=new DateTime.now();   //报错了</span><br></pre></td></tr></table></figure><p>永远不改量的量，请使用final或const修饰它，而不是使用var或其他变量类型。</p><h6 id="入口方法："><a href="#入口方法：" class="headerlink" title="入口方法："></a>入口方法：</h6><p>第一种定义方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main（）&#123;</span><br><span class="line">print（&#x27;hello Dart&#x27;）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种定义方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">print(&#x27;你好 Dart&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="命名规则："><a href="#命名规则：" class="headerlink" title="命名规则："></a>命名规则：</h6><p>Dart的命名规则：</p><pre><code>      1、变量名称必须由数字、字母、下划线和美元符($)组成。      2.注意：标识符开头不能是数字      3.标识符不能是保留字和关键字。         4.变量的名字是区分大小写的如: age和Age是不同的变量。在实际的运用中,也建议,不要用一个单词大小写区分两个变量。          5、标识符(变量名称)一定要见名思意 ：变量名称建议用名词，方法名称建议用动词  </code></pre><h1 id="Dart数据类型"><a href="#Dart数据类型" class="headerlink" title="Dart数据类型"></a>Dart数据类型</h1><h6 id="常用数据类型："><a href="#常用数据类型：" class="headerlink" title="常用数据类型："></a>常用数据类型：</h6><p> Numbers（数值）:<br>          int<br>          double<br>      Strings（字符串）<br>          String<br>      Booleans(布尔)<br>          bool<br>      List（数组）<br>          在Dart中，数组是列表对象，所以大多数人只是称它们为列表<br>      Maps（字典）<br>          通常来说，Map 是一个键值对相关的对象。 键和值可以是任何类型的对象。每个 键 只出现一次， 而一个值则可以出现多次</p><p>  项目中用不到的数据类型 （用不到）：<br>      Runes<br>        Rune是UTF-32编码的字符串。它可以通过文字转换成符号表情或者代表特定的文字。</p><p>Symbols<br>        Symbol对象表示在Dart程序中声明的运算符或标识符。您可能永远不需要使用符号，但它们对于按名称引用标识符的API非常有用，因为缩小会更改标识符名称而不会更改标识符符号。要获取标识符的符号，请使用符号文字，它只是＃后跟标识符：在Dart中符号用#开头表示。</p><h6 id="字符串类型："><a href="#字符串类型：" class="headerlink" title="字符串类型："></a>字符串类型：</h6><p>定义的几种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &#x27;str1&#x27;;</span><br><span class="line">var str2 = &quot;str2&quot;;</span><br><span class="line">在Dart中字符串用单引号和双引号都可以</span><br><span class="line">String str1 = &#x27;str1&#x27;;</span><br><span class="line">String str2 = &quot;str2&quot;;</span><br><span class="line"></span><br><span class="line">String str3 = &#x27;&#x27;&#x27;str1</span><br><span class="line">str2</span><br><span class="line">str3&#x27;&#x27;&#x27;</span><br><span class="line">三个单引号会保留之间的所有内容，原样输出。类似于kotlin中</span><br></pre></td></tr></table></figure><p>字符串的拼接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1=&#x27;你好&#x27;;</span><br><span class="line"></span><br><span class="line">  String str2=&#x27;Dart&#x27;;</span><br><span class="line">  </span><br><span class="line">//kotlin中的字符串模板，双引号中的变量之前加上$，会输出对应的变量</span><br><span class="line">  print(&quot;$str1 $str2&quot;);</span><br><span class="line"></span><br><span class="line">//java中的“+”，实现的字符串拼接</span><br><span class="line">  print(str1 + str2);</span><br><span class="line">//同上</span><br><span class="line">  print(str1 +&quot; &quot;+ str2);</span><br></pre></td></tr></table></figure><h6 id="数值类型：int、"><a href="#数值类型：int、" class="headerlink" title="数值类型：int、"></a>数值类型：int、</h6><p>int：必须是整形</p><p>double：可以是整形，也可以是浮点型</p><h6 id="布尔类型：bool"><a href="#布尔类型：bool" class="headerlink" title="布尔类型：bool"></a>布尔类型：bool</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag = true;</span><br><span class="line">var flag = false;</span><br></pre></td></tr></table></figure><h6 id="List-数组-集合-："><a href="#List-数组-集合-：" class="headerlink" title="List(数组/集合)："></a>List(数组/集合)：</h6><p>定义list的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">var list1 = [&quot;张三&quot;, 20, true];</span><br><span class="line">第二种：指定类型</span><br><span class="line">var list2 = &lt;String&gt;[&quot;张三&quot;, &quot;李四&quot;];</span><br><span class="line">var list2 = &lt;int&gt;[12, 30];</span><br><span class="line">第三种：通过[]创建的集合，容量可以变化。上述的两种方式容量就可以变化</span><br><span class="line">var list3 = [];</span><br><span class="line">list3.add(&quot;张三&quot;);</span><br><span class="line">第四种：</span><br><span class="line">var list4 = new List();//在新版本的dart中无法使用这个方法</span><br><span class="line">var list5 = List.filled(5, &quot;&quot;);//创建一个固定长度的集合</span><br><span class="line">创建了固定长度的集合之后，只能修改，不能添加了，也不能修改集合的长度。</span><br></pre></td></tr></table></figure><h6 id="Map：字典"><a href="#Map：字典" class="headerlink" title="Map：字典"></a>Map：字典</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//第一种定义 Maps的方式</span><br><span class="line"></span><br><span class="line">    // var person=&#123;</span><br><span class="line">    //   &quot;name&quot;:&quot;张三&quot;,</span><br><span class="line">    //   &quot;age&quot;:20,</span><br><span class="line">    //   &quot;work&quot;:[&quot;程序员&quot;,&quot;送外卖&quot;]</span><br><span class="line">    // &#125;;</span><br><span class="line"></span><br><span class="line">    // print(person);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;age&quot;]);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;work&quot;]);</span><br><span class="line"></span><br><span class="line">   //第二种定义 Maps的方式</span><br><span class="line"></span><br><span class="line">    var p=new Map();</span><br><span class="line"></span><br><span class="line">    p[&quot;name&quot;]=&quot;李四&quot;;</span><br><span class="line">    p[&quot;age&quot;]=22;</span><br><span class="line">    p[&quot;work&quot;]=[&quot;程序员&quot;,&quot;送外卖&quot;];</span><br><span class="line">    print(p);</span><br><span class="line"></span><br><span class="line">    print(p[&quot;age&quot;]);</span><br></pre></td></tr></table></figure><p>类型判断：is关键词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// var str=&#x27;1234&#x27;;</span><br><span class="line"></span><br><span class="line">  // if(str is String)&#123;</span><br><span class="line">  //   print(&#x27;是string类型&#x27;);</span><br><span class="line">  // &#125;else if(str is int)&#123;</span><br><span class="line"></span><br><span class="line">  //    print(&#x27;int&#x27;);</span><br><span class="line">  // &#125;else&#123;</span><br><span class="line">  //    print(&#x27;其他类型&#x27;);</span><br><span class="line">  // &#125;</span><br></pre></td></tr></table></figure><h1 id="运算符-类型转换"><a href="#运算符-类型转换" class="headerlink" title="运算符+类型转换"></a>运算符+类型转换</h1><h6 id="运算符和类型转换："><a href="#运算符和类型转换：" class="headerlink" title="运算符和类型转换："></a>运算符和类型转换：</h6><p>算术运算符</p><pre><code>  +    -    *    /     ~/ (取整)     %（取余）  关系运算符  ==    ！=   &gt;    &lt;    &gt;=    &lt;=逻辑运算符    !（取反）  &amp;&amp;（且，全真才真）   ||（或，全假才为假）赋值运算符 基础赋值运算符   =   ??=（b??=23，表示b为空的话，把23赋值给它） 复合赋值运算符   +=  -=  *=   /=   %=  ~/= 自增自减运算符：++，--++  --   表示自增 自减 1    在赋值运算里面 如果++ -- 写在前面 这时候先运算 再赋值，如果++ --写在后面 先赋值后运行运算条件表达式     if  else   switch case     三目运算符    ??运算符：如果为空              // var a;              // var b= a ?? 10;              // print(b);   10</code></pre><p>​<br>                  var a=22;<br>                  var b= a ?? 10;</p><pre><code>              print(b); //22</code></pre><p>2、类型转换</p><pre><code>1、Number与String类型之间的转换2、其他类型转换成Booleans类型</code></pre><p>  1、Number与String类型之间的转换</p><pre><code>  // Number类型转换成String类型 toString()  // String类型转成Number类型  int.parse()，double.parse()</code></pre><p>2、其他类型转换成Booleans类型</p><pre><code>    // isEmpty:判断字符串是否为空</code></pre><h6 id="break和continue："><a href="#break和continue：" class="headerlink" title="break和continue："></a>break和continue：</h6><p>break语句功能:<br>          1、在switch语句中使流程跳出switch结构。<br>          2、在循环语句中使流程跳出当前循环,遇到break 循环终止，后面代码也不会执行</p><pre><code>      强调:      1、如果在循环中已经执行了break语句,就不会执行循环体中位于break后的语句。      2、在多层循环中,一个break语句只能向外跳出一层    break可以用在switch case中 也可以用在 for 循环和 while循环中  continue语句的功能:              【注】只能在循环语句中使用,使本次循环结束，即跳过循环体重下面尚未执行的语句，接着进行下次的是否执行循环的判断。    continue可以用在for循环以及 while循环中，但是不建议用在while循环中，不小心容易死循环</code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h6 id="for基本语法"><a href="#for基本语法" class="headerlink" title="for基本语法"></a>for基本语法</h6><p>​          for (int i = 1; i&lt;=100; i++) {<br>​            print(i);<br>​          }</p><pre><code>        //第一步，声明变量int i = 1;        //第二步，判断i &lt;=100        //第三步，print(i);        //第四步，i++        //第五步 从第二步再来，直到判断为false</code></pre><h6 id="while语法格式"><a href="#while语法格式" class="headerlink" title="while语法格式:"></a>while语法格式:</h6><pre><code>    while(表达式/循环条件)&#123;                        &#125;        do&#123;        语句/循环体            &#125;while(表达式/循环条件);        注意： 1、最后的分号不要忘记            2、循环条件中使用的变量需要经过初始化          3、循环体中，应有结束循环的条件，否则会造成死循环。</code></pre><p> while 和 do while的区别   第一次循环条件不成立的情况下</p><p>​    // int i=10;<br>​      // while(i&lt;2){<br>​      //     print(‘执行代码’);<br>​      // }</p><pre><code>  var j=10;        do&#123;      print(&#39;执行代码&#39;);  &#125;while(j&lt;2);</code></pre><h1 id="Dart集合类型以及循环语句"><a href="#Dart集合类型以及循环语句" class="headerlink" title="Dart集合类型以及循环语句"></a>Dart集合类型以及循环语句</h1><h6 id="List集合："><a href="#List集合：" class="headerlink" title="List集合："></a>List集合：</h6><p>List里面常用的属性和方法：</p><pre><code>常用属性：    length          长度    reversed        翻转    isEmpty         是否为空    isNotEmpty      是否不为空常用方法：      add         增加    addAll      拼接数组    indexOf     查找  传入具体值    remove      删除  传入具体值    removeAt    删除  传入索引值    fillRange   修改       insert(index,value);            指定位置插入        insertAll(index,list)           指定位置插入List    toList()    其他类型转换成List      join()      List转换成字符串    split()     字符串转化成List    forEach       map    where    any    every</code></pre><h6 id="Set集合："><a href="#Set集合：" class="headerlink" title="Set集合："></a>Set集合：</h6><p>用它最主要的功能就是去除数组重复内容</p><p>Set是没有顺序且不能重复的集合，所以不能通过索引去获取值</p><h6 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h6><p>映射(Maps)是无序的键值对：</p><pre><code>常用属性：    keys            获取所有的key值    values          获取所有的value值    isEmpty         是否为空    isNotEmpty      是否不为空常用方法:    remove(key)     删除指定key的数据    addAll(&#123;...&#125;)   合并映射  给映射内增加属性    containsValue   查看映射内的值  返回true/false    forEach       map    where    any    every</code></pre><h6 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// for(var i=0;i&lt;myList.length;i++)&#123;</span><br><span class="line">     //   print(myList[i]);</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // for(var item in myList)&#123;</span><br><span class="line">     //   print(item);</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // myList.forEach((value)&#123;</span><br><span class="line">     //     print(&quot;$value&quot;);</span><br><span class="line">     // &#125;);</span><br></pre></td></tr></table></figure><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4];      </span><br><span class="line">     // var newList=myList.map((value)&#123;</span><br><span class="line">     //     return value*2;</span><br><span class="line">     // &#125;);</span><br><span class="line">     //  print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="where："><a href="#where：" class="headerlink" title="where："></a>where：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">    // var newList=myList.where((value)&#123;</span><br><span class="line">    //     return value&gt;5;</span><br><span class="line">    // &#125;);</span><br><span class="line">    // print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="any："><a href="#any：" class="headerlink" title="any："></a>any：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">    // var f=myList.any((value)&#123;   //只要集合里面有满足条件的就返回true</span><br><span class="line"></span><br><span class="line">    //     return value&gt;5;</span><br><span class="line">    // &#125;);</span><br><span class="line">    // print(f);</span><br></pre></td></tr></table></figure><h6 id="every："><a href="#every：" class="headerlink" title="every："></a>every：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">      // var f=myList.every((value)&#123;   //每一个都满足条件返回true  否则返回false</span><br><span class="line"></span><br><span class="line">      //     return value&gt;5;</span><br><span class="line">      // &#125;);</span><br><span class="line">      // print(f);</span><br></pre></td></tr></table></figure><h6 id="set："><a href="#set：" class="headerlink" title="set："></a>set：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// set</span><br><span class="line"></span><br><span class="line">// var s=new Set();</span><br><span class="line"></span><br><span class="line">// s.addAll([1,222,333]);</span><br><span class="line"></span><br><span class="line">// s.forEach((value)=&gt;print(value));</span><br></pre></td></tr></table></figure><h6 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map person=&#123;</span><br><span class="line">      &quot;name&quot;:&quot;张三&quot;,</span><br><span class="line">      &quot;age&quot;:20</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    person.forEach((key,value)&#123;            </span><br><span class="line">        print(&quot;$key---$value&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>  内置方法/函数：</p><pre><code>  print();</code></pre><p>  自定义方法：<br>      自定义方法的基本格式：</p><pre><code>  返回类型  方法名称（参数1，参数2,...）&#123;    方法体    return 返回值;    //可以在这里在定义一个函数，也就是允许函数嵌套  &#125;</code></pre><p>dart中的方法可以嵌套：演示方法作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//演示方法的作用域</span><br><span class="line">//全局作用域</span><br><span class="line">List getList()&#123;</span><br><span class="line"></span><br><span class="line">  return [&#x27;111&#x27;,&#x27;2222&#x27;,&#x27;333&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">  void xxx()&#123;</span><br><span class="line">//局部作用域</span><br><span class="line">      aaa()&#123;</span><br><span class="line"></span><br><span class="line">          print(getList());</span><br><span class="line">          print(&#x27;aaa&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      aaa();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // aaa();  错误写法 </span><br></pre></td></tr></table></figure><p>例一：int sunNum(int n){</p><p>}</p><p>例二：// String printUserInfo(String username, int age) {<br>  //   //行参<br>  //   return “姓名:$username—年龄:$age”;<br>  // }</p><p>  // print(printUserInfo(‘张三’, 20)); //实参</p><p>例三：定义一个带可选参数的方法，最新的dart定义可选参数需要指定类型默认值</p><p>String printUserInfo(String username,[int age， String sex]){  //可选参数age、sex<br>     if(age!=null){<br>       return “姓名:$username—年龄:$age”;<br>     }<br>     return “姓名:$username—年龄保密”;<br>   }<br>   print(printUserInfo(‘张三’,21)); //实参<br>   print(printUserInfo(‘张三’));</p><p>例四：带默认参数，</p><p>String printUserInfo(String username,[String sex=’男’,int age]){  //默认参数sex、可选参数age。注意顺序<br>  //   if(age!=0){<br>  //     return “姓名:$username—性别:$sex–年龄:$age”;<br>  //   }<br>  //   return “姓名:$username—性别:$sex–年龄保密”;<br>  // }<br>  // print(printUserInfo(‘张三’));<br>  // print(printUserInfo(‘小李’,’女’));<br>  // print(printUserInfo(‘小李’,’女’,30));</p><p>例五：定义一个命名参数的方法，最新的dart定义命名参数需要指定类型默认值</p><p>  // String printUserInfo(String username, {int age = 0, String sex = ‘男’}) {//行参<br>  //   if (age != 0) {<br>  //     return “姓名:$username—性别:$sex–年龄:$age”;<br>  //   }<br>  //   return “姓名:$username—性别:$sex–年龄保密”;<br>  // }<br>  // print(printUserInfo(‘张三’, age: 20, sex: ‘未知’));</p><p>例六：方法作为另一个方法的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// var fn=()&#123;</span><br><span class="line"></span><br><span class="line">  //   print(&#x27;我是一个匿名方法&#x27;);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // fn();</span><br><span class="line"></span><br><span class="line">  //方法</span><br><span class="line">  fn1() &#123;</span><br><span class="line">    print(&#x27;fn1&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //方法</span><br><span class="line">  fn2(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //调用fn2这个方法 把fn1这个方法当做参数传入</span><br><span class="line">  fn2(fn1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="箭头函数："><a href="#箭头函数：" class="headerlink" title="箭头函数："></a>箭头函数：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">/*需求：使用forEach打印下面List里面的数据*/</span><br><span class="line"></span><br><span class="line">  // List list=[&#x27;苹果&#x27;,&#x27;香蕉&#x27;,&#x27;西瓜&#x27;];</span><br><span class="line">  // list.forEach((value)&#123;</span><br><span class="line">  //   print(value);</span><br><span class="line">  // &#125;);</span><br><span class="line"></span><br><span class="line">  // list.forEach((value)=&gt;print(value));</span><br><span class="line"></span><br><span class="line">  //注意和方法的区别: 箭头函数内只能写一条语句，并且语句后面没有分号(;)</span><br><span class="line">  // list.forEach((value)=&gt;&#123;</span><br><span class="line">  //   print(value)</span><br><span class="line">  // &#125;);</span><br><span class="line"></span><br><span class="line">/*需求：修改下面List里面的数据，让数组中大于2的值乘以2*/</span><br><span class="line"></span><br><span class="line">  // List list=[4,1,2,3,4];</span><br><span class="line">  // var newList=list.map((value)&#123;</span><br><span class="line">  //     if(value&gt;2)&#123;</span><br><span class="line">  //       return value*2;</span><br><span class="line">  //     &#125;</span><br><span class="line">  //     return value;</span><br><span class="line"></span><br><span class="line">  // &#125;);</span><br><span class="line">  // print(newList.toList());</span><br><span class="line"></span><br><span class="line">  //  var newList=list.map((value)=&gt;value&gt;2?value*2:value);</span><br><span class="line">  //  print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="函数的相互调用："><a href="#函数的相互调用：" class="headerlink" title="函数的相互调用："></a>函数的相互调用：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">需求：    1、定义一个方法isEvenNumber来判断一个数是否是偶数  </span><br><span class="line">         2、定义一个方法打印1-n以内的所有偶数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 1、定义一个方法isEvenNumber来判断一个数是否是偶数  </span><br><span class="line">  bool isEvenNumber(int n) &#123;</span><br><span class="line">    if (n % 2 == 0) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">//  2、定义一个方法打印1-n以内的所有偶数</span><br><span class="line">  printNum(int n) &#123;</span><br><span class="line">    for (var i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">      if (isEvenNumber(i)) &#123;</span><br><span class="line">        print(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printNum(10);//打印1-10以内的所有函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="匿名方法："><a href="#匿名方法：" class="headerlink" title="匿名方法："></a>匿名方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int getNum(int n) &#123;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // print(getNum(12));</span><br><span class="line"></span><br><span class="line">  //匿名方法</span><br><span class="line"></span><br><span class="line">  // var printNum=()&#123;</span><br><span class="line">  //   print(123);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // printNum();</span><br><span class="line"></span><br><span class="line">  // var printNum=(int n)&#123;</span><br><span class="line">  //   print(n+2);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // printNum(12);</span><br></pre></td></tr></table></figure><h6 id="自执行方法："><a href="#自执行方法：" class="headerlink" title="自执行方法："></a>自执行方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((int n)&#123;</span><br><span class="line">  //   print(n);</span><br><span class="line">  //   print(&#x27;我是自执行方法&#x27;);</span><br><span class="line">  // &#125;)(12);</span><br></pre></td></tr></table></figure><h6 id="方法递归："><a href="#方法递归：" class="headerlink" title="方法递归："></a>方法递归：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// var sum = 1;</span><br><span class="line"> // fn(int n) &#123;</span><br><span class="line"> //   sum *= n;</span><br><span class="line"> //   if (n == 1) &#123;</span><br><span class="line"> //     return;</span><br><span class="line"> //   &#125;</span><br><span class="line"> //   fn(n - 1);</span><br><span class="line"> // &#125;</span><br><span class="line"></span><br><span class="line"> // fn(5);</span><br><span class="line"> // print(sum);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> var sum=0;</span><br><span class="line"> fn(int n)&#123;</span><br><span class="line">     sum+=n;</span><br><span class="line">     if(n==0)&#123;</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">     fn(n-1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(100);</span><br><span class="line"> print(sum);</span><br></pre></td></tr></table></figure><h6 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h6><p>  1、全局变量特点:    全局变量常驻内存、全局变量污染全局<br>  2、局部变量的特点：  不常驻内存会被垃圾机制回收、不会污染全局  </p><p>  /*  想实现的功能：</p><p>​    1.常驻内存<br>​    2.不污染全局   </p><p>​      产生了闭包,闭包可以解决这个问题…..  </p><p>​      闭包: 函数嵌套函数, 内部函数会调用外部函数的变量或参数, 变量或参数不会被系统回收(不会释放内存)</p><p>​      闭包的写法： 函数嵌套函数，并return 里面的函数，这样就形成了闭包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*全局变量*/</span><br><span class="line">var a = 123;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // print(a);</span><br><span class="line"></span><br><span class="line">  // fn()&#123;</span><br><span class="line">  //   a++;</span><br><span class="line">  //   print(a);</span><br><span class="line">  // &#125;</span><br><span class="line">  // fn();</span><br><span class="line">  // fn();</span><br><span class="line">  // fn();</span><br><span class="line"></span><br><span class="line">//局部变量</span><br><span class="line">  // printInfo() &#123;</span><br><span class="line">  //   var myNum = 123;</span><br><span class="line">  //   myNum++;</span><br><span class="line">  //   print(myNum);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // printInfo();</span><br><span class="line">  // printInfo();</span><br><span class="line">  // printInfo();</span><br><span class="line"></span><br><span class="line">//闭包</span><br><span class="line"></span><br><span class="line">  fn() &#123;</span><br><span class="line">    var a = 123; /*不会污染全局   常驻内存*/</span><br><span class="line">    return () &#123;</span><br><span class="line">      a++;</span><br><span class="line">      print(a);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var b = fn();</span><br><span class="line">  b();</span><br><span class="line">  b();</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象编程(OOP)的三个基本特征是：封装、继承、多态      </p><p>  封装：封装是对象和类概念的主要特性。封装，把客观事物封装成抽象的类，并且把自己的部分属性和方法提供给其他对象调用, 而一部分属性和方法则隐藏。</p><p>  继承：面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>  多态：允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。</p><p>Dart所有的东西都是对象，所有的对象都继承自Object类。</p><p>Dart是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是Object的子类</p><p>一个类通常由属性和方法组成。</p><h6 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h6><p>Dart是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是Object的子类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  String name=&quot;张三&quot;;</span><br><span class="line">  int age=23;</span><br><span class="line">  void getInfo()&#123;</span><br><span class="line">      // print(&quot;$name----$age&quot;);</span><br><span class="line">      print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void setInfo(int age)&#123;</span><br><span class="line">    this.age=age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  //实例化</span><br><span class="line"></span><br><span class="line">  // var p1=new Person();</span><br><span class="line">  // print(p1.name);</span><br><span class="line">  // p1.getInfo();</span><br><span class="line"></span><br><span class="line">  Person p1=new Person();</span><br><span class="line">  // print(p1.name);</span><br><span class="line"></span><br><span class="line">  p1.setInfo(28);</span><br><span class="line">  p1.getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// class Person&#123;</span><br><span class="line">//   String name=&#x27;张三&#x27;;</span><br><span class="line">//   int age=20; </span><br><span class="line">//   //默认构造函数</span><br><span class="line">   Person()&#123;</span><br><span class="line">     print(&#x27;这是构造函数里面的内容  这个方法在实例化的时候触发&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line">Person(String name, int age)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//上边构造函数的简写</span><br><span class="line">Person(this.name, this.age);</span><br><span class="line">//   void printInfo()&#123;   </span><br><span class="line">//     print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命名构造函数：</span><br><span class="line">class Person&#123;</span><br><span class="line">String name;</span><br><span class="line">int age ;</span><br><span class="line">//默认构造函数</span><br><span class="line">Person(String name, int age)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//命名构造函数</span><br><span class="line">Person.now()&#123;</span><br><span class="line">print(&#x27;我是命名构造函数&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">Person.setInfo(String name, int age)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">void printInfo()&#123;   </span><br><span class="line">     print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main&#123;</span><br><span class="line">Person p1 = new Person(&#x27;张三&#x27;, 20);//调用的默认构函数</span><br><span class="line">Person p2 = new Person.now();//调用的命名构造函数</span><br><span class="line">&#125;</span><br><span class="line">默认构造函数只能有一个，命名构造函数可以有多个</span><br></pre></td></tr></table></figure><p>import ‘lib/Person.dart’;//导入类</p><h6 id="私有方法、私有属性"><a href="#私有方法、私有属性" class="headerlink" title="私有方法、私有属性"></a>私有方法、私有属性</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Dart和其他面向对象语言不一样，Data中没有 public  private protected这些访问修饰符合</span><br><span class="line"></span><br><span class="line">但是我们可以使用_把一个属性或者方法定义成私有。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;lib/Animal.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"> </span><br><span class="line"> Animal a=new Animal(&#x27;小狗&#x27;, 3);</span><br><span class="line"></span><br><span class="line"> print(a.getName());</span><br><span class="line"></span><br><span class="line"> a.execRun();   //间接的调用私有方法</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">加了下划线，如果在同一个文件中也是能够访问到的。也可以在私有属性的类中定义方法，在另一个文件中通过方法访问</span><br><span class="line">私有方法只能在当前类中访问，也可以通过公共方法（公共方法中调用了私有方法），然后调用公共方法来访问</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="getter和setter方法："><a href="#getter和setter方法：" class="headerlink" title="getter和setter方法："></a>getter和setter方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rect&#123;</span><br><span class="line">  late num height;</span><br><span class="line">  late num width;   </span><br><span class="line">  Rect(this.height,this.width);</span><br><span class="line">  get area&#123;</span><br><span class="line">    return this.height*this.width;</span><br><span class="line">  &#125;</span><br><span class="line">  set areaHeight(value)&#123;</span><br><span class="line">    this.height=value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  Rect r=new Rect(10,4);</span><br><span class="line">  // print(&quot;面积:$&#123;r.area()&#125;&quot;);   </span><br><span class="line">  r.areaHeight=6;</span><br><span class="line"></span><br><span class="line">  print(r.area);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">get和set相当于一个计算属性，只是没有方法后边的括号。</span><br></pre></td></tr></table></figure><h6 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Dart中我们也可以在构造函数体运行之前初始化实例变量</span><br><span class="line"></span><br><span class="line">class Rect&#123;</span><br><span class="line">  int height;</span><br><span class="line">  int width;</span><br><span class="line">  Rect():height=2,width=10&#123;</span><br><span class="line">    </span><br><span class="line">    print(&quot;$&#123;this.height&#125;---$&#123;this.width&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  getArea()&#123;</span><br><span class="line">    return this.height*this.width;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  Rect r=new Rect();</span><br><span class="line">  print(r.getArea());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-7</title>
      <link href="2021/07/07/7-7/"/>
      <url>2021/07/07/7-7/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode大餐计数1711"><a href="#leetcode大餐计数1711" class="headerlink" title="leetcode大餐计数1711"></a>leetcode大餐计数1711</h1><p>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 任意 两道餐品做一顿大餐。</p><p>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><p>示例 1：</p><p>输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。<br>示例 2：</p><p>输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</p><h6 id="思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness-i-相加成为2的幂。"><a href="#思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness-i-相加成为2的幂。" class="headerlink" title="思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness[i]相加成为2的幂。"></a>思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness[i]相加成为2的幂。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int countPairs(int[] deliciousness)&#123;</span><br><span class="line">    List&lt;Double&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; deliciousness.length; i++)&#123;</span><br><span class="line">        for (int j = i + 1; j &lt; deliciousness.length; j++)&#123;</span><br><span class="line">            int k = deliciousness[i] +deliciousness[j];</span><br><span class="line">            //判断某一个数是否为2的次幂</span><br><span class="line">            //(number &amp; number - 1) == 0</span><br><span class="line">            if ((k &amp; (k - 1)) == 0 &amp;&amp; k != 0)&#123;</span><br><span class="line">                list.add(k % ((Math.pow(10, 9)) + 7));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为o（n^2）,</p><h6 id="判断某一个数是否为2的次幂："><a href="#判断某一个数是否为2的次幂：" class="headerlink" title="判断某一个数是否为2的次幂："></a>判断某一个数是否为2的次幂：</h6><p> 1、将2的幂次方写成二进制形式后，很容易就会发现有一个特点：二进制中只有一个1，并且1后面跟了n个0； 因此问题可以转化为判断1后面是否跟了n个0就可以了。</p><pre><code>    如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零。   最快速的方法：  (number &amp; number - 1) == 0</code></pre><p>2、看的宫水三叶<a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/</a></p><p>插入一小段话，我是偶然发现了宝藏姐姐的公众号，然后无法自拔，然后每天都有关注公众号和三叶的leetcode。每当看到大佬的解法总是无比的崇拜，感叹自己怎么这么菜，但是每个人的成长总是披荆斩棘的，所以coding吧兄弟们。</p><p>判断某个数是否为2的次幂。</p><p>朴素做法对x应用试除法，因为精度问题，需要使用乘法实现试除。</p><p>另外一个优秀的做法是利用位运算找到符合【大于等于x】的最近的2的幂，然后判断是否与x相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean check(long x) &#123;</span><br><span class="line">        // 方法一</span><br><span class="line">        // long cur = 1;</span><br><span class="line">        // while (cur &lt; x) &#123;</span><br><span class="line">        //     cur = cur * 2;</span><br><span class="line">        // &#125;</span><br><span class="line">        // return cur == x;</span><br><span class="line">        </span><br><span class="line">        // 方法二</span><br><span class="line">        return getVal(x) == x;</span><br><span class="line">    &#125;</span><br><span class="line">    long getVal(long x) &#123;</span><br><span class="line">        long n = x - 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 2;</span><br><span class="line">        n |= n &gt;&gt;&gt; 4;</span><br><span class="line">        n |= n &gt;&gt;&gt; 8;</span><br><span class="line">        n |= n &gt;&gt;&gt; 16;</span><br><span class="line">        return n &lt; 0 ? 1 : n + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述的两个for循环解法存在重复计算。可以用哈希表记录某个数出现的次数，但是这种算法的时间复杂度还是o（n^2）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int countPairs(int[] deliciousness)&#123;</span><br><span class="line">        long ans = 0;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; deliciousness.length; i++)&#123;</span><br><span class="line">            int k = deliciousness[i];</span><br><span class="line">            for (int other : hashMap.keySet())&#123;</span><br><span class="line">                int z = k + other;</span><br><span class="line">                if ((z &amp; (z - 1)) == 0 &amp;&amp; z != 0)&#123;</span><br><span class="line">                    ans += hashMap.get(other);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(k, hashMap.getOrDefault(k, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) (ans % 10000007);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我的疑问：我一开始不明白为什么哈希表为什么是一边遍历一边统计的。</p><p>上边的第一种思路理解：枚举后边的数。对于一开始的两个for循环，我们对于第一个for循环，然后找当前位置后边的数，看两个数相加是否为2的幂。</p><p>另外一种思路：枚举前一个数。其实我们也可以理解为对于第一个for循环，我们找当前位置前边的数，看两个数相加是否为2的次幂。</p><h6 id="思路2：枚举2的幂（容斥原理）"><a href="#思路2：枚举2的幂（容斥原理）" class="headerlink" title="思路2：枚举2的幂（容斥原理）"></a>思路2：枚举2的幂（容斥原理）</h6><p>宫水三叶<a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-6</title>
      <link href="2021/07/06/7-6/"/>
      <url>2021/07/06/7-6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-5</title>
      <link href="2021/07/06/7-5/"/>
      <url>2021/07/06/7-5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-4</title>
      <link href="2021/07/06/7-4/"/>
      <url>2021/07/06/7-4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-1</title>
      <link href="2021/07/06/7-1/"/>
      <url>2021/07/06/7-1/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode07传递信息"><a href="#leetcode07传递信息" class="headerlink" title="leetcode07传递信息"></a>leetcode07传递信息</h1><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： </p><p> 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 </p><p>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</p><p>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 </p><p>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。  </p><p>示例 1：  输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3  输出：3  解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。  </p><p>示例 2：  输入：n = 3, relation = [[0,2],[2,1]], k = 2  输出：0  解释：信息不能从小 A 处经过 2 轮传递到编号 2</p><h6 id="解析：BFS、DFS、动态规划"><a href="#解析：BFS、DFS、动态规划" class="headerlink" title="解析：BFS、DFS、动态规划"></a>解析：BFS、DFS、动态规划</h6><p>BFS方法：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3</title>
      <link href="2021/07/03/7-3/"/>
      <url>2021/07/03/7-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2</title>
      <link href="2021/07/02/7-2/"/>
      <url>2021/07/02/7-2/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer：单链表、链表"><a href="#剑指offer：单链表、链表" class="headerlink" title="剑指offer：单链表、链表"></a>剑指offer：单链表、链表</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>androidSomething</title>
      <link href="2021/07/02/androidSomething/"/>
      <url>2021/07/02/androidSomething/</url>
      
        <content type="html"><![CDATA[<h1 id="something"><a href="#something" class="headerlink" title="something"></a>something</h1><p>要理解设计者意图，就需要抽象。我们需要在哲学意义空间中去考虑系统的描述，即系统在本质上要表达什么。在逻辑空间上去考虑系统基本构成和动态结构。从现实到虚拟对象的映射去理解系统对象的组成，在从数据流的角度分析数据的产生者和消费者之间作用关系，从控制流的角度去分析对象之间的交互关系，从函数调用去分析具体的层次关系。</p><p>在系统设计上，原型是最能表达哲学空间和逻辑空间中系统本质的东西，原型是事物本质的第一层体现。我以为任何复杂的系统都一个简洁的系统原型，都有它简洁的意义。系统原型是设计者意图的第一体现，所以我们需要从几个方向上去提炼系统原型：</p><p>（1）从系统本质和基本原理出发</p><p>（2）从分析系统数据流和控制流分析出发。</p><p>从设计者意图出发，得出系统原型，提取到大的逻辑结构和系统构成是第一步。之后我们可以从设计者的角度考虑系统猜想系统设计，为什么要这样设计，为什么要有这些构成。这样的基本原型是什么？系统的限制是什么，应用场景有哪些，有些设计的引进还是系统收敛性而为之呢。我们还可以从代码痕迹上去分析，这些概念是如何的得来的？从一定的抽象和高度去理解这些问题，遵循系统原型出发之原则，在深入分析代码的时候，就不容易陷入细节中。我们就可以随时跳出来想，这些代码在整体上载表达一个什么概念，在描绘一个什么逻辑，他要构成一个虚拟层吗？他是在管理这个硬件吗？他在虚拟这个对象吗？他在构建管理机构？还是在构建一个对象管理？空间管理，为了快速引入了什么样的复杂算法，实际上的原型算法应该是什么样的？</p><p>只有深入到这个抽象层次，我们才能很好的把握住系统的每一条线，每一个对象的意义。只用从原型出发，我们才能把握住这个系统的实质所在，在干什么？他要表达什么？设计者为什么要这样想？最终极的想法是什么？这样，代码分析就变得简单明了，读代码就变成了是在印证猜想，修正方向。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode图</title>
      <link href="2021/07/01/leetcode%E5%9B%BE/"/>
      <url>2021/07/01/leetcode%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeBFS</title>
      <link href="2021/06/30/leetcodeBFS/"/>
      <url>2021/06/30/leetcodeBFS/</url>
      
        <content type="html"><![CDATA[<h1 id="100-相同的树（简单）"><a href="#100-相同的树（简单）" class="headerlink" title="100.相同的树（简单）"></a>100.相同的树（简单）</h1><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>思路：BFS的非递归，需要用到队列数据结构。</p><p>​            <code>bfs</code> 一般我们不会去涉及，而且比较绕，之前我们唯一 <code>A</code> 过的用 <code>bfs</code> 递归的方式是层序遍历二叉树的时候可以用递归的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isSameTree(TreeNode p, TreeNode q)&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queueP = new LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queueQ = new LinkedList&lt;&gt;();</span><br><span class="line">    queueP.add(p);</span><br><span class="line">    queueQ.add(q);</span><br><span class="line">    while (queueP.size() == queueQ.size() &amp;&amp; !queueP.isEmpty() &amp;&amp; !queueQ.isEmpty())&#123;</span><br><span class="line">        int size = queueP.size();</span><br><span class="line">        while (size-- &gt; 0)&#123;</span><br><span class="line">            TreeNode nodeP = queueP.remove();</span><br><span class="line">            TreeNode nodeQ = queueQ.remove();</span><br><span class="line">            if (nodeP == null &amp;&amp; nodeQ != null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (nodeP != null &amp;&amp; nodeQ == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (nodeP != null &amp;&amp; nodeQ != null &amp;&amp; nodeP.val != nodeQ.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (nodeP == null &amp;&amp; nodeQ == null)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nodeP.left != null || nodeP.right != null)&#123;</span><br><span class="line">                queueP.add(nodeP.left);</span><br><span class="line">                queueP.add(nodeP.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (nodeQ.left != null || nodeQ.right != null)&#123;</span><br><span class="line">                queueQ.add(nodeQ.left);</span><br><span class="line">                queueQ.add(nodeQ.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (queueP.size() != queueQ.size())&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130.被围绕的区域"></a>130.被围绕的区域</h1><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p>输入：board = [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]<br>输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]<br>解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br>示例 2：</p><p>输入：board = [[“X”]]<br>输出：[[“X”]]</p><h1 id="LCP07-传递信息"><a href="#LCP07-传递信息" class="headerlink" title="LCP07.传递信息"></a>LCP07.传递信息</h1><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><p>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0<br>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。<br>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人<br>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p><p>示例 1：</p><p>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3</p><p>输出：3</p><p>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p><p>示例 2：</p><p>输入：n = 3, relation = [[0,2],[2,1]], k = 2</p><p>输出：0</p><p>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p><p>思路：n 和 k 的数据范围都很小，并且根据题目对 relation 的定义可以知道这是一个边权相等的图。</p><p>对于边权相等的图，统计有限步数的到达某个节点的方案数，最常见的方式是使用 BFS 或 DFS。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeDFS</title>
      <link href="2021/06/30/leetcodeDFS/"/>
      <url>2021/06/30/leetcodeDFS/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS和BFS："><a href="#DFS和BFS：" class="headerlink" title="DFS和BFS："></a>DFS和BFS：</h2><p><strong>1.数据结构上的运用</strong></p><p>DFS用递归的形式，用到了栈结构，先进后出。</p><p>BFS选取状态用队列的形式，先进先出。</p><p><strong>2.复杂度</strong></p><p>DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。</p><p><strong>3.思想</strong></p><p>思想上来说这两种方法都是穷竭列举所有的情况。</p><h1 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403.青蛙过河"></a>403.青蛙过河</h1><p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p><p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p><p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p><p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p>示例 1：</p><p>输入：stones = [0,1,3,5,6,8,12,17]<br>输出：true<br>解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。<br>示例 2：</p><p>输入：stones = [0,1,2,3,4,8,9,11]<br>输出：false<br>解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</p><h1 id="113-路径总和"><a href="#113-路径总和" class="headerlink" title="113.路径总和"></a>113.路径总和</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood动态规划相关题目</title>
      <link href="2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode22：括号生成"><a href="#leetcode22：括号生成" class="headerlink" title="leetcode22：括号生成"></a>leetcode22：括号生成</h1>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood链表相关题目</title>
      <link href="2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood二叉树相关题目</title>
      <link href="2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode栈和队列相关题目</title>
      <link href="2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode20：有效括号（栈可以解决）"><a href="#leetcode20：有效括号（栈可以解决）" class="headerlink" title="leetcode20：有效括号（栈可以解决）"></a>leetcode20：有效括号（栈可以解决）</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员代码面试指南第一章题目</title>
      <link href="2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h1><h2 id="1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"><a href="#1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。" class="headerlink" title="1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"></a>1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。</h2><p>思路：因为要返回栈中最小的元素，所以需要找个地方把最小的元素给存起来。这个存起来的过程涉及到判断最小的元素。</p><p>方法1：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​            压入规则：1、判断stackData是否为空。</p><p>​                                    1.1：为空，两个栈压入</p><p>​                                    1.2：不为空，stackData压入，然后判断压入数据和stackMin栈顶元素的大小，如果压入数据小或等于，也压入stackMin中。压入数据大于stackMin栈顶的元素，则不用压入。</p><p>​            弹出规则：压入规则的对应。</p><p>​            查询当前栈最小值的操作：stackMin保存着最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackNormal = new Stack();</span><br><span class="line">    Stack&lt;Integer&gt; stackSpecial = new Stack();</span><br><span class="line">//构造函数</span><br><span class="line">    public GetMin() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GetMin(Stack&lt;Integer&gt; stackNormal, Stack&lt;Integer&gt; stackSpecial) &#123;</span><br><span class="line">        this.stackNormal = stackNormal;</span><br><span class="line">        this.stackSpecial = stackSpecial;</span><br><span class="line">    &#125;</span><br><span class="line">//压入规则</span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">       stackNormal.push(input);</span><br><span class="line">       if (stackSpecial.size() == 0)&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stackSpecial.size() != 0 &amp;&amp; input &lt;= stackSpecial.peek())&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//弹出规则</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stackNormal.pop();</span><br><span class="line">        if (value == stackSpecial.peek())&#123;</span><br><span class="line">            stackSpecial.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">//查询规则</span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackSpecial.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​        压入规则：先判断stackData栈是否为空，为空的话两个栈同时压入。</p><p>​                            不为空：stackData压入数据，然后判断压入的数据和stackMin栈顶的元素的大小。如果大于stackMin栈顶的元素，stackMin再次压入当前栈顶的元素，如果小于stackMin栈顶的元素，则也直接压入stackMin。</p><p>​        弹出规则：压入规则的对应</p><p>​        查询规则：stackMin栈的栈顶元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin2 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackData = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackMin = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public GetMin2(Stack&lt;Integer&gt; stackData, Stack&lt;Integer&gt; stackMin) &#123;</span><br><span class="line">        this.stackData = stackData;</span><br><span class="line">        this.stackMin = stackMin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">        stackData.push(input);</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            stackMin.push(input);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (input &lt;= stackMin.peek())&#123;</span><br><span class="line">                stackMin.push(input);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stackMin.push(stackMin.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackData.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stackMin.pop();</span><br><span class="line">        return stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackMin.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="两个栈组成的队列"><a href="#两个栈组成的队列" class="headerlink" title="两个栈组成的队列"></a>两个栈组成的队列</h1><h5 id="2、编写一个类，用两个栈实现队列，支持队列的基本操作"><a href="#2、编写一个类，用两个栈实现队列，支持队列的基本操作" class="headerlink" title="2、编写一个类，用两个栈实现队列，支持队列的基本操作"></a>2、编写一个类，用两个栈实现队列，支持队列的基本操作</h5><p>思路：栈的特点是先进后出，队列的特点是先进先出。所以我们需要从stackIn中数据倒入stackOut中，在出栈就会满足队列的特点。注意点1：就是从stackIn转移数据到stackOut中的时候，需要把stackIn中的数据全部出栈，再stackOut中进栈。注意点2：如果stackOut不空的时候stackIn不能向stackOut中压入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TwoStackToQueue &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackOut = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(int input)&#123;</span><br><span class="line">        stackIn.push(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int poll()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="如何仅用递归函数和栈操作逆序一个栈"><a href="#如何仅用递归函数和栈操作逆序一个栈" class="headerlink" title="如何仅用递归函数和栈操作逆序一个栈"></a>如何仅用递归函数和栈操作逆序一个栈</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//翻转栈</span><br><span class="line">public static void reverseStack(Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">    if (stack.isEmpty())&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = getAndRemoveLastElement(stack);</span><br><span class="line">    reverseStack(stack);</span><br><span class="line">    stack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在递归函数中用一个变量来保存中间的值</span><br><span class="line">public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">    int result = stack.pop();</span><br><span class="line">    if (stack.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        int last = getAndRemoveLastElement(stack);</span><br><span class="line">        stack.push(result);</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode168Excel表列名称</title>
      <link href="2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
      <url>2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode168：Excel表列名称"><a href="#leetcode168：Excel表列名称" class="headerlink" title="leetcode168：Excel表列名称"></a>leetcode168：Excel表列名称</h1><p>题目：给你一个整数，返回它在Excel表中相应的列名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">例如：</span><br><span class="line">输入：columnNumber = 1</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">输入：columnNumber = 28</span><br><span class="line">输出：&quot;AB&quot;</span><br><span class="line">输入：columnNumber = 2147483647</span><br><span class="line">输出：&quot;FXSHRXW&quot;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>这道题属于简单题。首先要能够意识这道题考察了进制之间的转换。另外本题中的范围为【1-26】，要变化为【0-25】。</p><h5 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h5><p>1、m进制转化为10进制。</p><p>​        方法：从低位到高位按权展开</p><p>2、10进制转换为n进制</p><p>​        方法：除留取余，逆序排序</p><p>3、本题中的范围是【1-26】，需要对每个进行求余和整除的数减一，在对26进行求余运算，把范围变成【0-25】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String convertToTitle(int columnNumber)&#123;</span><br><span class="line">    //用的stringBuilder进行储存</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    while (columnNumber &gt; 0)&#123;</span><br><span class="line">        columnNumber--;</span><br><span class="line">        //减一,为什么减一。因为26在本题中对应的Z，但是和26除余之后为0.</span><br><span class="line">        //举个例子，比如1--&gt;A.减一除余之后为0，在加A（是加的ASCII码）就变成了A。</span><br><span class="line">        stringBuilder.append((char)((columnNumber % 26) + &#x27;A&#x27;));</span><br><span class="line">        columnNumber = columnNumber / 26;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.reverse();</span><br><span class="line">    return stringBuilder.toString();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin基础</title>
      <link href="2021/06/28/kotlin%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/28/kotlin%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin从入门到进阶实战"><a href="#Kotlin从入门到进阶实战" class="headerlink" title="Kotlin从入门到进阶实战"></a>Kotlin从入门到进阶实战</h1><h2 id="变量和标识符"><a href="#变量和标识符" class="headerlink" title="变量和标识符"></a>变量和标识符</h2><p>变量标识一个对象的地址，称之为标识符。具体存放的数据占用的内存的大小和存放的形式由其类型来决定。</p><p>kotlin中所有的变量类型都是引用类型。kotlin变量分为</p><p>​        val（不可变的）：只读的，仅能赋值一次</p><p>​        var（可写的）：可以被多次赋值</p><h2 id="关键字和修饰符"><a href="#关键字和修饰符" class="headerlink" title="关键字和修饰符"></a>关键字和修饰符</h2><p>关键字：类修饰符、成员修饰符、访问权限修饰符、协变逆变修饰符、函数修饰符、属性修饰符、参数修饰符等</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>分支语句（if、when）</p><p>​        在Kotlin中，if是一个表达式，会返回一个值</p><p>​        if的分支可以是代码块，最后的表达式作为该块的值</p><p>​        when表达式类似于switch..case表达式</p><p>循环语句（for、while）</p><p>​        for循环可以对任何提供迭代器（iterator）的对象进行遍历</p><p>​        while循环类似于java</p><p>跳转语句（return、break、continue、throw）</p><p>​        break：用于完全结束一个循环，直接跳出循环体，然后执行循环后面的语句。<br>​        continue：只终止本轮循环，但是还会继续下一轮循环。</p><p>​        return：kotlin中除了表达式的值，有返回值的函数都要求显示使用return语句返回其值。kotlin中可以直接使用“=”符号返回一个函数的值，这样的函数称为函数字面量。</p><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>kotlin中任何表达式都可以用标签来标记。标签的格式为标识符后跟@符号，可以用标签来控制return、break、continue等语句的跳转行为。</p><h5 id="基本类型："><a href="#基本类型：" class="headerlink" title="基本类型："></a>基本类型：</h5><p>​        在kotlin中，所有东西都是对象，我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示–数字、字符、布尔值在运行时表示为原生类型值，但对于用户来说，看起来就像是普通的类。kotlin中的基本类型：数字、字符、布尔值、数组与字符串。</p><p>整型：Byte、Short、Int、Long。</p><p>​        所有未超出Int最大值的整形值且未显示指定类型，都会被推断为Int类型。如果初始值超过了其最大值且未显示指定类型会被推断为Long类型。</p><p>浮点型：Float、Double。</p><p>​        对于以小数初始化的变量，编译器会推断为Double类型。可以添加f或F将值显示指定为Float类型。</p><p>​        三个特殊的浮点型数值：正无穷大、负无穷大和非数。所有的正无穷大数值都相等，所有的负无穷大数值都相等，非数不与任何数值相等且非数之间也不相等（因为非数之间比较没有意义）</p><p>​        kotlin没有隐式拓宽转换，具有Double参数的函数只能对Double值调用，而不能对Float、Int其他数字值调用 。</p><p>字符型：kotlin语言使用16位的unicode字符集作为编码方式。kotlin中的Char型变量不能当成整数值使用，Char型变量不能赋值给整型变量，整型变量也不能赋值给Char型变量。</p><p>字面值常量：</p><p>​        十进制：123.  Long类型用大写L标记：123L</p><p>​        十六进制：0x0F</p><p>​        二进制：0b00001011</p><p>​        不支持八进制</p><p>支持浮点数的常规表示方法：</p><p>​        默认double:123.5</p><p>​        Float用f或者F标记：123.5f</p><p> kotlin中，较小类型不是较大类型的子类型，所以较小类型不能隐式转换为较大类型。必须通过显示转换。toByte（）、toShort（）、toInt（）、toLong（）等。</p><p>kotlin在表达式中可以自动转换，这种转换是基于上下文推断出来的，算术运算符会有重载做适当转换。</p><p>布尔：布尔用Boolean类型表示，有两个值true和false</p><p>121000004352307294</p><h1 id="疯狂kotlin讲义"><a href="#疯狂kotlin讲义" class="headerlink" title="疯狂kotlin讲义"></a>疯狂kotlin讲义</h1><h2 id="kotlin的基础类型："><a href="#kotlin的基础类型：" class="headerlink" title="kotlin的基础类型："></a>kotlin的基础类型：</h2><p>声明变量：var | val  变量名 【：类型】【= 初始值】</p><p>var声明的变量可被多次赋值，val声明的变量不可被重新赋值</p><p>kotlin是强类型的语言，要求所有的变量必须先声明、后使用，声明变量时必须显示或隐式指定变量的类型。</p><p>程序要么通过“：类型”的形式显示指定该变量的类型，要么为该变量指定初始值-kotlin编译器会根据初始值确定变量的类型。不能声明变量时既不指定变量类型、也不指定变量的初始值。</p><p>常量：</p><p>​        局部范围的常量：允许在声明时不指定初始值，只要在第一次使用之前指定初始值就可以。</p><p>​        类的常量属性：这种常量属性既可以在声明时指定初始值，也可以在类或结构体的构造器中指定初始值。</p><p>kotlin程序编译的字节码必须遵守JVM规范，直接在kotlin程序中定义变量、函数，kotlinc将会自动生成一个名为“文件名首字母大写+Kt”的类，并将变量转换为该类的静态getter、setter方法（val声明的只有getter方法），函数转换为该类的静态方法。</p><p>null安全：只有可空类型的变量或常量才能接受null，非空类型的变量或常量不能接受null。</p><p>kotlin对可空类型进行了限制，可空类型不允许直接调用方法、访问属性。需要先判断该变量不为null，然后再调用该变量的方法和属性。kotlin：“！！”强制调用可空变量的方法和属性，可能引发NPE</p><h5 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h5><p>​        kotlin中的字符串有两种字面值：</p><p>​            转义字符串：可以有转义字符，转移字符串很像普通的java字符串。</p><p>​            原始字符串：可以包含换行和任意文本，原始字符串需要3个引号引起来。</p><p>​        字符串模板：允许在字符串中嵌入变量或表达式，只要将变量或表达式放入${}中，kotlin会把该变量或表达式的值嵌入该字符串中。</p><h5 id="类型别名："><a href="#类型别名：" class="headerlink" title="类型别名："></a>类型别名：</h5><p>​        kotlin提供typealias来定义类型别名。</p><p>​        typealias 类型别名 = 已有类型</p><h2 id="第三章：运算符和表达式"><a href="#第三章：运算符和表达式" class="headerlink" title="第三章：运算符和表达式"></a>第三章：运算符和表达式</h2><p>java支持的运算符包括算数运算符、赋值运算符、扩展后的赋值运算符、比较运算符、逻辑运算符。kotlin也完全支持。</p><p>kotlin不支持三目运算符，kotlin使用if表达式代替了三目运算符。kotlin的运算符都是以方法形式实现的。</p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划总结</title>
      <link href="2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈动态规划"><a href="#浅谈动态规划" class="headerlink" title="浅谈动态规划"></a>浅谈动态规划</h1><h2 id="演变过程："><a href="#演变过程：" class="headerlink" title="演变过程："></a>演变过程：</h2><p>​        动态规划的演变过程：暴力递归—&gt;记忆化搜索—&gt;动态规划。前提是该问题是一个“无后效性”问题。</p><h2 id="无后效性："><a href="#无后效性：" class="headerlink" title="无后效性："></a>无后效性：</h2><p>​        无后效性是指：当某阶段的状态一旦确定，此后的决策过程和最终结果将不受此前的各种状态所影响。可以简单理解为当编写好一个递归函数后，当可变参数确定后，结果是唯一可确定的。</p><p>​        当尝试用【动态规划】解决问题的时候，首先要关注该问题是否为一个“无后效性问题”。</p><h2 id="参考：宫水三叶的刷题笔记（大家可以微信关注公众号，十分推荐）"><a href="#参考：宫水三叶的刷题笔记（大家可以微信关注公众号，十分推荐）" class="headerlink" title="参考：宫水三叶的刷题笔记（大家可以微信关注公众号，十分推荐）"></a>参考：宫水三叶的刷题笔记（大家可以微信关注公众号，十分推荐）</h2><h1 id="leetcode62"><a href="#leetcode62" class="headerlink" title="leetcode62."></a>leetcode62.</h1><p>给定一个 m*n的矩阵，从左上角作为起点，到达右下角共有多少条路径（机器人只能往右或者往下进行移动）。</p><h2 id="暴力递归解法："><a href="#暴力递归解法：" class="headerlink" title="暴力递归解法："></a>暴力递归解法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int paths(int m, int n)&#123;</span><br><span class="line">        return recursive(m, n, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int recursive(int m, int n, int i, int j)&#123;</span><br><span class="line">        if (i == m - 1 || j == n - 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure><h2 id="记忆化搜索："><a href="#记忆化搜索：" class="headerlink" title="记忆化搜索："></a>记忆化搜索：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int paths(int m, int n)&#123;</span><br><span class="line">       int[][] cache = new int[m][n];</span><br><span class="line">       for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">           int[] ints = new int[n];</span><br><span class="line">           Arrays.fill(ints, -1);</span><br><span class="line">           cache[i] = ints;</span><br><span class="line">       &#125;</span><br><span class="line">       return recursive(m, n, 0, 0, cache);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static int recursive(int m, int n, int i, int j, int[][] cache) &#123;</span><br><span class="line">       if (i == m - 1 || j == n - 1)&#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (cache[i][j] == -1)&#123;</span><br><span class="line">           if (cache[i + 1][j] == -1)&#123;</span><br><span class="line">               cache[i + 1][j] = recursive(m, n, i + 1, j, cache);</span><br><span class="line">           &#125;</span><br><span class="line">           if (cache[i][j + 1] == -1)&#123;</span><br><span class="line">               cache[i][j + 1] = recursive(m, n, i, j + 1, cache);</span><br><span class="line">           &#125;</span><br><span class="line">           cache[i][j] = cache[i + 1][j] + cache[i][j + 1];</span><br><span class="line">       &#125;</span><br><span class="line">       return cache[i][j];</span><br></pre></td></tr></table></figure><p>分析：其实整个求解过程，对于每个情况（每个点）的访问次数并没有发生改变。</p><p>只是从「以前的每次访问都进行求解」改进为「只有第一次访问才真正求解」。</p><p>事实上，我们通过查看 <code>recursive()</code> 方法就可以发现：当我们求解某一个点（i，j） 的答案时，其实是依赖于（i， j +1） 和（i + 1，j） 。也就是每求解一个点的答案，都需要访问两个点的结果。</p><p>这种情况是由于我们采用的是“自顶向下”的解决思路所导致的。我们无法直观确定哪个点的结果会在什么时候被访问，被访问多少次。所以我们不得不使用一个与矩阵相同大小的数组，将所有中间结果“缓存”起来。换句话说，「记忆化搜索」解决的是重复计算的问题，并没有解决结果访问时机和访问次数的不确定问题。</p><h2 id="次优解版本的记忆化搜索："><a href="#次优解版本的记忆化搜索：" class="headerlink" title="次优解版本的记忆化搜索："></a>次优解版本的记忆化搜索：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private int[][] cache;</span><br><span class="line"></span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        cache = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            int[] ints = new int[n];</span><br><span class="line">            Arrays.fill(ints, -1);</span><br><span class="line">            cache[i] = ints;</span><br><span class="line">        &#125;</span><br><span class="line">        return recursive(m, n, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int recursive(int m, int n, int i, int j) &#123;</span><br><span class="line">        if (i == m - 1 || j == n - 1) return 1;</span><br><span class="line">        if (cache[i][j] == -1) &#123;</span><br><span class="line">            cache[i][j] = recursive(m, n, i + 1, j) + recursive(m, n, i, j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要区别在于 <code>if (cache[i][j] == -1)</code> 的判断里面。</p><p>在我提供解决方案中，会在计算 <code>cache[i][j]</code> 时，尝试从“缓存”中读取 <code>cache[i+1][j]</code> 和 <code>cache[i][j+1]</code>，确保每次调用 <code>recursive()</code> 都是必须的，不重复的。</p><p>网上大多数的解决方案只会在外层读取“缓存”，在真正计算 <code>cache[i][j]</code> 的时候并不采取先检查再调用的方式，直接调用 <code>recursive()</code> 计算子问题 。</p><p>虽然两者相比与直接的「暴力递归」都大大减少了计算次数（<code>recursive()</code> 的访问次数），但后者的计算次数显然要比前者高上不少。</p><p>建议你在「记忆化搜索」的解决方案时，采取第一种策略：</p><p><strong>确保在每次访问递归函数时先去“缓存”检查。尽管这有点“不美观”，但它能发挥「记忆化搜索」的最大作用。</strong></p><h2 id="从【自顶向下】到自底向上"><a href="#从【自顶向下】到自底向上" class="headerlink" title="从【自顶向下】到自底向上"></a>从【自顶向下】到自底向上</h2><h1 id="浅谈动态规划2"><a href="#浅谈动态规划2" class="headerlink" title="浅谈动态规划2"></a>浅谈动态规划2</h1><p>动态规划中的每个状态一定是上一个状态推导出来的，贪心没有状态推导，而是直接从局部直接选最优的。</p><p><strong>1.确定dp数组以及下标的含义</strong></p><p><strong>2.确定递推公式</strong></p><p><strong>3.dp数组如何初始化</strong></p><p><strong>4.确定遍历顺序</strong></p><p>5.举例推导dp数组</p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p><p>示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p><p>示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//第一步确定dp数组以及下标含义</span><br><span class="line"> //递推公式</span><br><span class="line"> //dp数组如何初始化</span><br><span class="line"> //确定遍历顺序</span><br><span class="line"> //举例推导dp数组</span><br><span class="line"> public static int dp(int n)&#123;</span><br><span class="line">     int[] dp = new int[n];</span><br><span class="line">     dp[0] = 0;</span><br><span class="line">     dp[1] = 1;</span><br><span class="line">     for (int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">         dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">     &#125;</span><br><span class="line">     return dp[n - 1];</span><br><span class="line"> &#125;</span><br><span class="line"> public static int dp(int n)&#123;</span><br><span class="line">     if (n == 0) return 0;</span><br><span class="line">     if (n == 1) return 1;</span><br><span class="line">     int pre1 = 1, pre2 = 0, ans = 0;</span><br><span class="line">     for (int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">         ans = pre1 +pre2;</span><br><span class="line">         pre2 = pre1;</span><br><span class="line">         pre1 = ans;</span><br><span class="line">     &#125;</span><br><span class="line">     return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶</li><li> 2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶 + 1 阶</li><li> 1 阶 + 2 阶</li><li> 2 阶 + 1 阶</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//确定dp数组及下标含义。dp[i],含义是到第i层，有多少种方法</span><br><span class="line">    //递推公式。dp【i】 = dp【i- 1】 + dp【i- 2】</span><br><span class="line">    //如何初始化。dp【1】 = 1， dp【2】 = 2</span><br><span class="line">    //确定遍历顺序，顺序从底向上</span><br><span class="line">    //手动模拟</span><br><span class="line">    public static int dp1(int n)&#123;</span><br><span class="line">        if(n &lt;= 1) return n;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 2;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    public static int dp2(int n)&#123;</span><br><span class="line">        if(n &lt;= 2) return n;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int pre1 = 2, pre2 = 1;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            ans = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h1><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：</p><p>输入：cost = [10, 15, 20]<br>输出：15<br>解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。<br> 示例 2：</p><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出：6<br>解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>解析：这里最后一步登顶的花费不用算。从最后两步登顶需要花费</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">    if (cost == null || cost.length == 0)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if (cost.length == 1)&#123;</span><br><span class="line">          return cost[0];</span><br><span class="line">      &#125;</span><br><span class="line">      int[] dp = new int[cost.length];</span><br><span class="line">      dp[0] = cost[0];</span><br><span class="line">      dp[1] = cost[1];</span><br><span class="line">      for (int i = 2; i &lt; cost.length; i++)&#123;</span><br><span class="line">          dp[i] = Math.min(dp[i - 1], dp[i - 2]) +cost[i];</span><br><span class="line">      &#125;</span><br><span class="line">      return Math.min(dp[cost.length - 1], dp[cost.length - 2]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//确定dp数组下标以及含义。dp[i][j]，到达ij有多少条路径</span><br><span class="line">    //递推公式：dp【i】【j】 = dp[i - 1][j] + dp[i][j - 1]，如果到达最后一行或者最后一列，只能向右或者向下下</span><br><span class="line">    //初始化dp【i】【0】=1，dp【0】【j】 = 1</span><br><span class="line">    //确定遍历顺序：从左到右一层一层遍历</span><br><span class="line">    public static int uniquePaths(int m, int n)&#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="63-不同路径二"><a href="#63-不同路径二" class="headerlink" title="63.不同路径二"></a>63.不同路径二</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//确定dp数组及下标含义。dp[i][j]，表示从开始到ij，总共有多少条路径</span><br><span class="line">    //确定递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - 1].并且有障碍物的地方为0.</span><br><span class="line">    //确定初始化。dp[i][0] = 1, dp[0][j] = 1.但是有障碍的地方为0.</span><br><span class="line">    //确定遍历顺序，从左到右依次遍历</span><br><span class="line">    //手动模拟</span><br><span class="line">    public static int unique(int[][] obstacleGrid)&#123;</span><br><span class="line">        int m = obstacleGrid.length, n = obstacleGrid[0].length;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++)&#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++)&#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                if (obstacleGrid[i][j] == 1) continue;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h1><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。<br>示例 2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p><p>从暴力递归到记忆化搜索到动态规划的过程，可以参考<a href="https://leetcode-cn.com/problems/integer-break/solution/bao-li-sou-suo-ji-yi-hua-sou-suo-dong-tai-gui-hua-/">https://leetcode-cn.com/problems/integer-break/solution/bao-li-sou-suo-ji-yi-hua-sou-suo-dong-tai-gui-hua-/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> //暴力递归</span><br><span class="line">    //暴力递归思路：对于每个数，可以分成2个，三个，四个等(从1~n-2开始尝试)</span><br><span class="line">    public static int integerBreakDiGui(int n)&#123;</span><br><span class="line">        if (n &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n - 1; i++)&#123;</span><br><span class="line">            ans = Math.max(ans, Math.max(i * (n - i), i * integerBreakDiGui(n - i)));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //记忆化搜索</span><br><span class="line">    //记忆化搜索思路：因为暴力递归的过程有很多重复计算，但是并没有减少遍历的次数。</span><br><span class="line">    public static int integerBreakMemory(int n)&#123;</span><br><span class="line">        if (n &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] cache = new int[n + 1];</span><br><span class="line">        cache[2] = 1;</span><br><span class="line">        if (cache[n] != 0)&#123;</span><br><span class="line">            return cache[n];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果当前cache【n】没有的话，就需要自己求。怎么求还是暴力递归</span><br><span class="line">        int curMax = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n - 1; i++)&#123;</span><br><span class="line">            curMax = Math.max(curMax, Math.max(i * (n - i), i * integerBreakMemory(n - i)));</span><br><span class="line">        &#125;</span><br><span class="line">        cache[n] = curMax;</span><br><span class="line">        return cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">//动态规划思路：但是对于这样的一个递归代码，我们更习惯转化为递推，</span><br><span class="line">// 将自顶向下的思路转换为自底向上，这也是记忆化搜索和DP之间的区别所在。</span><br><span class="line">    public static int integerBreakDp(int n)&#123;</span><br><span class="line">        if (n &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[n + 2];</span><br><span class="line">        dp[2] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">            int curMax = -1;</span><br><span class="line">            for (int j = 1; j &lt;= i - 1; j++)&#123;</span><br><span class="line">                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="剑指offer42：连续子数组的最大和"><a href="#剑指offer42：连续子数组的最大和" class="headerlink" title="剑指offer42：连续子数组的最大和"></a>剑指offer42：连续子数组的最大和</h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>暴力递归：遍历数组，以i为子数组开始的所有子数组。并且比较大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">    int ans = Integer.MIN_VALUE;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        for (int j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum = sum + nums[j];</span><br><span class="line">            if (sum &gt; ans)&#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>如果当前子数组加上下一位变小了，说明需要重新选择子数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">        int currSum = 0;</span><br><span class="line">        int maxSum = Integer.MIN_VALUE;       //全负情况，返回最大数</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            currSum = (nums[j] &gt; currSum + nums[j]) ? nums[j] : currSum + nums[j];</span><br><span class="line">            maxSum = (maxSum &gt; currSum) ? maxSum : currSum;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转换成动态规划的过程：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        for(int j = 1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(dp[j-1]&gt;0)&#123;</span><br><span class="line">                dp[j] = dp[j-1]+nums[j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[j] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            if(dp[i]&gt;max)</span><br><span class="line">                max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br>示例 2：</p><p>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。<br>示例 3：</p><p>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin</title>
      <link href="2021/06/24/kotlin/"/>
      <url>2021/06/24/kotlin/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-docs（基本语法）"><a href="#Kotlin-docs（基本语法）" class="headerlink" title="Kotlin-docs（基本语法）"></a>Kotlin-docs（基本语法）</h1><p>包的定义和导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包的声明应处于源文件的顶部：</span><br><span class="line">package my.demo</span><br><span class="line">import kotlin.txt</span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kotlin的入口点是main函数</span><br><span class="line">带有两个Int参数、返回Int的函数</span><br><span class="line">fun sum(a: Int, b: Int): Int&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">将表达式作为函数体、返回值类型自动推断的函数</span><br><span class="line">fun sum(a: Int, b: Int) = a + b</span><br><span class="line">函数返回无意义的值：</span><br><span class="line">fun printSum(a: Int, b: Int): Unit&#123;</span><br><span class="line">println(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">Unit返回类型可以省略</span><br><span class="line">fun printSum(a: Int, b: Int)&#123;</span><br><span class="line">printLn(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var maximun:Int = 5</span><br><span class="line">变量定义关键字 变量名 类型定义 赋值运算符 赋值</span><br><span class="line">简写：var maximun = 5</span><br><span class="line">变量名关键字 变量名 赋值运算符 赋值（相比少了一个类型定义，因为kotlin可以进行类型推断）</span><br><span class="line"></span><br><span class="line">var关键字修饰的是可修改变量</span><br><span class="line">val关键字修饰的是只读变量</span><br><span class="line"></span><br><span class="line">类型推断：对与以声明并赋值的变量，允许省略类型定义</span><br><span class="line"></span><br><span class="line">定义只读局部变量使用关键字val定义，只能为其赋值一次</span><br><span class="line">val a: Int = 1//立即赋值</span><br><span class="line">val b = 2//自动推断出Int类型</span><br><span class="line">val c: Int //如果没有初始值类型不能省略</span><br><span class="line">c = 3 //明确赋值</span><br><span class="line"></span><br><span class="line">可重新赋值的变量使用var关键字</span><br><span class="line">var x = 5 //自动推断出Int类型</span><br><span class="line">x += 1</span><br><span class="line">顶层变量</span><br><span class="line">val PI = 3.14</span><br><span class="line">var x = 0</span><br><span class="line">fun incre()&#123;</span><br><span class="line">x += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时常量：只能定义在函数之外，因为编译时常量必须在编译时赋值，函数都是在运行时才调用，函数内的变量是在运行时赋值，编译时常量要在这些变量赋值前就已经存在。</p><p>编译时常量只能是常见的基本数据类型：String、Int、Double、Float、Long、Short、Byte、Char、Boolean</p><p>kotlin只提供引用类型这一种数据类型，但是kotlin编译器会在java字节码中改用基本数据类型</p><p>空值和null检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当某个变量的值可以为null的时候，必须在声明处的类型后添加？，来标识该引用可以为空</span><br><span class="line">fun parseInt(str: String): Int?&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型检测与自动类型转换:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is运算符检测一个表达式是否某类型的一个实例。如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显示转换。</span><br><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">if (obj is String) &#123;</span><br><span class="line">// `obj` 在该条件分⽀内⾃动转换成`String`</span><br><span class="line">return obj.length</span><br><span class="line">&#125;</span><br><span class="line">// 在离开类型检测分⽀后，`obj` 仍然是`Any` 类型</span><br><span class="line">return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>for循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;,&quot;kiwifruit&quot;)</span><br><span class="line">for(item in items)&#123;</span><br><span class="line">println(item)</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">for (index in items.indices) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>while循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">var index = 0</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>when表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun describe(obj: Any): String =</span><br><span class="line">when (obj) &#123;</span><br><span class="line">1 -&gt; &quot;One&quot;</span><br><span class="line">&quot;Hello&quot; -&gt; &quot;Greeting&quot;</span><br><span class="line">is Long -&gt; &quot;Long&quot;</span><br><span class="line">!is String -&gt; &quot;Not a string&quot;</span><br><span class="line">else -&gt; &quot;Unknown&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用区间（range）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">使用in运算符来检测某个数字是否在指定区间内</span><br><span class="line">val x = 10</span><br><span class="line">val y = 9</span><br><span class="line">if (x in 1..y+1) &#123;</span><br><span class="line">println(&quot;fits in range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">检测某个数字是否在指定区间外：</span><br><span class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">if (-1 !in 0..list.lastIndex) &#123;</span><br><span class="line">println(&quot;-1 is out of range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if (list.size !in list.indices) &#123;</span><br><span class="line">println(&quot;list size is out of valid list indices range, too&quot;)</span><br><span class="line">&#125;</span><br><span class="line">区间迭代：</span><br><span class="line">for (x in 1..5) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">数列迭代：</span><br><span class="line">for (x in 1..10 step 2) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line">for (x in 9 downTo 0 step 3) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="kotlin小知识点"><a href="#kotlin小知识点" class="headerlink" title="kotlin小知识点"></a>kotlin小知识点</h1><h5 id="强类型语言："><a href="#强类型语言：" class="headerlink" title="强类型语言："></a>强类型语言：</h5><p>​        一旦某一个变量被定义类型，如果不经过强制转换，就永远是该数据类型</p><h5 id="弱类型语言："><a href="#弱类型语言：" class="headerlink" title="弱类型语言："></a>弱类型语言：</h5><p>​        某一个变量被定义类型，该变量可以根据环境变化自动变化。</p><h5 id="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"><a href="#强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。" class="headerlink" title="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"></a>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</h5><h5 id="动态类型语言："><a href="#动态类型语言：" class="headerlink" title="动态类型语言："></a>动态类型语言：</h5><p>​        动态性语言是指在运行期间才去做数据类型检查的语言，也就是动态类型语言编程时，永远不用给任何变量指定数据类型。该语言会在第一次赋值给变量时，在内部将数据类型记录下来。python、ruby</p><h5 id="静态类型语言："><a href="#静态类型语言：" class="headerlink" title="静态类型语言："></a>静态类型语言：</h5><p>​        数据类型在编译期间检查，也就是在写程序的时候要声明变量的数据类型。</p><h5 id="kotlin中的常量问题？"><a href="#kotlin中的常量问题？" class="headerlink" title="kotlin中的常量问题？"></a><em><u>kotlin中的常量问题？</u></em></h5><h5 id="kotlin是null安全的语言："><a href="#kotlin是null安全的语言：" class="headerlink" title="kotlin是null安全的语言："></a>kotlin是null安全的语言：</h5><p>​        Byte、Short、Int、Long型变量都不能接受null值，如果要存储null值，应该使用Byte？、Short？、Int？、Long？类型（相当于支持null值的对应类型）。</p><p>​        加不加？后缀的另一个区别：普通类型的整形变量将会映射成java的基本类型，带？后缀的整形变量将会映射成基本类型的包装类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">val pm1 = 200;</span><br><span class="line">val pm2 = 200;</span><br><span class="line">println(pm1 == pm2);</span><br><span class="line">println(pm1 === pm2)</span><br><span class="line"></span><br><span class="line">val ob1: Int? = 200</span><br><span class="line">val ob2: Int? = 200</span><br><span class="line">println(ob1 == ob2)</span><br><span class="line">println(ob1 === ob2)</span><br><span class="line"></span><br><span class="line">val  ob3: Int? = 100</span><br><span class="line">val  ob4: Int? = 100</span><br><span class="line">println(ob3 == ob4)</span><br><span class="line">println(ob3 === ob4)</span><br><span class="line">结果如下：</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS服务和参数</title>
      <link href="2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/"/>
      <url>2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"><a href="#ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。" class="headerlink" title="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"></a>ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。</h2><h1 id="使用rosservice"><a href="#使用rosservice" class="headerlink" title="使用rosservice"></a>使用rosservice</h1><p>rosservice可以很容易通过服务附加到ROS客户端/服务器框架上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rosservice list         输出活跃服务的信息</span><br><span class="line">rosservice call         用给定的参数调用服务</span><br><span class="line">rosservice type         输出服务的类型</span><br><span class="line">rosservice find         按服务的类型查找服务</span><br><span class="line">rosservice uri          输出服务的ROSRPC uri</span><br></pre></td></tr></table></figure><p>rosservice type [service]:进一步查看服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /clear</span><br><span class="line">结果是：std_srvs/Empty</span><br></pre></td></tr></table></figure><p>服务的类型为empty，表明调用这个服务时不需要参数。（它在发出<strong>请求</strong>时不发送数据，在接收<strong>响应</strong>时也不接收数据）</p><p>rosservice call [service] [args]:call命令调用服务，args是给定的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear：</span><br><span class="line">call:表明调用clear服务</span><br></pre></td></tr></table></figure><p>查看spawn（产卵）服务的信息，此服务具有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /spawn | rossrv show</span><br></pre></td></tr></table></figure><p>​        spawn服务的参数：name字段是可选的        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">string name</span><br><span class="line">---</span><br><span class="line">string name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn 2 2 0.2 &quot;&quot;</span><br><span class="line">调用spawn服务，并且需要参数。</span><br><span class="line">clear服务不需要参数</span><br></pre></td></tr></table></figure><h1 id="使用rosparam"><a href="#使用rosparam" class="headerlink" title="使用rosparam"></a>使用rosparam</h1><p><code>rosparam</code>能让我们在ROS[参数服务器（Parameter Server）](<a href="http://wiki.ros.org/Parameter">http://wiki.ros.org/Parameter</a> Server)上存储和操作数据。参数服务器能够存储整型（integer）、浮点（float）、布尔（boolean）、字典（dictionaries）和列表（list）等数据类型。rosparam使用YAML标记语言的语法。一般而言，YAML的表述很自然：<code>1</code>是整型，<code>1.0</code>是浮点型，<code>one</code>是字符串，<code>true</code>是布尔型，<code>[1, 2, 3]</code>是整型组成的列表，<code>&#123;a: b, c: d&#125;</code>是字典。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS话题</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="理解ROS话题（乌龟走动幕后的故事）"><a href="#理解ROS话题（乌龟走动幕后的故事）" class="headerlink" title="理解ROS话题（乌龟走动幕后的故事）"></a>理解ROS话题（乌龟走动幕后的故事）</h1><p>roscore：只运行一个roscore就够了。</p><p>乌龟走动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个新终端：roscore</span><br><span class="line">新终端：rosrun turtlesim turtlesim_node</span><br><span class="line">新终端：rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><h2 id="ROS话题："><a href="#ROS话题：" class="headerlink" title="ROS话题："></a>ROS话题：</h2><p>​            turtlesim_node节点和turtle_teleop_key节点之间通过ROS话题相互通信。turtle_teleop_key在话题上发布键盘按下的信息，turtlesim_node订阅该话题以接收消息。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure><p>上述命令之后，rqt_graph会用动态的图显示系统中发生的事情。</p><h2 id="rostopic：rostopic命令工具能获取ROS话题的信息。"><a href="#rostopic：rostopic命令工具能获取ROS话题的信息。" class="headerlink" title="rostopic：rostopic命令工具能获取ROS话题的信息。"></a>rostopic：rostopic命令工具能获取ROS话题的信息。</h2><p>rostopic -h：查看可用的rostopic的子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">        rostopic bw     display bandwidth used by topic</span><br><span class="line">        rostopic delay  display delay of topic from timestamp in header</span><br><span class="line">        rostopic echo   print messages to screen</span><br><span class="line">        rostopic find   find topics by type</span><br><span class="line">        rostopic hz     display publishing rate of topic    </span><br><span class="line">        rostopic info   print information about active topic</span><br><span class="line">        rostopic list   list active topics</span><br><span class="line">        rostopic pub    publish data to topic</span><br><span class="line">        rostopic type   print topic or field type</span><br></pre></td></tr></table></figure><p>rostopic echo [topic]:查看在某个话题上发布的数据。（也就是去订阅了话题）</p><p>rostopic list -h：查看可用的rostopic list子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -b BAGFILE, --bag=BAGFILE</span><br><span class="line">                        list topics in .bag file</span><br><span class="line">  -v, --verbose         list full details about each topic</span><br><span class="line">  -p                    list only publishers</span><br><span class="line">  -s                    list only subscribers</span><br></pre></td></tr></table></figure><p>rostopic list -v：会列出所有发布者和订阅的主题及其类型的相关信息。</p><h1 id="ROS消息"><a href="#ROS消息" class="headerlink" title="ROS消息"></a>ROS消息</h1><p>话题的通信是通过节点间发送ROS消息实现的。为了使发布者和订阅者进行通信，发布者和订阅者必须发送和接收相同类型的消息。所以话题的类型是由发布在上面的消息的类型决定的。</p><p>rostopic type 【topic】:查看所发布话题的消息类型。    </p><p>​        使用rosmsg show  【geometry_msgs/Twist】查看消息的详细信息。</p><h2 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic:"></a>rostopic:</h2><p>rostopic pub 【topic】【msg_type】【args】:把数据发布到当前某个正在广播的话题上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, 1.8]&#x27;</span><br></pre></td></tr></table></figure><p>rostopic pub:将消息发布到指定的话题。</p><p>-1：让rostopic只发布一条消息，然后退出</p><p>/turtle1/cmd_vel：要发布到的话题的名称</p><p>geometry_msgs/Twist：发布到话题时要使用的消息的类型</p><p>–：两个破折号，用来告诉解析器，之后的参数都不是选项</p><p>如前所述，一个turtlesim/Velocity消息有两个浮点型元素：<code>linear</code>和<code>angular</code>。在本例中，<code>&#39;[2.0, 0.0, 0.0]&#39;</code>表示<code>linear</code>的值为<code>x=2.0</code>, <code>y=0.0</code>, <code>z=0.0</code>，而<code>&#39;[0.0, 0.0, 1.8]&#39;</code>是说<code>angular</code>的值为<code>x=0.0</code>, <code>y=0.0</code>, <code>z=1.8</code>。这些参数实际上使用的是YAML语法，在<a href="http://wiki.ros.org/ROS/YAMLCommandLine">YAML命令行文档</a>中有描述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, -1.8]&#x27;</span><br></pre></td></tr></table></figure><p>turtle以一个稳定的频率为1Hz的指令流才能保持移动状态。我们可以使用<code>rostopic pub -r</code>命令来发布源源不断的命令。</p><p>rostopic hz 【topic】：报告数据发布的速率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic type /turtle1/cmd_vel | rosmsg show</span><br></pre></td></tr></table></figure><p>结合rostopic、type、rosmsg show、命令来获取关于某个话题的更深层次的信息。</p><h1 id="使用rqt-plot"><a href="#使用rqt-plot" class="headerlink" title="使用rqt_plot"></a>使用rqt_plot</h1><p><code>rqt_plot</code>命令可以在滚动时间图上显示发布到某个话题上的数据。这里我们将使用<code>rqt_plot</code>命令来绘制正被发布到<code>/turtle1/pose</code>话题上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS节点</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p>计算图是一个由ROS进程组成的点对点网络，能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Services）、话题（Topics）、包（Bags）。</p><p>节点：是ROS软件包中的一个可执行文件，可以通过ROS来与其他节点通信。</p><p>​            ROS节点使用ROS客户端与其他节点通信。节点可以发布或订阅话题，也可以提供或使用服务。</p><p>消息：订阅或发布话题时所使用的的ROS数据类型。</p><p>话题：节点可以将消息发布到话题或者通过订阅话题来接收消息。</p><p>主节点：ROS的命名服务，帮助节点发现彼此。</p><p>rosout：相当于stdout/stderr（标准输出、标准错误）</p><p>​                rosout节点，用于收集和记录节点的调试输出，所以总是在运行。</p><p>roscore：主节点+rosout+参数服务器</p><p>​                运行所有ROS程序前需要运行的命令。</p><p>客户端库：ROS客户端库可以让不同编程语言编写的节点进行相互通信</p><p>​                    rospy=python客户端库</p><p>​                    roscpp=c++客户端库</p><p>rosnode:获取接地那信息的ros工具</p><p>​                rosnode list：列出活动的节点</p><p>​                rosnode info：返回某个节点的信息。rosnode info /rosout</p><p>​                rosnode cleanup：尝试清除rosnode列表</p><p>rosrun：运行给定的软件包中的节点</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terminator常用快捷键</title>
      <link href="2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //移动到上面的终端</span><br><span class="line">Alt+Down                        //移动到下面的终端</span><br><span class="line">Alt+Left                        //移动到左边的终端</span><br><span class="line">Alt+Right                       //移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line">Ctrl+Shift+S                    //隐藏/显示滚动条</span><br><span class="line">Ctrl+Shift+F                    //搜索</span><br><span class="line">Ctrl+Shift+C                    //复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V                    //粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+W                    //关闭当前终端</span><br><span class="line">Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭</span><br><span class="line">Ctrl+Shift+X                    //最大化显示当前终端</span><br><span class="line">Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大</span><br><span class="line">Ctrl+Shift+N or Ctrl+Tab        //移动到下一个终端</span><br><span class="line">Ctrl+Shift+P or Ctrl+Shift+Tab  //Crtl+Shift+Tab 移动到之前的一个终端</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="标签之间的操作"><a href="#标签之间的操作" class="headerlink" title="标签之间的操作"></a>标签之间的操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F11                             //全屏开关</span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line">Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置</span><br><span class="line">Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置</span><br><span class="line">Ctrl+Plus (+)                   //增大字体</span><br><span class="line">Ctrl+Minus (-)                  //减小字体</span><br><span class="line">Ctrl+Zero (0)                   //恢复字体到原始大小</span><br><span class="line">Ctrl+Shift+R                    //重置终端状态</span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line">Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端</span><br><span class="line">Super+Shift+G                   //解除绑定</span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line">Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程</span><br><span class="line">Super+i                         //打开一个新窗口，新窗口与原来的窗口使用不同的进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS软件包</title>
      <link href="2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
      <url>2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="创建ROS软件包"><a href="#创建ROS软件包" class="headerlink" title="创建ROS软件包"></a>创建ROS软件包</h1><ol><li><p>catkin软件包的组成：</p><ol><li>必须有一个符合catkin规范的package.xml文件。</li><li>必须有一个CMakeLists.txt文件</li><li>每个包必须有自己的目录。同一目录下不能嵌套或者多个软件包存在</li></ol></li><li><p>catkin工作空间中的软件包</p><ol><li><p>推荐使用catkin工作空间，也可以单独开发catkin软件包</p></li><li><p>创建软件包之前需要创建工作空间</p></li><li><pre><code>workspace_folder/        -- WORKSPACE  src/                   -- SOURCE SPACE    CMakeLists.txt       -- &#39;Toplevel&#39; CMake file, provided by catkin    package_1/      CMakeLists.txt     -- CMakeLists.txt file for package_1      package.xml        -- Package manifest for package_1    ...    package_n/      CMakeLists.txt     -- CMakeLists.txt file for package_n      package.xml        -- Package manifest for package_n<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 创建catkin软件包（功能包）</span><br><span class="line"></span><br><span class="line">   1. 切换到catkin工作空间中的源文件空间目录</span><br><span class="line"></span><br></pre></td></tr></table></figure> cd ~/catkin_ws/src<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用catkin_create_pkg命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>catkin_create_pkg catkin软件包名 std_msgs rospy roscpp<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      catkin软件包内包含[package.xml](http://wiki.ros.org/catkin/package.xml)文件和一个[CMakeLists.txt](http://wiki.ros.org/catkin/CMakeLists.txt)文件，文件中有执行catkin_create_pkg命令时提供的信息。</span><br><span class="line"></span><br><span class="line">      std_msgs rospy roscpp三个包是依赖。</span><br><span class="line"></span><br><span class="line">4. 包依赖关系</span><br><span class="line"></span><br><span class="line">   1. 一级依赖</span><br><span class="line">   2. 间接依赖</span><br><span class="line"></span><br><span class="line"># 构建ROS软件包</span><br><span class="line"></span><br><span class="line">在catkin工作空间构建ros软件包</span><br><span class="line"></span><br><span class="line">catkin_make:是一个命令行工具，它简化了标准catkin工作流程。你可以认为`catkin_make`是在标准CMake工作流程中依次调用了`cmake`和`make`。</span><br><span class="line"></span><br></pre></td></tr></table></figure>#在catkin工作空间下catkin_make<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">build:构建空间的默认位置，同时cmake和make在这里被调用用来配置和构建软件包。</span><br><span class="line"></span><br><span class="line">devel：开发空间的默认位置，在安装软件包之前，这里存放可执行文件和库。</span><br><span class="line"></span><br><span class="line">src：源码文件</span><br><span class="line"></span><br><span class="line"># 创建ROS工作空间（先于创建ROS软件包）</span><br><span class="line"></span><br></pre></td></tr></table></figure>$ mkdir -p ~/工作空间名/src$ cd ~/catkin_ws/$ catkin_make</code></pre></li></ol></li></ol><p>catkin_make命令：在工作空间第一次运行的时候，会在src目录下创建CMakeLists.txt链接。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS文件系统</title>
      <link href="2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>软件包（packages）：包是ROS代码的软件组织单元，每个软件包都可以包含程序库、可执行文件、脚本或其他构件。</p><p>Manifests（package.xml）:清单是对软件包的描述，用于定义软件包之间的依赖关系，并记录有关软件包的元信息。如版本、维护者、许可证</p><h1 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h1><p>ROS提供了专门的命令工具来实现ros软件包的查找和导航。</p><ul><li><p>rospack：获取软件包的有关信息。find选项返回软件包所在路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack find roscpp</span><br></pre></td></tr></table></figure><p>结果：/opt/ros/<distro>/share/roscpp</distro></p></li><li><p>roscd:直接切换目录到某个软件包或者软件包集中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd roscpp</span><br><span class="line">roscd roscpp/cmake</span><br></pre></td></tr></table></figure><p>只能切换到那些路径包含在ROS_PACKAGE_PATH环境变量中的软件包。</p></li><li><p>roscd log:进入存储ROS日志文件的目录，如果没有执行过任何ROS程序，系统会报错说该目录不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd log</span><br></pre></td></tr></table></figure></li><li><p>rosls: 允许直接按软件包的名称执行，而不必输入绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosls roscpp_tutorials</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="VIM常用命令："><a href="#VIM常用命令：" class="headerlink" title="VIM常用命令："></a>VIM常用命令：</h1><h2 id="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"><a href="#vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。" class="headerlink" title="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"></a>vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。</h2><p>命令模式（一般模式）：启动vim就进入了命令模式。此时键盘动作被识别为命令，比如：i切换到输入模式、x删除当前光标所在处的字符、：切换到底线命令模式、u撤回上一步的操作。</p><p>输入模式（编辑模式）：ESC键退出输入模式，切换到命令模式。</p><p>底线命令模式：命令模式下按:（英文）进入底线命令模式。q退出程序、w保存文件、ESC退出底线命令模式。</p><p>搜索替换：命令模式下，（/word，代表向光标之下寻找一个字符串）（？word，代表向光标之上寻找一个字符串），n代表重复前一个搜索动作，N反向搜索的动作。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rosDay1</title>
      <link href="2021/06/03/rosDay1/"/>
      <url>2021/06/03/rosDay1/</url>
      
        <content type="html"><![CDATA[<h1 id="helloworld实现过程（C-）："><a href="#helloworld实现过程（C-）：" class="headerlink" title="helloworld实现过程（C++）："></a>helloworld实现过程（C++）：</h1><p>1.创建工作空间并编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 工作空间名称/src</span><br><span class="line">cd 工作空间</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>首先会创建一个工作空间和一个src子目录，进入工作空间调用catkin_make命令编译。</p><p>2.进入工作空间下的src目录，创建ros功能包并添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src</span><br><span class="line">catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure><p>会在工作空间下生成一个功能包，该功能包依赖于 roscpp、rospy 与 std_msgs，其中roscpp是使用C++实现的库，而rospy则是使用python实现的库，std_msgs是标准消息库，创建ROS功能包时，一般都会依赖这三个库实现。</p><p>3.进入ros功能包下的src目录编辑源文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src/功能包/src</span><br></pre></td></tr></table></figure><p>注意是功能包下的src目录，编辑源文件。</p><p>4.编辑配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">配置文件位置：和功能包下的src平级的</span><br><span class="line">cd 工作空间/src/功能包/CMakeLists.txt</span><br><span class="line">编辑内容如下：</span><br><span class="line">add_executable(步骤3的源文件名</span><br><span class="line">  src/步骤3的源文件名.cpp</span><br><span class="line">)</span><br><span class="line">两个参数：分别修改为如下</span><br><span class="line">1.相当于后边原文件名的别名，可以任意名字，一般建议为原文件名</span><br><span class="line">2：功能包/src/源文件名.cpp</span><br><span class="line"></span><br><span class="line">修改链接库：</span><br><span class="line">target_link_libraries(步骤3的源文件名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line">修改第一个参数：</span><br><span class="line">1.修改为add_executable中的一个参数名（也就是源文件名的别名）</span><br></pre></td></tr></table></figure><p>5.编译执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在工作空间目录下编译</span><br><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行过程：</span><br><span class="line">启动命令：roscore</span><br><span class="line">另外一个终端：</span><br><span class="line">cd 工作空间</span><br><span class="line">source ./devel/setup.bash（作用：把当前工作空间刷新到当前窗口下的环境变量。缺点是：只在当前终端管用）</span><br><span class="line">rosrun 包名 C++节点（源文件的映射名字）</span><br></pre></td></tr></table></figure><p><code>source ~/工作空间/devel/setup.bash</code>可以添加进<code>.bashrc</code>文件，使用上更方便</p><p>添加方式1: 直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容</p><p>添加方式2:<code>echo &quot;source ~/工作空间/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p><h1 id="helloworld实现过程（python）"><a href="#helloworld实现过程（python）" class="headerlink" title="helloworld实现过程（python）"></a>helloworld实现过程（python）</h1><p>1.创建工作空间和功能包（如上cpp过程）</p><h1 id="ROS工作空间目录"><a href="#ROS工作空间目录" class="headerlink" title="ROS工作空间目录"></a>ROS工作空间目录</h1><p>工作空间：是一个存放工程开发相关文件的文件夹</p><ol><li>build:编译空间，编译过程产生的中间文件</li><li>devel：开发空间，可执行文件和相关脚本</li><li>src：代码空间</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="新建文章步骤："><a href="#新建文章步骤：" class="headerlink" title="新建文章步骤："></a>新建文章步骤：</h1><p>1.在你的博客目录下，右键Git Bash Here。输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章的名字&quot;</span><br></pre></td></tr></table></figure><p>2.在博客目录下/source/_posts/文件夹下，会生成”文章的名字.md”文件</p><p>3.在文件中编辑博客内容。hexo发布的文章是Markdown格式的文件。我使用的Typora软件进行编辑的。Markdown语法可以参考如下网址：<a href="http://www.markdown.cn/">语法网址</a>。</p><p>4.给文章添加分类和标签：在md文件中设置tags和categories属性就行了。</p><p>5.hexo s，启动本地服务器进行测试</p><p>6.hexo clean：清楚命令</p><p>hexo g：重新生成</p><p>hexo d：发布命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="2021/06/02/ros/"/>
      <url>2021/06/02/ros/</url>
      
        <content type="html"><![CDATA[<p>机器人操作系统(ROS)是一个用于编写机器人软件的灵活框架。它是一个工具、库和约定的集合，旨在简化跨各种机器人平台创建复杂和健壮的机器人行为的任务。ROS操作系统是目前使用最广泛的开源机器人软件平台，在无人驾驶系统的实现上，ROS是开源框架中的最好的选择。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。</p><span id="more"></span><p>ROS1.0的架构核心是基于message的松耦合、分布式架构。核心概念有：Node、Master、Message、Topic、Services等。因为ROS1.0在设计之初没有考虑到安全问题，所以ROS 1.0框架主要安全风险充分暴露：匿名通信无身份认证、消息明文传输、缺少访问控制等。</p><p>ROS2.0采用DDS替换了ROS1.0的publish-subscribe通信机制，因为DDS本身是有Security安全协议规范的，因此ROS2.0的安全主要基于DDS-Security。</p><p>DDS-Security规范对DDS规范进行了扩展，通过定义服务插件接口(Service Plugin Interface，SPI)体系结构、SPI的一组内置实现以及SPI实施的安全模型，增加了安全增强功能。具体地说，定义了五个SPI：</p><p>身份验证：验证给定域参与者的身份。</p><p>访问控制：对可由验证域参与者执行的与DDS相关的操作实施限制。 </p><p>加密：处理所有必需的加密、签名和散列操作。</p><p>日志记录：提供审计与DDS安全相关的事件的能力。 </p><p>数据标记：提供向数据样本添加标记的功能。</p><p>ROS 2的安全功能目前只使用前三个功能。这是因为为了符合DDS-Security规范，既不需要日志记录，也不需要数据标记，因此并不是所有的DDS实现都支持它们。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 自动驾驶操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/25/hello-world/"/>
      <url>2021/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
