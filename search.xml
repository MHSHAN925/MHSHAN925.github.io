<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>androidSomething</title>
      <link href="2021/07/02/androidSomething/"/>
      <url>2021/07/02/androidSomething/</url>
      
        <content type="html"><![CDATA[<h1 id="something"><a href="#something" class="headerlink" title="something"></a>something</h1><p>要理解设计者意图，就需要抽象。我们需要在哲学意义空间中去考虑系统的描述，即系统在本质上要表达什么。在逻辑空间上去考虑系统基本构成和动态结构。从现实到虚拟对象的映射去理解系统对象的组成，在从数据流的角度分析数据的产生者和消费者之间作用关系，从控制流的角度去分析对象之间的交互关系，从函数调用去分析具体的层次关系。</p><p>在系统设计上，原型是最能表达哲学空间和逻辑空间中系统本质的东西，原型是事物本质的第一层体现。我以为任何复杂的系统都一个简洁的系统原型，都有它简洁的意义。系统原型是设计者意图的第一体现，所以我们需要从几个方向上去提炼系统原型：</p><p>（1）从系统本质和基本原理出发</p><p>（2）从分析系统数据流和控制流分析出发。</p><p>从设计者意图出发，得出系统原型，提取到大的逻辑结构和系统构成是第一步。之后我们可以从设计者的角度考虑系统猜想系统设计，为什么要这样设计，为什么要有这些构成。这样的基本原型是什么？系统的限制是什么，应用场景有哪些，有些设计的引进还是系统收敛性而为之呢。我们还可以从代码痕迹上去分析，这些概念是如何的得来的？从一定的抽象和高度去理解这些问题，遵循系统原型出发之原则，在深入分析代码的时候，就不容易陷入细节中。我们就可以随时跳出来想，这些代码在整体上载表达一个什么概念，在描绘一个什么逻辑，他要构成一个虚拟层吗？他是在管理这个硬件吗？他在虚拟这个对象吗？他在构建管理机构？还是在构建一个对象管理？空间管理，为了快速引入了什么样的复杂算法，实际上的原型算法应该是什么样的？</p><p>只有深入到这个抽象层次，我们才能很好的把握住系统的每一条线，每一个对象的意义。只用从原型出发，我们才能把握住这个系统的实质所在，在干什么？他要表达什么？设计者为什么要这样想？最终极的想法是什么？这样，代码分析就变得简单明了，读代码就变成了是在印证猜想，修正方向。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode图</title>
      <link href="2021/07/01/leetcode%E5%9B%BE/"/>
      <url>2021/07/01/leetcode%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeBFS</title>
      <link href="2021/06/30/leetcodeBFS/"/>
      <url>2021/06/30/leetcodeBFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeDFS</title>
      <link href="2021/06/30/leetcodeDFS/"/>
      <url>2021/06/30/leetcodeDFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcood动态规划相关题目</title>
      <link href="2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode22：括号生成"><a href="#leetcode22：括号生成" class="headerlink" title="leetcode22：括号生成"></a>leetcode22：括号生成</h1>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood链表相关题目</title>
      <link href="2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood二叉树相关题目</title>
      <link href="2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode栈和队列相关题目</title>
      <link href="2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode20：有效括号（栈可以解决）"><a href="#leetcode20：有效括号（栈可以解决）" class="headerlink" title="leetcode20：有效括号（栈可以解决）"></a>leetcode20：有效括号（栈可以解决）</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员代码面试指南第一章题目</title>
      <link href="2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h1><h2 id="1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"><a href="#1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。" class="headerlink" title="1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"></a>1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。</h2><p>思路：因为要返回栈中最小的元素，所以需要找个地方把最小的元素给存起来。这个存起来的过程涉及到判断最小的元素。</p><p>方法1：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​            压入规则：1、判断stackData是否为空。</p><p>​                                    1.1：为空，两个栈压入</p><p>​                                    1.2：不为空，stackData压入，然后判断压入数据和stackMin栈顶元素的大小，如果压入数据小或等于，也压入stackMin中。压入数据大于stackMin栈顶的元素，则不用压入。</p><p>​            弹出规则：压入规则的对应。</p><p>​            查询当前栈最小值的操作：stackMin保存着最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackNormal = new Stack();</span><br><span class="line">    Stack&lt;Integer&gt; stackSpecial = new Stack();</span><br><span class="line">//构造函数</span><br><span class="line">    public GetMin() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GetMin(Stack&lt;Integer&gt; stackNormal, Stack&lt;Integer&gt; stackSpecial) &#123;</span><br><span class="line">        this.stackNormal = stackNormal;</span><br><span class="line">        this.stackSpecial = stackSpecial;</span><br><span class="line">    &#125;</span><br><span class="line">//压入规则</span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">       stackNormal.push(input);</span><br><span class="line">       if (stackSpecial.size() == 0)&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stackSpecial.size() != 0 &amp;&amp; input &lt;= stackSpecial.peek())&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//弹出规则</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stackNormal.pop();</span><br><span class="line">        if (value == stackSpecial.peek())&#123;</span><br><span class="line">            stackSpecial.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">//查询规则</span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackSpecial.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​        压入规则：先判断stackData栈是否为空，为空的话两个栈同时压入。</p><p>​                            不为空：stackData压入数据，然后判断压入的数据和stackMin栈顶的元素的大小。如果大于stackMin栈顶的元素，stackMin再次压入当前栈顶的元素，如果小于stackMin栈顶的元素，则也直接压入stackMin。</p><p>​        弹出规则：压入规则的对应</p><p>​        查询规则：stackMin栈的栈顶元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin2 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackData = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackMin = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public GetMin2(Stack&lt;Integer&gt; stackData, Stack&lt;Integer&gt; stackMin) &#123;</span><br><span class="line">        this.stackData = stackData;</span><br><span class="line">        this.stackMin = stackMin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">        stackData.push(input);</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            stackMin.push(input);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (input &lt;= stackMin.peek())&#123;</span><br><span class="line">                stackMin.push(input);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stackMin.push(stackMin.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackData.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stackMin.pop();</span><br><span class="line">        return stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackMin.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="两个栈组成的队列"><a href="#两个栈组成的队列" class="headerlink" title="两个栈组成的队列"></a>两个栈组成的队列</h1><h5 id="2、编写一个类，用两个栈实现队列，支持队列的基本操作"><a href="#2、编写一个类，用两个栈实现队列，支持队列的基本操作" class="headerlink" title="2、编写一个类，用两个栈实现队列，支持队列的基本操作"></a>2、编写一个类，用两个栈实现队列，支持队列的基本操作</h5><p>思路：栈的特点是先进后出，队列的特点是先进先出。所以我们需要从stackIn中数据倒入stackOut中，在出栈就会满足队列的特点。注意点1：就是从stackIn转移数据到stackOut中的时候，需要把stackIn中的数据全部出栈，再stackOut中进栈。注意点2：如果stackOut不空的时候stackIn不能向stackOut中压入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TwoStackToQueue &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackOut = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(int input)&#123;</span><br><span class="line">        stackIn.push(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int poll()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode168Excel表列名称</title>
      <link href="2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
      <url>2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode168：Excel表列名称"><a href="#leetcode168：Excel表列名称" class="headerlink" title="leetcode168：Excel表列名称"></a>leetcode168：Excel表列名称</h1><p>题目：给你一个整数，返回它在Excel表中相应的列名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">例如：</span><br><span class="line">输入：columnNumber = 1</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">输入：columnNumber = 28</span><br><span class="line">输出：&quot;AB&quot;</span><br><span class="line">输入：columnNumber = 2147483647</span><br><span class="line">输出：&quot;FXSHRXW&quot;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>这道题属于简单题。首先要能够意识这道题考察了进制之间的转换。另外本题中的范围为【1-26】，要变化为【0-25】。</p><h5 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h5><p>1、m进制转化为10进制。</p><p>​        方法：从低位到高位按权展开</p><p>2、10进制转换为n进制</p><p>​        方法：除留取余，逆序排序</p><p>3、本题中的范围是【1-26】，需要对每个进行求余和整除的数减一，在对26进行求余运算，把范围变成【0-25】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String convertToTitle(int columnNumber)&#123;</span><br><span class="line">    //用的stringBuilder进行储存</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    while (columnNumber &gt; 0)&#123;</span><br><span class="line">        columnNumber--;</span><br><span class="line">        //减一,为什么减一。因为26在本题中对应的Z，但是和26除余之后为0.</span><br><span class="line">        //举个例子，比如1--&gt;A.减一除余之后为0，在加A（是加的ASCII码）就变成了A。</span><br><span class="line">        stringBuilder.append((char)((columnNumber % 26) + &#x27;A&#x27;));</span><br><span class="line">        columnNumber = columnNumber / 26;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.reverse();</span><br><span class="line">    return stringBuilder.toString();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin基础</title>
      <link href="2021/06/28/kotlin%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/28/kotlin%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin从入门到进阶实战"><a href="#Kotlin从入门到进阶实战" class="headerlink" title="Kotlin从入门到进阶实战"></a>Kotlin从入门到进阶实战</h1><h2 id="变量和标识符"><a href="#变量和标识符" class="headerlink" title="变量和标识符"></a>变量和标识符</h2><p>变量标识一个对象的地址，称之为标识符。具体存放的数据占用的内存的大小和存放的形式由其类型来决定。</p><p>kotlin中所有的变量类型都是引用类型。kotlin变量分为</p><p>​        val（不可变的）：只读的，仅能赋值一次</p><p>​        var（可写的）：可以被多次赋值</p><h2 id="关键字和修饰符"><a href="#关键字和修饰符" class="headerlink" title="关键字和修饰符"></a>关键字和修饰符</h2><p>关键字：类修饰符、成员修饰符、访问权限修饰符、协变逆变修饰符、函数修饰符、属性修饰符、参数修饰符等</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>分支语句（if、when）</p><p>​        在Kotlin中，if是一个表达式，会返回一个值</p><p>​        if的分支可以是代码块，最后的表达式作为该块的值</p><p>​        when表达式类似于switch..case表达式</p><p>循环语句（for、while）</p><p>​        for循环可以对任何提供迭代器（iterator）的对象进行遍历</p><p>​        while循环类似于java</p><p>跳转语句（return、break、continue、throw）</p><p>​        break：用于完全结束一个循环，直接跳出循环体，然后执行循环后面的语句。<br>​        continue：只终止本轮循环，但是还会继续下一轮循环。</p><p>​        return：kotlin中除了表达式的值，有返回值的函数都要求显示使用return语句返回其值。kotlin中可以直接使用“=”符号返回一个函数的值，这样的函数称为函数字面量。</p><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>kotlin中任何表达式都可以用标签来标记。标签的格式为标识符后跟@符号，可以用标签来控制return、break、continue等语句的跳转行为。</p><h5 id="基本类型："><a href="#基本类型：" class="headerlink" title="基本类型："></a>基本类型：</h5><p>​        在kotlin中，所有东西都是对象，我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示–数字、字符、布尔值在运行时表示为原生类型值，但对于用户来说，看起来就像是普通的类。kotlin中的基本类型：数字、字符、布尔值、数组与字符串。</p><p>整型：Byte、Short、Int、Long。</p><p>​        所有未超出Int最大值的整形值且未显示指定类型，都会被推断为Int类型。如果初始值超过了其最大值且未显示指定类型会被推断为Long类型。</p><p>浮点型：Float、Double。</p><p>​        对于以小数初始化的变量，编译器会推断为Double类型。可以添加f或F将值显示指定为Float类型。</p><p>​        三个特殊的浮点型数值：正无穷大、负无穷大和非数。所有的正无穷大数值都相等，所有的负无穷大数值都相等，非数不与任何数值相等且非数之间也不相等（因为非数之间比较没有意义）</p><p>​        kotlin没有隐式拓宽转换，具有Double参数的函数只能对Double值调用，而不能对Float、Int其他数字值调用 。</p><p>字符型：kotlin语言使用16位的unicode字符集作为编码方式。kotlin中的Char型变量不能当成整数值使用，Char型变量不能赋值给整型变量，整型变量也不能赋值给Char型变量。</p><p>字面值常量：</p><p>​        十进制：123.  Long类型用大写L标记：123L</p><p>​        十六进制：0x0F</p><p>​        二进制：0b00001011</p><p>​        不支持八进制</p><p>支持浮点数的常规表示方法：</p><p>​        默认double:123.5</p><p>​        Float用f或者F标记：123.5f</p><p> kotlin中，较小类型不是较大类型的子类型，所以较小类型不能隐式转换为较大类型。必须通过显示转换。toByte（）、toShort（）、toInt（）、toLong（）等。</p><p>kotlin在表达式中可以自动转换，这种转换是基于上下文推断出来的，算术运算符会有重载做适当转换。</p><p>布尔：布尔用Boolean类型表示，有两个值true和false</p><p>121000004352307294</p><h1 id="疯狂kotlin讲义"><a href="#疯狂kotlin讲义" class="headerlink" title="疯狂kotlin讲义"></a>疯狂kotlin讲义</h1><h2 id="kotlin的基础类型："><a href="#kotlin的基础类型：" class="headerlink" title="kotlin的基础类型："></a>kotlin的基础类型：</h2><p>声明变量：var | val  变量名 【：类型】【= 初始值】</p><p>var声明的变量可被多次赋值，val声明的变量不可被重新赋值</p><p>kotlin是强类型的语言，要求所有的变量必须先声明、后使用，声明变量时必须显示或隐式指定变量的类型。</p><p>程序要么通过“：类型”的形式显示指定该变量的类型，要么为该变量指定初始值-kotlin编译器会根据初始值确定变量的类型。不能声明变量时既不指定变量类型、也不指定变量的初始值。</p><p>常量：</p><p>​        局部范围的常量：允许在声明时不指定初始值，只要在第一次使用之前指定初始值就可以。</p><p>​        类的常量属性：这种常量属性既可以在声明时指定初始值，也可以在类或结构体的构造器中指定初始值。</p><p>kotlin程序编译的字节码必须遵守JVM规范，直接在kotlin程序中定义变量、函数，kotlinc将会自动生成一个名为“文件名首字母大写+Kt”的类，并将变量转换为该类的静态getter、setter方法（val声明的只有getter方法），函数转换为该类的静态方法。</p><p>null安全：只有可空类型的变量或常量才能接受null，非空类型的变量或常量不能接受null。</p><p>kotlin对可空类型进行了限制，可空类型不允许直接调用方法、访问属性。需要先判断该变量不为null，然后再调用该变量的方法和属性。kotlin：“！！”强制调用可空变量的方法和属性，可能引发NPE</p><h5 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h5><p>​        kotlin中的字符串有两种字面值：</p><p>​            转义字符串：可以有转义字符，转移字符串很像普通的java字符串。</p><p>​            原始字符串：可以包含换行和任意文本，原始字符串需要3个引号引起来。</p><p>​        字符串模板：允许在字符串中嵌入变量或表达式，只要将变量或表达式放入${}中，kotlin会把该变量或表达式的值嵌入该字符串中。</p><h5 id="类型别名："><a href="#类型别名：" class="headerlink" title="类型别名："></a>类型别名：</h5><p>​        kotlin提供typealias来定义类型别名。</p><p>​        typealias 类型别名 = 已有类型</p><h2 id="第三章：运算符和表达式"><a href="#第三章：运算符和表达式" class="headerlink" title="第三章：运算符和表达式"></a>第三章：运算符和表达式</h2><p>java支持的运算符包括算数运算符、赋值运算符、扩展后的赋值运算符、比较运算符、逻辑运算符。kotlin也完全支持。</p><p>kotlin不支持三目运算符，kotlin使用if表达式代替了三目运算符。kotlin的运算符都是以方法形式实现的。</p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划总结</title>
      <link href="2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 算法之动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin</title>
      <link href="2021/06/24/kotlin/"/>
      <url>2021/06/24/kotlin/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-docs（基本语法）"><a href="#Kotlin-docs（基本语法）" class="headerlink" title="Kotlin-docs（基本语法）"></a>Kotlin-docs（基本语法）</h1><p>包的定义和导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包的声明应处于源文件的顶部：</span><br><span class="line">package my.demo</span><br><span class="line">import kotlin.txt</span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kotlin的入口点是main函数</span><br><span class="line">带有两个Int参数、返回Int的函数</span><br><span class="line">fun sum(a: Int, b: Int): Int&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">将表达式作为函数体、返回值类型自动推断的函数</span><br><span class="line">fun sum(a: Int, b: Int) = a + b</span><br><span class="line">函数返回无意义的值：</span><br><span class="line">fun printSum(a: Int, b: Int): Unit&#123;</span><br><span class="line">println(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">Unit返回类型可以省略</span><br><span class="line">fun printSum(a: Int, b: Int)&#123;</span><br><span class="line">printLn(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var maximun:Int = 5</span><br><span class="line">变量定义关键字 变量名 类型定义 赋值运算符 赋值</span><br><span class="line">简写：var maximun = 5</span><br><span class="line">变量名关键字 变量名 赋值运算符 赋值（相比少了一个类型定义，因为kotlin可以进行类型推断）</span><br><span class="line"></span><br><span class="line">var关键字修饰的是可修改变量</span><br><span class="line">val关键字修饰的是只读变量</span><br><span class="line"></span><br><span class="line">类型推断：对与以声明并赋值的变量，允许省略类型定义</span><br><span class="line"></span><br><span class="line">定义只读局部变量使用关键字val定义，只能为其赋值一次</span><br><span class="line">val a: Int = 1//立即赋值</span><br><span class="line">val b = 2//自动推断出Int类型</span><br><span class="line">val c: Int //如果没有初始值类型不能省略</span><br><span class="line">c = 3 //明确赋值</span><br><span class="line"></span><br><span class="line">可重新赋值的变量使用var关键字</span><br><span class="line">var x = 5 //自动推断出Int类型</span><br><span class="line">x += 1</span><br><span class="line">顶层变量</span><br><span class="line">val PI = 3.14</span><br><span class="line">var x = 0</span><br><span class="line">fun incre()&#123;</span><br><span class="line">x += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时常量：只能定义在函数之外，因为编译时常量必须在编译时赋值，函数都是在运行时才调用，函数内的变量是在运行时赋值，编译时常量要在这些变量赋值前就已经存在。</p><p>编译时常量只能是常见的基本数据类型：String、Int、Double、Float、Long、Short、Byte、Char、Boolean</p><p>kotlin只提供引用类型这一种数据类型，但是kotlin编译器会在java字节码中改用基本数据类型</p><p>空值和null检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当某个变量的值可以为null的时候，必须在声明处的类型后添加？，来标识该引用可以为空</span><br><span class="line">fun parseInt(str: String): Int?&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型检测与自动类型转换:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is运算符检测一个表达式是否某类型的一个实例。如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显示转换。</span><br><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">if (obj is String) &#123;</span><br><span class="line">// `obj` 在该条件分⽀内⾃动转换成`String`</span><br><span class="line">return obj.length</span><br><span class="line">&#125;</span><br><span class="line">// 在离开类型检测分⽀后，`obj` 仍然是`Any` 类型</span><br><span class="line">return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>for循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;,&quot;kiwifruit&quot;)</span><br><span class="line">for(item in items)&#123;</span><br><span class="line">println(item)</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">for (index in items.indices) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>while循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">var index = 0</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>when表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun describe(obj: Any): String =</span><br><span class="line">when (obj) &#123;</span><br><span class="line">1 -&gt; &quot;One&quot;</span><br><span class="line">&quot;Hello&quot; -&gt; &quot;Greeting&quot;</span><br><span class="line">is Long -&gt; &quot;Long&quot;</span><br><span class="line">!is String -&gt; &quot;Not a string&quot;</span><br><span class="line">else -&gt; &quot;Unknown&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用区间（range）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">使用in运算符来检测某个数字是否在指定区间内</span><br><span class="line">val x = 10</span><br><span class="line">val y = 9</span><br><span class="line">if (x in 1..y+1) &#123;</span><br><span class="line">println(&quot;fits in range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">检测某个数字是否在指定区间外：</span><br><span class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">if (-1 !in 0..list.lastIndex) &#123;</span><br><span class="line">println(&quot;-1 is out of range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if (list.size !in list.indices) &#123;</span><br><span class="line">println(&quot;list size is out of valid list indices range, too&quot;)</span><br><span class="line">&#125;</span><br><span class="line">区间迭代：</span><br><span class="line">for (x in 1..5) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">数列迭代：</span><br><span class="line">for (x in 1..10 step 2) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line">for (x in 9 downTo 0 step 3) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="kotlin小知识点"><a href="#kotlin小知识点" class="headerlink" title="kotlin小知识点"></a>kotlin小知识点</h1><h5 id="强类型语言："><a href="#强类型语言：" class="headerlink" title="强类型语言："></a>强类型语言：</h5><p>​        一旦某一个变量被定义类型，如果不经过强制转换，就永远是该数据类型</p><h5 id="弱类型语言："><a href="#弱类型语言：" class="headerlink" title="弱类型语言："></a>弱类型语言：</h5><p>​        某一个变量被定义类型，该变量可以根据环境变化自动变化。</p><h5 id="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"><a href="#强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。" class="headerlink" title="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"></a>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</h5><h5 id="动态类型语言："><a href="#动态类型语言：" class="headerlink" title="动态类型语言："></a>动态类型语言：</h5><p>​        动态性语言是指在运行期间才去做数据类型检查的语言，也就是动态类型语言编程时，永远不用给任何变量指定数据类型。该语言会在第一次赋值给变量时，在内部将数据类型记录下来。python、ruby</p><h5 id="静态类型语言："><a href="#静态类型语言：" class="headerlink" title="静态类型语言："></a>静态类型语言：</h5><p>​        数据类型在编译期间检查，也就是在写程序的时候要声明变量的数据类型。</p><h5 id="kotlin中的常量问题？"><a href="#kotlin中的常量问题？" class="headerlink" title="kotlin中的常量问题？"></a><em><u>kotlin中的常量问题？</u></em></h5><h5 id="kotlin是null安全的语言："><a href="#kotlin是null安全的语言：" class="headerlink" title="kotlin是null安全的语言："></a>kotlin是null安全的语言：</h5><p>​        Byte、Short、Int、Long型变量都不能接受null值，如果要存储null值，应该使用Byte？、Short？、Int？、Long？类型（相当于支持null值的对应类型）。</p><p>​        加不加？后缀的另一个区别：普通类型的整形变量将会映射成java的基本类型，带？后缀的整形变量将会映射成基本类型的包装类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">val pm1 = 200;</span><br><span class="line">val pm2 = 200;</span><br><span class="line">println(pm1 == pm2);</span><br><span class="line">println(pm1 === pm2)</span><br><span class="line"></span><br><span class="line">val ob1: Int? = 200</span><br><span class="line">val ob2: Int? = 200</span><br><span class="line">println(ob1 == ob2)</span><br><span class="line">println(ob1 === ob2)</span><br><span class="line"></span><br><span class="line">val  ob3: Int? = 100</span><br><span class="line">val  ob4: Int? = 100</span><br><span class="line">println(ob3 == ob4)</span><br><span class="line">println(ob3 === ob4)</span><br><span class="line">结果如下：</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS服务和参数</title>
      <link href="2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/"/>
      <url>2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"><a href="#ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。" class="headerlink" title="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"></a>ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。</h2><h1 id="使用rosservice"><a href="#使用rosservice" class="headerlink" title="使用rosservice"></a>使用rosservice</h1><p>rosservice可以很容易通过服务附加到ROS客户端/服务器框架上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rosservice list         输出活跃服务的信息</span><br><span class="line">rosservice call         用给定的参数调用服务</span><br><span class="line">rosservice type         输出服务的类型</span><br><span class="line">rosservice find         按服务的类型查找服务</span><br><span class="line">rosservice uri          输出服务的ROSRPC uri</span><br></pre></td></tr></table></figure><p>rosservice type [service]:进一步查看服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /clear</span><br><span class="line">结果是：std_srvs/Empty</span><br></pre></td></tr></table></figure><p>服务的类型为empty，表明调用这个服务时不需要参数。（它在发出<strong>请求</strong>时不发送数据，在接收<strong>响应</strong>时也不接收数据）</p><p>rosservice call [service] [args]:call命令调用服务，args是给定的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear：</span><br><span class="line">call:表明调用clear服务</span><br></pre></td></tr></table></figure><p>查看spawn（产卵）服务的信息，此服务具有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /spawn | rossrv show</span><br></pre></td></tr></table></figure><p>​        spawn服务的参数：name字段是可选的        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">string name</span><br><span class="line">---</span><br><span class="line">string name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn 2 2 0.2 &quot;&quot;</span><br><span class="line">调用spawn服务，并且需要参数。</span><br><span class="line">clear服务不需要参数</span><br></pre></td></tr></table></figure><h1 id="使用rosparam"><a href="#使用rosparam" class="headerlink" title="使用rosparam"></a>使用rosparam</h1><p><code>rosparam</code>能让我们在ROS[参数服务器（Parameter Server）](<a href="http://wiki.ros.org/Parameter">http://wiki.ros.org/Parameter</a> Server)上存储和操作数据。参数服务器能够存储整型（integer）、浮点（float）、布尔（boolean）、字典（dictionaries）和列表（list）等数据类型。rosparam使用YAML标记语言的语法。一般而言，YAML的表述很自然：<code>1</code>是整型，<code>1.0</code>是浮点型，<code>one</code>是字符串，<code>true</code>是布尔型，<code>[1, 2, 3]</code>是整型组成的列表，<code>&#123;a: b, c: d&#125;</code>是字典。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS话题</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="理解ROS话题（乌龟走动幕后的故事）"><a href="#理解ROS话题（乌龟走动幕后的故事）" class="headerlink" title="理解ROS话题（乌龟走动幕后的故事）"></a>理解ROS话题（乌龟走动幕后的故事）</h1><p>roscore：只运行一个roscore就够了。</p><p>乌龟走动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个新终端：roscore</span><br><span class="line">新终端：rosrun turtlesim turtlesim_node</span><br><span class="line">新终端：rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><h2 id="ROS话题："><a href="#ROS话题：" class="headerlink" title="ROS话题："></a>ROS话题：</h2><p>​            turtlesim_node节点和turtle_teleop_key节点之间通过ROS话题相互通信。turtle_teleop_key在话题上发布键盘按下的信息，turtlesim_node订阅该话题以接收消息。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure><p>上述命令之后，rqt_graph会用动态的图显示系统中发生的事情。</p><h2 id="rostopic：rostopic命令工具能获取ROS话题的信息。"><a href="#rostopic：rostopic命令工具能获取ROS话题的信息。" class="headerlink" title="rostopic：rostopic命令工具能获取ROS话题的信息。"></a>rostopic：rostopic命令工具能获取ROS话题的信息。</h2><p>rostopic -h：查看可用的rostopic的子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">        rostopic bw     display bandwidth used by topic</span><br><span class="line">        rostopic delay  display delay of topic from timestamp in header</span><br><span class="line">        rostopic echo   print messages to screen</span><br><span class="line">        rostopic find   find topics by type</span><br><span class="line">        rostopic hz     display publishing rate of topic    </span><br><span class="line">        rostopic info   print information about active topic</span><br><span class="line">        rostopic list   list active topics</span><br><span class="line">        rostopic pub    publish data to topic</span><br><span class="line">        rostopic type   print topic or field type</span><br></pre></td></tr></table></figure><p>rostopic echo [topic]:查看在某个话题上发布的数据。（也就是去订阅了话题）</p><p>rostopic list -h：查看可用的rostopic list子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -b BAGFILE, --bag=BAGFILE</span><br><span class="line">                        list topics in .bag file</span><br><span class="line">  -v, --verbose         list full details about each topic</span><br><span class="line">  -p                    list only publishers</span><br><span class="line">  -s                    list only subscribers</span><br></pre></td></tr></table></figure><p>rostopic list -v：会列出所有发布者和订阅的主题及其类型的相关信息。</p><h1 id="ROS消息"><a href="#ROS消息" class="headerlink" title="ROS消息"></a>ROS消息</h1><p>话题的通信是通过节点间发送ROS消息实现的。为了使发布者和订阅者进行通信，发布者和订阅者必须发送和接收相同类型的消息。所以话题的类型是由发布在上面的消息的类型决定的。</p><p>rostopic type 【topic】:查看所发布话题的消息类型。    </p><p>​        使用rosmsg show  【geometry_msgs/Twist】查看消息的详细信息。</p><h2 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic:"></a>rostopic:</h2><p>rostopic pub 【topic】【msg_type】【args】:把数据发布到当前某个正在广播的话题上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, 1.8]&#x27;</span><br></pre></td></tr></table></figure><p>rostopic pub:将消息发布到指定的话题。</p><p>-1：让rostopic只发布一条消息，然后退出</p><p>/turtle1/cmd_vel：要发布到的话题的名称</p><p>geometry_msgs/Twist：发布到话题时要使用的消息的类型</p><p>–：两个破折号，用来告诉解析器，之后的参数都不是选项</p><p>如前所述，一个turtlesim/Velocity消息有两个浮点型元素：<code>linear</code>和<code>angular</code>。在本例中，<code>&#39;[2.0, 0.0, 0.0]&#39;</code>表示<code>linear</code>的值为<code>x=2.0</code>, <code>y=0.0</code>, <code>z=0.0</code>，而<code>&#39;[0.0, 0.0, 1.8]&#39;</code>是说<code>angular</code>的值为<code>x=0.0</code>, <code>y=0.0</code>, <code>z=1.8</code>。这些参数实际上使用的是YAML语法，在<a href="http://wiki.ros.org/ROS/YAMLCommandLine">YAML命令行文档</a>中有描述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, -1.8]&#x27;</span><br></pre></td></tr></table></figure><p>turtle以一个稳定的频率为1Hz的指令流才能保持移动状态。我们可以使用<code>rostopic pub -r</code>命令来发布源源不断的命令。</p><p>rostopic hz 【topic】：报告数据发布的速率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic type /turtle1/cmd_vel | rosmsg show</span><br></pre></td></tr></table></figure><p>结合rostopic、type、rosmsg show、命令来获取关于某个话题的更深层次的信息。</p><h1 id="使用rqt-plot"><a href="#使用rqt-plot" class="headerlink" title="使用rqt_plot"></a>使用rqt_plot</h1><p><code>rqt_plot</code>命令可以在滚动时间图上显示发布到某个话题上的数据。这里我们将使用<code>rqt_plot</code>命令来绘制正被发布到<code>/turtle1/pose</code>话题上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS节点</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p>计算图是一个由ROS进程组成的点对点网络，能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Services）、话题（Topics）、包（Bags）。</p><p>节点：是ROS软件包中的一个可执行文件，可以通过ROS来与其他节点通信。</p><p>​            ROS节点使用ROS客户端与其他节点通信。节点可以发布或订阅话题，也可以提供或使用服务。</p><p>消息：订阅或发布话题时所使用的的ROS数据类型。</p><p>话题：节点可以将消息发布到话题或者通过订阅话题来接收消息。</p><p>主节点：ROS的命名服务，帮助节点发现彼此。</p><p>rosout：相当于stdout/stderr（标准输出、标准错误）</p><p>​                rosout节点，用于收集和记录节点的调试输出，所以总是在运行。</p><p>roscore：主节点+rosout+参数服务器</p><p>​                运行所有ROS程序前需要运行的命令。</p><p>客户端库：ROS客户端库可以让不同编程语言编写的节点进行相互通信</p><p>​                    rospy=python客户端库</p><p>​                    roscpp=c++客户端库</p><p>rosnode:获取接地那信息的ros工具</p><p>​                rosnode list：列出活动的节点</p><p>​                rosnode info：返回某个节点的信息。rosnode info /rosout</p><p>​                rosnode cleanup：尝试清除rosnode列表</p><p>rosrun：运行给定的软件包中的节点</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terminator常用快捷键</title>
      <link href="2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //移动到上面的终端</span><br><span class="line">Alt+Down                        //移动到下面的终端</span><br><span class="line">Alt+Left                        //移动到左边的终端</span><br><span class="line">Alt+Right                       //移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line">Ctrl+Shift+S                    //隐藏/显示滚动条</span><br><span class="line">Ctrl+Shift+F                    //搜索</span><br><span class="line">Ctrl+Shift+C                    //复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V                    //粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+W                    //关闭当前终端</span><br><span class="line">Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭</span><br><span class="line">Ctrl+Shift+X                    //最大化显示当前终端</span><br><span class="line">Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大</span><br><span class="line">Ctrl+Shift+N or Ctrl+Tab        //移动到下一个终端</span><br><span class="line">Ctrl+Shift+P or Ctrl+Shift+Tab  //Crtl+Shift+Tab 移动到之前的一个终端</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="标签之间的操作"><a href="#标签之间的操作" class="headerlink" title="标签之间的操作"></a>标签之间的操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F11                             //全屏开关</span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line">Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置</span><br><span class="line">Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置</span><br><span class="line">Ctrl+Plus (+)                   //增大字体</span><br><span class="line">Ctrl+Minus (-)                  //减小字体</span><br><span class="line">Ctrl+Zero (0)                   //恢复字体到原始大小</span><br><span class="line">Ctrl+Shift+R                    //重置终端状态</span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line">Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端</span><br><span class="line">Super+Shift+G                   //解除绑定</span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line">Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程</span><br><span class="line">Super+i                         //打开一个新窗口，新窗口与原来的窗口使用不同的进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS软件包</title>
      <link href="2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
      <url>2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="创建ROS软件包"><a href="#创建ROS软件包" class="headerlink" title="创建ROS软件包"></a>创建ROS软件包</h1><ol><li><p>catkin软件包的组成：</p><ol><li>必须有一个符合catkin规范的package.xml文件。</li><li>必须有一个CMakeLists.txt文件</li><li>每个包必须有自己的目录。同一目录下不能嵌套或者多个软件包存在</li></ol></li><li><p>catkin工作空间中的软件包</p><ol><li><p>推荐使用catkin工作空间，也可以单独开发catkin软件包</p></li><li><p>创建软件包之前需要创建工作空间</p></li><li><pre><code>workspace_folder/        -- WORKSPACE  src/                   -- SOURCE SPACE    CMakeLists.txt       -- &#39;Toplevel&#39; CMake file, provided by catkin    package_1/      CMakeLists.txt     -- CMakeLists.txt file for package_1      package.xml        -- Package manifest for package_1    ...    package_n/      CMakeLists.txt     -- CMakeLists.txt file for package_n      package.xml        -- Package manifest for package_n<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 创建catkin软件包（功能包）</span><br><span class="line"></span><br><span class="line">   1. 切换到catkin工作空间中的源文件空间目录</span><br><span class="line"></span><br></pre></td></tr></table></figure> cd ~/catkin_ws/src<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用catkin_create_pkg命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>catkin_create_pkg catkin软件包名 std_msgs rospy roscpp<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      catkin软件包内包含[package.xml](http://wiki.ros.org/catkin/package.xml)文件和一个[CMakeLists.txt](http://wiki.ros.org/catkin/CMakeLists.txt)文件，文件中有执行catkin_create_pkg命令时提供的信息。</span><br><span class="line"></span><br><span class="line">      std_msgs rospy roscpp三个包是依赖。</span><br><span class="line"></span><br><span class="line">4. 包依赖关系</span><br><span class="line"></span><br><span class="line">   1. 一级依赖</span><br><span class="line">   2. 间接依赖</span><br><span class="line"></span><br><span class="line"># 构建ROS软件包</span><br><span class="line"></span><br><span class="line">在catkin工作空间构建ros软件包</span><br><span class="line"></span><br><span class="line">catkin_make:是一个命令行工具，它简化了标准catkin工作流程。你可以认为`catkin_make`是在标准CMake工作流程中依次调用了`cmake`和`make`。</span><br><span class="line"></span><br></pre></td></tr></table></figure>#在catkin工作空间下catkin_make<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">build:构建空间的默认位置，同时cmake和make在这里被调用用来配置和构建软件包。</span><br><span class="line"></span><br><span class="line">devel：开发空间的默认位置，在安装软件包之前，这里存放可执行文件和库。</span><br><span class="line"></span><br><span class="line">src：源码文件</span><br><span class="line"></span><br><span class="line"># 创建ROS工作空间（先于创建ROS软件包）</span><br><span class="line"></span><br></pre></td></tr></table></figure>$ mkdir -p ~/工作空间名/src$ cd ~/catkin_ws/$ catkin_make</code></pre></li></ol></li></ol><p>catkin_make命令：在工作空间第一次运行的时候，会在src目录下创建CMakeLists.txt链接。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS文件系统</title>
      <link href="2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>软件包（packages）：包是ROS代码的软件组织单元，每个软件包都可以包含程序库、可执行文件、脚本或其他构件。</p><p>Manifests（package.xml）:清单是对软件包的描述，用于定义软件包之间的依赖关系，并记录有关软件包的元信息。如版本、维护者、许可证</p><h1 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h1><p>ROS提供了专门的命令工具来实现ros软件包的查找和导航。</p><ul><li><p>rospack：获取软件包的有关信息。find选项返回软件包所在路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack find roscpp</span><br></pre></td></tr></table></figure><p>结果：/opt/ros/<distro>/share/roscpp</p></li><li><p>roscd:直接切换目录到某个软件包或者软件包集中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd roscpp</span><br><span class="line">roscd roscpp/cmake</span><br></pre></td></tr></table></figure><p>只能切换到那些路径包含在ROS_PACKAGE_PATH环境变量中的软件包。</p></li><li><p>roscd log:进入存储ROS日志文件的目录，如果没有执行过任何ROS程序，系统会报错说该目录不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd log</span><br></pre></td></tr></table></figure></li><li><p>rosls: 允许直接按软件包的名称执行，而不必输入绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosls roscpp_tutorials</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="VIM常用命令："><a href="#VIM常用命令：" class="headerlink" title="VIM常用命令："></a>VIM常用命令：</h1><h2 id="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"><a href="#vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。" class="headerlink" title="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"></a>vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。</h2><p>命令模式（一般模式）：启动vim就进入了命令模式。此时键盘动作被识别为命令，比如：i切换到输入模式、x删除当前光标所在处的字符、：切换到底线命令模式、u撤回上一步的操作。</p><p>输入模式（编辑模式）：ESC键退出输入模式，切换到命令模式。</p><p>底线命令模式：命令模式下按:（英文）进入底线命令模式。q退出程序、w保存文件、ESC退出底线命令模式。</p><p>搜索替换：命令模式下，（/word，代表向光标之下寻找一个字符串）（？word，代表向光标之上寻找一个字符串），n代表重复前一个搜索动作，N反向搜索的动作。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rosDay1</title>
      <link href="2021/06/03/rosDay1/"/>
      <url>2021/06/03/rosDay1/</url>
      
        <content type="html"><![CDATA[<h1 id="helloworld实现过程（C-）："><a href="#helloworld实现过程（C-）：" class="headerlink" title="helloworld实现过程（C++）："></a>helloworld实现过程（C++）：</h1><p>1.创建工作空间并编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 工作空间名称/src</span><br><span class="line">cd 工作空间</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>首先会创建一个工作空间和一个src子目录，进入工作空间调用catkin_make命令编译。</p><p>2.进入工作空间下的src目录，创建ros功能包并添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src</span><br><span class="line">catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure><p>会在工作空间下生成一个功能包，该功能包依赖于 roscpp、rospy 与 std_msgs，其中roscpp是使用C++实现的库，而rospy则是使用python实现的库，std_msgs是标准消息库，创建ROS功能包时，一般都会依赖这三个库实现。</p><p>3.进入ros功能包下的src目录编辑源文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src/功能包/src</span><br></pre></td></tr></table></figure><p>注意是功能包下的src目录，编辑源文件。</p><p>4.编辑配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">配置文件位置：和功能包下的src平级的</span><br><span class="line">cd 工作空间/src/功能包/CMakeLists.txt</span><br><span class="line">编辑内容如下：</span><br><span class="line">add_executable(步骤3的源文件名</span><br><span class="line">  src/步骤3的源文件名.cpp</span><br><span class="line">)</span><br><span class="line">两个参数：分别修改为如下</span><br><span class="line">1.相当于后边原文件名的别名，可以任意名字，一般建议为原文件名</span><br><span class="line">2：功能包/src/源文件名.cpp</span><br><span class="line"></span><br><span class="line">修改链接库：</span><br><span class="line">target_link_libraries(步骤3的源文件名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line">修改第一个参数：</span><br><span class="line">1.修改为add_executable中的一个参数名（也就是源文件名的别名）</span><br></pre></td></tr></table></figure><p>5.编译执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在工作空间目录下编译</span><br><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行过程：</span><br><span class="line">启动命令：roscore</span><br><span class="line">另外一个终端：</span><br><span class="line">cd 工作空间</span><br><span class="line">source ./devel/setup.bash（作用：把当前工作空间刷新到当前窗口下的环境变量。缺点是：只在当前终端管用）</span><br><span class="line">rosrun 包名 C++节点（源文件的映射名字）</span><br></pre></td></tr></table></figure><p><code>source ~/工作空间/devel/setup.bash</code>可以添加进<code>.bashrc</code>文件，使用上更方便</p><p>添加方式1: 直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容</p><p>添加方式2:<code>echo &quot;source ~/工作空间/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p><h1 id="helloworld实现过程（python）"><a href="#helloworld实现过程（python）" class="headerlink" title="helloworld实现过程（python）"></a>helloworld实现过程（python）</h1><p>1.创建工作空间和功能包（如上cpp过程）</p><h1 id="ROS工作空间目录"><a href="#ROS工作空间目录" class="headerlink" title="ROS工作空间目录"></a>ROS工作空间目录</h1><p>工作空间：是一个存放工程开发相关文件的文件夹</p><ol><li>build:编译空间，编译过程产生的中间文件</li><li>devel：开发空间，可执行文件和相关脚本</li><li>src：代码空间</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="新建文章步骤："><a href="#新建文章步骤：" class="headerlink" title="新建文章步骤："></a>新建文章步骤：</h1><p>1.在你的博客目录下，右键Git Bash Here。输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章的名字&quot;</span><br></pre></td></tr></table></figure><p>2.在博客目录下/source/_posts/文件夹下，会生成”文章的名字.md”文件</p><p>3.在文件中编辑博客内容。hexo发布的文章是Markdown格式的文件。我使用的Typora软件进行编辑的。Markdown语法可以参考如下网址：<a href="http://www.markdown.cn/">语法网址</a>。</p><p>4.给文章添加分类和标签：在md文件中设置tags和categories属性就行了。</p><p>5.hexo s，启动本地服务器进行测试</p><p>6.hexo clean：清楚命令</p><p>hexo g：重新生成</p><p>hexo d：发布命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="2021/06/02/ros/"/>
      <url>2021/06/02/ros/</url>
      
        <content type="html"><![CDATA[<p>机器人操作系统(ROS)是一个用于编写机器人软件的灵活框架。它是一个工具、库和约定的集合，旨在简化跨各种机器人平台创建复杂和健壮的机器人行为的任务。ROS操作系统是目前使用最广泛的开源机器人软件平台，在无人驾驶系统的实现上，ROS是开源框架中的最好的选择。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。</p><span id="more"></span><p>ROS1.0的架构核心是基于message的松耦合、分布式架构。核心概念有：Node、Master、Message、Topic、Services等。因为ROS1.0在设计之初没有考虑到安全问题，所以ROS 1.0框架主要安全风险充分暴露：匿名通信无身份认证、消息明文传输、缺少访问控制等。</p><p>ROS2.0采用DDS替换了ROS1.0的publish-subscribe通信机制，因为DDS本身是有Security安全协议规范的，因此ROS2.0的安全主要基于DDS-Security。</p><p>DDS-Security规范对DDS规范进行了扩展，通过定义服务插件接口(Service Plugin Interface，SPI)体系结构、SPI的一组内置实现以及SPI实施的安全模型，增加了安全增强功能。具体地说，定义了五个SPI：</p><p>身份验证：验证给定域参与者的身份。</p><p>访问控制：对可由验证域参与者执行的与DDS相关的操作实施限制。 </p><p>加密：处理所有必需的加密、签名和散列操作。</p><p>日志记录：提供审计与DDS安全相关的事件的能力。 </p><p>数据标记：提供向数据样本添加标记的功能。</p><p>ROS 2的安全功能目前只使用前三个功能。这是因为为了符合DDS-Security规范，既不需要日志记录，也不需要数据标记，因此并不是所有的DDS实现都支持它们。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 自动驾驶操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/25/hello-world/"/>
      <url>2021/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
