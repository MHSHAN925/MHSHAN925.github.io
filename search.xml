<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>7-18</title>
      <link href="2021/07/18/7-18/"/>
      <url>2021/07/18/7-18/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题10-02-变位词组"><a href="#面试题10-02-变位词组" class="headerlink" title="面试题10.02.变位词组"></a>面试题10.02.变位词组</h1><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p><p>注意：本题相对原题稍作修改</p><p>示例:</p><p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p><p>思路：变位词是指字母相同，排列不同的字符串。我们可以对同一类的变位词排序，将排序之后的（同一类的当然key相同）key作为map的key，用同一个list保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;String&gt;&gt; group(String[] strs)&#123;</span><br><span class="line">     HashMap&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">     for (String ss : strs)&#123;</span><br><span class="line">         char[] c = ss.toCharArray();</span><br><span class="line">         Arrays.sort(c);</span><br><span class="line">         String key = new String(c);</span><br><span class="line">         System.out.println(key);</span><br><span class="line">         System.out.println(&quot;===&quot;);</span><br><span class="line">         List&lt;String&gt; list = hashMap.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class="line">         list.add(ss);</span><br><span class="line">         hashMap.put(key, list);</span><br><span class="line">     &#125;</span><br><span class="line">     return new ArrayList&lt;&gt;(hashMap.values());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路2：一样的原理，同一类变位词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">     List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">     Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">     for (String s : strs) &#123;</span><br><span class="line">         int[] cnts = new int[26];</span><br><span class="line">         for (char c : s.toCharArray()) cnts[c - &#x27;a&#x27;]++;</span><br><span class="line">         StringBuilder sb = new StringBuilder();</span><br><span class="line">         for (int i : cnts) sb.append(i + &quot;_&quot;);</span><br><span class="line">         String key = sb.toString();</span><br><span class="line">         List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class="line">         list.add(s);</span><br><span class="line">         map.put(key, list);</span><br><span class="line">     &#125;</span><br><span class="line">     for (String key : map.keySet()) ans.add(map.get(key));</span><br><span class="line">     return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-17</title>
      <link href="2021/07/17/7-17/"/>
      <url>2021/07/17/7-17/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer42：连续子数组的最大和"><a href="#剑指offer42：连续子数组的最大和" class="headerlink" title="剑指offer42：连续子数组的最大和"></a>剑指offer42：连续子数组的最大和</h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>暴力递归：遍历数组，以i为子数组开始的所有子数组。并且比较大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">    int ans = Integer.MIN_VALUE;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        for (int j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum = sum + nums[j];</span><br><span class="line">            if (sum &gt; ans)&#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>如果当前子数组加上下一位变小了，说明需要重新选择子数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">        int currSum = 0;</span><br><span class="line">        int maxSum = Integer.MIN_VALUE;       //全负情况，返回最大数</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            currSum = (nums[j] &gt; currSum + nums[j]) ? nums[j] : currSum + nums[j];</span><br><span class="line">            maxSum = (maxSum &gt; currSum) ? maxSum : currSum;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转换成动态规划的过程：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        for(int j = 1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(dp[j-1]&gt;0)&#123;</span><br><span class="line">                dp[j] = dp[j-1]+nums[j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[j] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            if(dp[i]&gt;max)</span><br><span class="line">                max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-16</title>
      <link href="2021/07/17/7-16/"/>
      <url>2021/07/17/7-16/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer53：在排序数组中查找数字1"><a href="#剑指offer53：在排序数组中查找数字1" class="headerlink" title="剑指offer53：在排序数组中查找数字1"></a>剑指offer53：在排序数组中查找数字1</h1><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6</p><p>第一种可以放在一个map中，第二种可以遍历。这两种的时间复杂度都是o（n）的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target)&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            hashMap.put(nums[i], hashMap.getOrDefault(nums[i], 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return hashMap.get(target) != null ? hashMap.get(target) : 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>利用数组已经排序的特点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记day01</title>
      <link href="2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/"/>
      <url>2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记01"><a href="#操作系统笔记01" class="headerlink" title="操作系统笔记01"></a>操作系统笔记01</h1><h2 id="Hello-OS："><a href="#Hello-OS：" class="headerlink" title="Hello OS："></a>Hello OS：</h2><p>引导程序：机器加电启动后，整个计算机第一个启动的程序就是固化在PC主板上的BIOS固件，它启动之后检测系统参数，如内存的大小、日期和时间、磁盘设备以及这些磁盘设备用来引导的顺序。BIOS寻找用于装载操作系统的指令。装载操作系统的这个程序就是boot loader。Linux系统默认的boot loader就是GRUB（GRand Unified Bootloader），于是PC上电以后系统启动流程如下。<br><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\操作引导图.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="lable"></p><p>接下来我们要做的就是写一个由GRUB引导的“操作系统”——它会在屏幕上显示“Hello OS“。**注：**其实操作系统归根结底也是一个程序，只不过它在开机之后已经运行，并且权限和功能高的吓人，你可以将它看成是整个计算机应用的**管家角色**。</p><p>1.下载源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/lmos/cosmos/tree/master/</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\helloOs代码结构.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="lable"></p><p>entry.asm:汇编代码，用作GRUB引导调用，关掉中断，设定CPU工作模式，初始化寄存器及c语言运行环境。</p><p>hello.lds:进行链接调用。</p><p>install.md:需要将这个文件里的内容复制到GRUB的cfg配置文件中，才能使电脑开机时找到我们的HelloOS</p><p>main.c:HelloOS的主函数，注意printf不是c语言函数库，而是自己实现的printf也就是vgastr.h。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//彭东 @ 2021.01.09</span><br><span class="line">#include &quot;vgastr.h&quot;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello OS!&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vgastr.h:控制计算机屏幕VGABIOS固件程序显示特定的字符</p><p>Makefile：利用make工具来实现编译源代码主要是将entry.asm、main.c、vgastr.h编译并链接。</p><h2 id="编译操作系统：Makefile文件中已经写了如何编译-操作系统，只是自己目前看不懂。"><a href="#编译操作系统：Makefile文件中已经写了如何编译-操作系统，只是自己目前看不懂。" class="headerlink" title="编译操作系统：Makefile文件中已经写了如何编译 操作系统，只是自己目前看不懂。"></a>编译操作系统：Makefile文件中已经写了如何编译 操作系统，只是自己目前看不懂。</h2><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\编译过程.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-15</title>
      <link href="2021/07/15/7-15/"/>
      <url>2021/07/15/7-15/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2021/07/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2021/07/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="从有序序列中找某个数，第一反应应该是二分。"><a href="#从有序序列中找某个数，第一反应应该是二分。" class="headerlink" title="从有序序列中找某个数，第一反应应该是二分。"></a>从有序序列中找某个数，第一反应应该是二分。</h2><p>二分模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">「二分」模板其实有两套，主要是根据 check(mid) 函数为 true 时，需要调整的是 l 指针还是 r 指针来判断。</span><br><span class="line"></span><br><span class="line">当 check(mid) == true 调整的是 l 时：计算 mid 的方式应该为 mid = l + r + 1 &gt;&gt; 1：</span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line">long l = 0, r = 1000009;</span><br><span class="line">while (l &lt; r) &#123;</span><br><span class="line">    long mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">    if (check(mid)) &#123;</span><br><span class="line">        l = mid;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当 check(mid) == true 调整的是 r 时：计算 mid 的方式应该为 mid = l + r &gt;&gt; 1：</span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line">long l = 0, r = 1000009;</span><br><span class="line">while (l &lt; r) &#123;</span><br><span class="line">    long mid = l + r &gt;&gt; 1;</span><br><span class="line">    if (check(mid)) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode33：搜索旋转排序数组"><a href="#leetcode33：搜索旋转排序数组" class="headerlink" title="leetcode33：搜索旋转排序数组"></a>leetcode33：搜索旋转排序数组</h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br>示例 2：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br>示例 3：</p><p>输入：nums = [1], target = 0<br>输出：-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target)&#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    int left = 0, right = nums.length;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)&#123;</span><br><span class="line">        if (nums[i] &gt; nums[i + 1])&#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = binarySearch(0, index, target, nums);</span><br><span class="line">    if (ans != -1)&#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    if (index + 1 &lt; nums.length)&#123;</span><br><span class="line">        ans = binarySearch(index + 1, nums.length - 1, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//区间为[]</span><br><span class="line">private static int binarySearch(int left, int right, int target, int[] nums) &#123;</span><br><span class="line">    while (left &lt;= right)&#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分不是单纯的指从有序数组中快速找到某个数，这只是二分的一份应用。</p><p>二分的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质就可以用二分。</p><h1 id="leetcode29：两数相除"><a href="#leetcode29：两数相除" class="headerlink" title="leetcode29：两数相除"></a>leetcode29：两数相除</h1><p>题目：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><p>示例 1:</p><p>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3<br>示例 2:</p><p>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter实战</title>
      <link href="2021/07/14/Flutter%E5%AE%9E%E6%88%98/"/>
      <url>2021/07/14/Flutter%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h5 id="原生开发："><a href="#原生开发：" class="headerlink" title="原生开发："></a>原生开发：</h5><p>原生应用程序是指某一个移动平台（比如iOS或安卓）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。原生开发有以下主要优势：</p><ul><li>可访问平台全部功能（GPS、摄像头）；</li><li>速度快、性能高、可以实现复杂动画及绘制，整体用户体验好；</li></ul><p>主要缺点：</p><ul><li>平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大；</li><li>内容固定，动态化弱，大多数情况下，有新功能更新时只能发版；</li></ul><p>在移动互联网发展初期，业务场景并不复杂，原生开发还可以应对产品需求迭代。 但近几年，随着物联网时代到来、移动互联网高歌猛进，日新月异，在很多业务场景中，传统的纯原生开发已经不能满足日益增长的业务需求。主要表现在：</p><ul><li>动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，所以，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。</li><li>业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。</li></ul><p>总结一下，纯原生开发主要面临动态化和开发成本两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。</p><h5 id="跨平台技术"><a href="#跨平台技术" class="headerlink" title="跨平台技术"></a>跨平台技术</h5><p>针对原生开发面临问题，人们一直都在努力寻找好的解决方案，而时至今日，已经有很多跨平台框架(注意，本书中所指的“跨平台”若无特殊说明，即特指Android和iOS两个平台)，根据其原理，主要分为三类：</p><ul><li>H5+原生（Cordova、Ionic、微信小程序）</li><li>JavaScript开发+原生渲染 （React Native、Weex、快应用）</li><li>自绘UI+原生(QT for mobile、Flutter)</li></ul><p>Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。那么，我们会担心，QT mobile面对的问题Flutter是否也一样，Flutter会不会步入QT mobile后尘，成为另一个烈士？要回到这个问题，我们先来看看Flutter诞生过程：</p><ul><li>2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架——Flutter。</li><li>2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。</li><li>2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。</li></ul><p>观其发展，在2018年5月份，Flutter 进入了 GitHub stars 排行榜前 100 名，已有 27k star。而今天(2019年5月29日)，已经有65K的Star。经历了短短2年多的时间，Flutter 生态系统得以快速增长，由此可见，Flutter在开发者中受到了热烈的欢迎，其未来发展值得期待！</p><p>现在，我们来和QT mobile做一个对比：</p><ol><li>生态：从Github上来看，目前Flutter活跃用户正在高速增长。从Stackoverflow上提问来看，Flutter社区现在已经很庞大。Flutter的文档、资源也越来越丰富，开发过程中遇到的很多问题都可以在Stackoverflow或其github issue中找到答案。</li><li>技术支持：现在Google正在大力推广Flutter，Flutter的作者中很多人都是来自Chromium团队，并且github上活跃度很高。另一个角度，从今年上半年Flutter频繁的版本发布也可以看出Google对Flutter的投入的资源不小，所以在官方技术支持这方面，大可不必担心。</li><li>开发效率：Flutter的热重载可帮助开发者快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以实现毫秒级热重载，并且不会丢失状态。这真的很棒，相信我，如果你是一名原生开发者，体验了Flutter开发流后，很可能就不想重新回去做原生了，毕竟很少有人不吐槽原生开发的编译速度。</li></ol><h5 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h5><p>Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。</p><h6 id="跨平台自绘引擎"><a href="#跨平台自绘引擎" class="headerlink" title="#跨平台自绘引擎"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%87%AA%E7%BB%98%E5%BC%95%E6%93%8E">#</a>跨平台自绘引擎</h6><p>Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。</p><p>Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。</p><p>目前Flutter默认支持iOS、Android、Fuchsia（Google新的自研操作系统）三个移动平台。但Flutter亦可支持Web开发（Flutter for web）和PC开发，本书的示例和介绍主要是基于iOS和Android平台的，其它平台读者可以自行了解。</p><h6 id="高性能"><a href="#高性能" class="headerlink" title="#高性能"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E9%AB%98%E6%80%A7%E8%83%BD">#</a>高性能</h6><p>Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。</p><h6 id="采用Dart语言开发"><a href="#采用Dart语言开发" class="headerlink" title="#采用Dart语言开发"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E9%87%87%E7%94%A8dart%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91">#</a>采用Dart语言开发</h6><p>这是一个很有意思，但也很有争议的问题，在了解Flutter为什么选择了 Dart而不是 JavaScript之前我们先来介绍两个概念：JIT和AOT。</p><p>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。</p><p>现在我们看看Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）：</p><ol><li><p><strong>开发效率高</strong></p><p>Dart运行时和编译器支持Flutter的两个关键特性的组合：</p><p><strong>基于JIT的快速开发周期</strong>：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</p><p><strong>基于AOT的发布包</strong>: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。</p></li><li><p><strong>高性能</strong></p><p>Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。</p></li><li><p><strong>快速内存分配</strong></p><p>Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。</p></li><li><p><strong>类型安全</strong></p><p>由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。</p></li></ol><h6 id="Flutter框架结构"><a href="#Flutter框架结构" class="headerlink" title="Flutter框架结构"></a>Flutter框架结构</h6><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source_posts\flutter.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="flutter"></p><h6 id="Flutter-Framework：这是一个纯-Dart实现的-SDK，它实现了一套基础库，自底向上，我们来简单介绍一下："><a href="#Flutter-Framework：这是一个纯-Dart实现的-SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：" class="headerlink" title="Flutter Framework：这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下："></a>Flutter Framework：这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：</h6><ul><li>底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的<code>dart:ui</code>包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。</li><li>Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。</li><li>Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而<strong>我们Flutter开发的大多数场景，只是和这两层打交道</strong>。</li></ul><h6 id="Flutter-Engine"><a href="#Flutter-Engine" class="headerlink" title="Flutter Engine"></a>Flutter Engine</h6><p>这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 <code>dart:ui</code>库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-14</title>
      <link href="2021/07/14/7-14/"/>
      <url>2021/07/14/7-14/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode1818：绝对差值和"><a href="#leetcode1818：绝对差值和" class="headerlink" title="leetcode1818：绝对差值和"></a>leetcode1818：绝对差值和</h1><p>给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。</p><p>数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。</p><p>你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。</p><p>|x| 定义为：</p><p>如果 x &gt;= 0 ，值为 x ，或者<br>如果 x &lt;= 0 ，值为 -x</p><p>示例 1：</p><p>输入：nums1 = [1,7,5], nums2 = [2,3,5]<br>输出：3<br>解释：有两种可能的最优方案：</p><ul><li>将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者</li><li>将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]<br>两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3<br>示例 2：</li></ul><p>输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]<br>输出：0<br>解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0<br>示例 3：</p><p>输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]<br>输出：20<br>解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] =&gt; [10,10,4,4,2,7]<br>绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20</p><p>解析：这竟然是一道二分查找的题，难道因为刚睡醒一点思路也没有。<img "" class="lazyload placeholder" data-original="file:///C:\Users\ydhc\AppData\Local\Temp\SGPicFaceTpBq\13032\0F7E7DE0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-13</title>
      <link href="2021/07/13/7-13/"/>
      <url>2021/07/13/7-13/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode218天际线问题"><a href="#leetcode218天际线问题" class="headerlink" title="leetcode218天际线问题"></a>leetcode218天际线问题</h1><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p><p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br>righti 是第 i 座建筑物右边缘的 x 坐标。<br>heighti 是第 i 座建筑物的高度。<br>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p><p>具体题目请看<a href="https://leetcode-cn.com/problems/the-skyline-problem/">https://leetcode-cn.com/problems/the-skyline-problem/</a></p><h6 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h6>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter</title>
      <link href="2021/07/13/Flutter/"/>
      <url>2021/07/13/Flutter/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter完整开发实战详解系列"><a href="#Flutter完整开发实战详解系列" class="headerlink" title="Flutter完整开发实战详解系列"></a>Flutter完整开发实战详解系列</h1><p>flutter中所有的组件都是类。</p><h5 id="Flutter-Widget："><a href="#Flutter-Widget：" class="headerlink" title="Flutter Widget："></a>Flutter Widget：</h5><p>在flutter中一切的显示都是widget，widget是一切的基础，利用响应式模式进行渲染。可以修改数据，再用setState设置数据，Flutter会自动通过绑定的数据更新Widget，所以开发者需要做的就是实现Widget，并且和数据绑定。</p><p>Widget分为有状态和无状态两种，在Flutter中每个页面都是一帧，无状态就是保持在那一帧，有状态的Widget当数据更新时，其实是创建了新的Widget，只是State实现了跨帧的数据同步保存。</p><h6 id="无状态的StatelessWidget"><a href="#无状态的StatelessWidget" class="headerlink" title="无状态的StatelessWidget"></a>无状态的StatelessWidget</h6><p>自定义的Widget（类），继承StatelessWidget（抽象类）。通过build方法返回一个布局好的控件。Widget和Widget之间通过child进行嵌套，有的Widget只能有一个child（比如container），有的可以有多个child（比如Column布局）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class DemoWidget extends StatelessWidget&#123;</span><br><span class="line">  //数据可以通过构造方法传递进来</span><br><span class="line">  final String? text;</span><br><span class="line">  DemoWidget(this.text);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    //throw UnimplementedError();</span><br><span class="line">    //这里返回需要的控件</span><br><span class="line">    return Container(</span><br><span class="line">      //蓝色背景</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">      //在Dart语法中，？？表示如果text为空，返回尾号后的内容</span><br><span class="line">      child: Text(text ?? &quot;这就是无状态的Demo&quot;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="有状态的StatefulWidget"><a href="#有状态的StatefulWidget" class="headerlink" title="有状态的StatefulWidget"></a>有状态的StatefulWidget</h6><p>需要创建管理的主要是State，通过State的build方法构建控件。在State中可以动态改变数据，在setState之后，改变的数据会触发Widget重新构建刷新</p><p>State中的声明周期有：initState：初始化，理论上只有一次，有特殊情况。</p><p>didChangeDependencies：在initState之后调用，此时可以获取其他State</p><p>dispose：销毁，只会调用一次</p><p>综上：flutter中的关注点：创建StatelessWidget或者StatefulWidget，需要的就是在build中堆积你的布局，然后把数据添加到Widget中，最后通过setState改变数据，实现画面变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:async&#x27;;</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class DemoStateWidget extends StatefulWidget&#123;</span><br><span class="line">  //通过构造方法传值</span><br><span class="line">  final String text;</span><br><span class="line">  DemoStateWidget(this.text);</span><br><span class="line"></span><br><span class="line">  //主要是负责创建state</span><br><span class="line">  @override</span><br><span class="line">  _DemoStateWidgetState createState() &#123;</span><br><span class="line">    // TODO: implement createState</span><br><span class="line">    throw UnimplementedError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _DemoStateWidgetState extends State&lt;DemoStateWidget&gt;&#123;</span><br><span class="line">  //同样通过构造方法传值</span><br><span class="line">  String text;</span><br><span class="line">  _DemoStateWidgetState(this.text);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    //初始化，这个函数在声明周期中只调用一次</span><br><span class="line">    // TODO: implement initState</span><br><span class="line">    super.initState();</span><br><span class="line">    //定时一秒</span><br><span class="line">    new Future.delayed(const Duration(seconds: 1),())&#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        text = &quot;这就遍历数值&quot;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    //销毁</span><br><span class="line">    // TODO: implement dispose</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void didChangeDependencies() &#123;</span><br><span class="line">    //在initState之后</span><br><span class="line">    // TODO: implement didChangeDependencies</span><br><span class="line">    super.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    //throw UnimplementedError();</span><br><span class="line">    return Container(</span><br><span class="line">      child: Text(text ?? &quot;这就是有状态的Demo&quot;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Flutter布局"><a href="#Flutter布局" class="headerlink" title="Flutter布局"></a>Flutter布局</h5><p>Flutter 中拥有需要将近 30 种内置的 布局 Widget ，其中常⽤有Container 、<br>Padding 、 Center 、 Flex 、 Stack 、 Row 、 Column 、 ListView 等，</p><h6 id="Container：只有⼀个⼦Widget-。默认充满，包含了-padding-、"><a href="#Container：只有⼀个⼦Widget-。默认充满，包含了-padding-、" class="headerlink" title="Container：只有⼀个⼦Widget 。默认充满，包含了 padding 、"></a>Container：只有⼀个⼦Widget 。默认充满，包含了 padding 、</h6><p>margin 、 color 、宽⾼、 decoration 等配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">最常⽤的默认控件，但是实际上它是由多个内置控件组</span><br><span class="line">成的模版，只能包含⼀个child ，⽀持padding,margin,color, 宽</span><br><span class="line">⾼ ,decoration （⼀般配置边框和阴影）等配置，在Flutter 中，不是</span><br><span class="line">所有的控件都有宽⾼、 padding 、 margin 、 color 等属性，所以才会</span><br><span class="line">有Padding 、 Center 等Widget 的存在。</span><br><span class="line"></span><br><span class="line">new Container(</span><br><span class="line">/// 四周 10 ⼤⼩的 maring</span><br><span class="line">margin: EdgeInsets.all(10.0),</span><br><span class="line">height: 120.0,</span><br><span class="line">width: 500.0,</span><br><span class="line">/// 透明⿊⾊遮罩</span><br><span class="line">decoration: new BoxDecoration(</span><br><span class="line">/// 弧度为 4.0</span><br><span class="line">borderRadius: BorderRadius.all(Radius.circula</span><br><span class="line">/// 设置了 decoration 的 color ，就不能设置 Container 的</span><br><span class="line">color: Colors.black,</span><br><span class="line">/// 边框</span><br><span class="line">border: new Border.all(color: Color(GSYColors</span><br><span class="line">child:new Text(&quot;666666&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Padding：只有⼀个⼦Widget-。只⽤于设置-Padding-，常⽤于嵌"><a href="#Padding：只有⼀个⼦Widget-。只⽤于设置-Padding-，常⽤于嵌" class="headerlink" title="Padding：只有⼀个⼦Widget 。只⽤于设置 Padding ，常⽤于嵌"></a>Padding：只有⼀个⼦Widget 。只⽤于设置 Padding ，常⽤于嵌</h6><p>套 child ，给 child 设置 padding </p><h6 id="Center：只有⼀个⼦Widget-。只⽤于居中显示，常⽤于嵌套"><a href="#Center：只有⼀个⼦Widget-。只⽤于居中显示，常⽤于嵌套" class="headerlink" title="Center：只有⼀个⼦Widget 。只⽤于居中显示，常⽤于嵌套"></a>Center：只有⼀个⼦Widget 。只⽤于居中显示，常⽤于嵌套</h6><p>child ，给 child 设置居中</p><h6 id="Stack：可以有多个⼦Widget-。⼦-Widget-堆叠在⼀起。"><a href="#Stack：可以有多个⼦Widget-。⼦-Widget-堆叠在⼀起。" class="headerlink" title="Stack：可以有多个⼦Widget 。⼦ Widget 堆叠在⼀起。"></a>Stack：可以有多个⼦Widget 。⼦ Widget 堆叠在⼀起。</h6><h6 id="Column：可以有多个⼦Widget-。垂直布局"><a href="#Column：可以有多个⼦Widget-。垂直布局" class="headerlink" title="Column：可以有多个⼦Widget 。垂直布局"></a>Column：可以有多个⼦Widget 。垂直布局</h6><h6 id="Row：可以有多个⼦Widget-。⽔平布局"><a href="#Row：可以有多个⼦Widget-。⽔平布局" class="headerlink" title="Row：可以有多个⼦Widget 。⽔平布局"></a>Row：可以有多个⼦Widget 。⽔平布局</h6><p>Column 、 Row 绝对是必备布局， 横竖布局也是⽇常中最常⻅的场<br>景。如下⽅所示，它们常⽤的有这些属性配置：主轴⽅向是 start 或<br>center 等；副轴⽅向⽅向是start 或center 等； mainAxisSize 是充满<br>最⼤尺⼨，或者只根据⼦Widget 显示最⼩尺⼨</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 主轴⽅向， Column 的竖向、 Row 我的横向</span><br><span class="line">mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">// 默认是最⼤充满、还是根据 child 显示最⼩⼤⼩</span><br><span class="line">mainAxisSize: MainAxisSize.max,</span><br><span class="line">// 副轴⽅向， Column 的横向、 Row 我的竖向</span><br><span class="line">crossAxisAlignment :CrossAxisAlignment.center,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Expanded：只有⼀个⼦Widget-。在Column-和Row-中充满。"><a href="#Expanded：只有⼀个⼦Widget-。在Column-和Row-中充满。" class="headerlink" title="Expanded：只有⼀个⼦Widget 。在Column 和Row 中充满。"></a>Expanded：只有⼀个⼦Widget 。在Column 和Row 中充满。</h6><p>Expanded 在Column 和Row 中代表着平均充满的作⽤，当有两个存在的时候默认均分充满。同时⻚可以设置flex 属性决定⽐例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Column(</span><br><span class="line">/// 主轴居中 , 即是竖直向居中</span><br><span class="line">mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">/// ⼤⼩按照最⼩显示</span><br><span class="line">mainAxisSize : MainAxisSize.min,</span><br><span class="line">/// 横向也居中</span><br><span class="line">crossAxisAlignment : CrossAxisAlignment.center,</span><br><span class="line">children: &lt;Widget&gt;[</span><br><span class="line">///flex 默认为 1</span><br><span class="line">new Expanded(child: new Text(&quot;1111&quot;), flex: 2,),</span><br><span class="line">new Expanded(child: new Text(&quot;2222&quot;)),</span><br><span class="line">],</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="ListView：可以有多个子Widget"><a href="#ListView：可以有多个子Widget" class="headerlink" title="ListView：可以有多个子Widget"></a>ListView：可以有多个子Widget</h6><h5 id="Flutter页面"><a href="#Flutter页面" class="headerlink" title="Flutter页面"></a>Flutter页面</h5><p>Flutter 中除了布局的Widget ，还有交互显示的Widget 和完整⻚⾯呈现的<br>Widget ，其中常⻅的有MaterialApp 、 Scaffold 、 Appbar 、 Text 、 Image 、FlatButton 等</p><h6 id="MaterialApp：⼀般作为-APP-顶层的主⻚⼊⼝，可配置主题，多语"><a href="#MaterialApp：⼀般作为-APP-顶层的主⻚⼊⼝，可配置主题，多语" class="headerlink" title="MaterialApp：⼀般作为 APP 顶层的主⻚⼊⼝，可配置主题，多语"></a>MaterialApp：⼀般作为 APP 顶层的主⻚⼊⼝，可配置主题，多语</h6><p>⾔，路由等</p><h6 id="Scaffold：⼀般⽤户⻚⾯的承载-Widget-，包含-appbar-、snackbar-、-drawer-等-material-design-的设定"><a href="#Scaffold：⼀般⽤户⻚⾯的承载-Widget-，包含-appbar-、snackbar-、-drawer-等-material-design-的设定" class="headerlink" title="Scaffold：⼀般⽤户⻚⾯的承载 Widget ，包含 appbar 、snackbar 、 drawer 等 material design 的设定"></a>Scaffold：⼀般⽤户⻚⾯的承载 Widget ，包含 appbar 、snackbar 、 drawer 等 material design 的设定</h6><h6 id="Appbar：⼀般⽤于-Scaffold-的-appbar-，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些，-tabbar-等也会需要它"><a href="#Appbar：⼀般⽤于-Scaffold-的-appbar-，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些，-tabbar-等也会需要它" class="headerlink" title="Appbar：⼀般⽤于 Scaffold 的 appbar ，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些， tabbar 等也会需要它"></a>Appbar：⼀般⽤于 Scaffold 的 appbar ，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些， tabbar 等也会需要它</h6><h6 id="Text：显示⽂本，⼏乎都会⽤到，主要是通过-style-设置TextStyle-来设置字体样式等"><a href="#Text：显示⽂本，⼏乎都会⽤到，主要是通过-style-设置TextStyle-来设置字体样式等" class="headerlink" title="Text：显示⽂本，⼏乎都会⽤到，主要是通过 style 设置TextStyle 来设置字体样式等"></a>Text：显示⽂本，⼏乎都会⽤到，主要是通过 style 设置TextStyle 来设置字体样式等</h6><h6 id="RichText：富⽂本，通过设置TextSpan-，可以拼接出富⽂本场景。"><a href="#RichText：富⽂本，通过设置TextSpan-，可以拼接出富⽂本场景。" class="headerlink" title="RichText：富⽂本，通过设置TextSpan ，可以拼接出富⽂本场景。"></a>RichText：富⽂本，通过设置TextSpan ，可以拼接出富⽂本场景。</h6><h6 id="TextField：⽂本输⼊框-：new-TextField-controller-⽂本控制器-obscureText-“hint-⽂本-“"><a href="#TextField：⽂本输⼊框-：new-TextField-controller-⽂本控制器-obscureText-“hint-⽂本-“" class="headerlink" title="TextField：⽂本输⼊框 ：new TextField(controller: // ⽂本控制器 , obscureText: “hint ⽂本 “);"></a>TextField：⽂本输⼊框 ：new TextField(controller: // ⽂本控制器 , obscureText: “hint ⽂本 “);</h6><h6 id="Image：图⽚加载-new-FadeInImage-assetNetwork"><a href="#Image：图⽚加载-new-FadeInImage-assetNetwork" class="headerlink" title="Image：图⽚加载 : new FadeInImage.assetNetwork("></a>Image：图⽚加载 : new FadeInImage.assetNetwork(</h6><p>placeholder: “ 预览图 “, </p><p>fit:BoxFit.fitWidth, </p><p>image: “url”);</p><h6 id="FlatButton：按键点击-new-FlatButton-onPressed-child-new-Container"><a href="#FlatButton：按键点击-new-FlatButton-onPressed-child-new-Container" class="headerlink" title="FlatButton：按键点击 : new FlatButton(onPressed: (){},child: new Container());"></a>FlatButton：按键点击 : new FlatButton(onPressed: (){},child: new Container());</h6>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DartDay2</title>
      <link href="2021/07/12/DartDay2/"/>
      <url>2021/07/12/DartDay2/</url>
      
        <content type="html"><![CDATA[<h1 id="DartDay2"><a href="#DartDay2" class="headerlink" title="DartDay2"></a>DartDay2</h1><h6 id="静态属性和静态方法，可以通过类来访问不用通过实例"><a href="#静态属性和静态方法，可以通过类来访问不用通过实例" class="headerlink" title="静态属性和静态方法，可以通过类来访问不用通过实例"></a>静态属性和静态方法，可以通过类来访问不用通过实例</h6><p>Dart中的静态成员:</p><p>  1、使用static 关键字来实现类级别的变量和函数</p><p>  2、静态方法不能访问非静态成员，非静态方法可以访问静态成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// class Person &#123;</span><br><span class="line">//   static String name = &#x27;张三&#x27;;</span><br><span class="line">//   static void show() &#123;</span><br><span class="line">//     print(name);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// main()&#123;</span><br><span class="line">//   print(Person.name);</span><br><span class="line">//   Person.show();  </span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  static String name = &#x27;张三&#x27;;</span><br><span class="line">  int age=20;  </span><br><span class="line">  static void show() &#123;</span><br><span class="line">    print(name);</span><br><span class="line">  &#125;</span><br><span class="line">  void printInfo()&#123;  /*非静态方法可以访问静态成员以及非静态成员*/</span><br><span class="line">      // print(name);  //访问静态属性</span><br><span class="line">      // print(this.age);  //访问非静态属性</span><br><span class="line">      show();   //调用静态方法</span><br><span class="line">  &#125;</span><br><span class="line">  static void printUserInfo()&#123;//静态方法</span><br><span class="line">        print(name);   //静态属性</span><br><span class="line">        show();        //静态方法</span><br><span class="line"></span><br><span class="line">        //print(this.age);     //静态方法没法访问非静态的属性</span><br><span class="line">        // this.printInfo();   //静态方法没法访问非静态的方法</span><br><span class="line">        // printInfo();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对象操作符："><a href="#对象操作符：" class="headerlink" title="对象操作符："></a>对象操作符：</h6><p>/*<br>Dart中的对象操作符:</p><pre><code>?     条件运算符 （了解）   https://dart.dev/tools/diagnostic-messages#invalid_null_aware_operator        as    类型转换is    类型判断..    级联操作 （连缀）  (记住)</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age;</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">？用法</span><br><span class="line">main() &#123;</span><br><span class="line">  // Person p;</span><br><span class="line">  // p?.printInfo();   //已被最新的dart废弃 了解</span><br><span class="line"></span><br><span class="line">  //  Person p=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  //  p?.printInfo();   //已被最新的dart废弃 了解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">is用法</span><br><span class="line">  // Person p=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  // if(p is Person)&#123;</span><br><span class="line">  //     p.name=&quot;李四&quot;;</span><br><span class="line">  // &#125;</span><br><span class="line">  // p.printInfo();</span><br><span class="line">  // print(p is Object);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">as用法</span><br><span class="line">  // var p1;</span><br><span class="line"></span><br><span class="line">  // p1=&#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">  // p1=new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  // // p1.printInfo();</span><br><span class="line">  // (p1 as Person).printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">级联操作</span><br><span class="line">  //  Person p1=new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  //  p1.printInfo();</span><br><span class="line"></span><br><span class="line">  //  p1.name=&#x27;张三222&#x27;;</span><br><span class="line">  //  p1.age=40;</span><br><span class="line">  //  p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Person p1 = new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line">  p1.printInfo();</span><br><span class="line">  p1</span><br><span class="line">    ..name = &quot;李四&quot;</span><br><span class="line">    ..age = 30</span><br><span class="line">    ..printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">面向对象的三大特性：封装 、继承、多态</span><br><span class="line"></span><br><span class="line">Dart中的类的继承：  </span><br><span class="line">    1、子类使用extends关键词来继承父类</span><br><span class="line">    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数</span><br><span class="line">    3、子类能复写父类的方法 getter和setter</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为父类构造函数无法继承</span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  // Person p=new Person(&#x27;李四&#x27;,20);</span><br><span class="line">  // p.printInfo();</span><br><span class="line"></span><br><span class="line">  // Person p1=new Person(&#x27;张三&#x27;,20);</span><br><span class="line">  // p1.printInfo();</span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;张三&#x27;, 12);</span><br><span class="line">  w.printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">面向对象的三大特性：封装 、继承、多态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dart中的类的继承：  </span><br><span class="line">    1、子类使用extends关键词来继承父类</span><br><span class="line">    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数</span><br><span class="line">    3、子类能复写父类的方法 getter和setter</span><br><span class="line"></span><br><span class="line">   注意:最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">在子类中扩展属性和方法</span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  late String sex;</span><br><span class="line">  Web(String name, num age,String sex) : super(name, age)&#123;</span><br><span class="line">    this.sex=sex;</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">   print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;--$&#123;this.sex&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  // Person p=new Person(&#x27;李四&#x27;,20);</span><br><span class="line">  // p.printInfo();</span><br><span class="line"></span><br><span class="line">  // Person p1=new Person(&#x27;张三&#x27;,20);</span><br><span class="line">  // p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;张三&#x27;, 12,&quot;男&quot;);</span><br><span class="line"></span><br><span class="line">  w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给匿名的构造函数传参</span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age;</span><br><span class="line">  //给匿名的构造函数传参</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  Person.xxx(this.name, this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person &#123;</span><br><span class="line">  late String sex;</span><br><span class="line">  Web(String name, num age, String sex) : super.xxx(name, age) &#123;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;--$&#123;this.sex&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中重写父类的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">  work()&#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;在工作...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age);</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">    super.work();  //自类调用父类的方法</span><br><span class="line">  &#125;</span><br><span class="line">  //覆写父类的方法</span><br><span class="line">  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override </span><br><span class="line">  void printInfo()&#123;</span><br><span class="line">     print(&quot;姓名：$&#123;this.name&#125;---年龄：$&#123;this.age&#125;&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;李四&#x27;,20);</span><br><span class="line"></span><br><span class="line">  // w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.run();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类中调用父类的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">  work()&#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;在工作...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age);</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">    super.work();  //自类调用父类的方法</span><br><span class="line">  &#125;</span><br><span class="line">  //覆写父类的方法</span><br><span class="line">  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override </span><br><span class="line">  void printInfo()&#123;</span><br><span class="line">     print(&quot;姓名：$&#123;this.name&#125;---年龄：$&#123;this.age&#125;&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h6><p>/*<br>Dart中抽象类: Dart抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。</p><p>  1、抽象类通过abstract 关键字来定义</p><p>  2、Dart中的抽象方法不能用abstract声明，Dart中没有方法体的方法我们称为抽象方法。</p><p>  3、如果子类继承抽象类必须得实现里面的抽象方法</p><p>  4、如果把抽象类当做接口实现的话必须得实现抽象类里面定义的所有属性和方法。</p><p>  5、抽象类不能被实例化，只有继承它的子类可以</p><p>extends抽象类 和 implements的区别：</p><p>  1、如果要复用抽象类里面的方法，并且要用抽象方法约束自类的话我们就用extends继承抽象类</p><p>  2、如果只是把抽象类当做标准的话我们就用implements实现抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">案例：定义一个Animal 类要求它的子类必须包含eat方法</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">  eat();   //抽象方法</span><br><span class="line">  run();  //抽象方法  </span><br><span class="line">  printInfo()&#123;  //非抽象方法</span><br><span class="line">    print(&#x27;我是一个抽象类里面的普通方法&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">     print(&#x27;小狗在吃骨头&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    // TODO: implement run</span><br><span class="line">    print(&#x27;小狗在跑&#x27;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">    // TODO: implement eat</span><br><span class="line">    print(&#x27;小猫在吃老鼠&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    // TODO: implement run</span><br><span class="line">    print(&#x27;小猫在跑&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">  Dog d=new Dog();</span><br><span class="line">  d.eat();</span><br><span class="line">  d.printInfo();</span><br><span class="line"></span><br><span class="line">   Cat c=new Cat();</span><br><span class="line">  c.eat();</span><br><span class="line">  c.printInfo();</span><br><span class="line"></span><br><span class="line">  // Animal a=new Animal();   //抽象类没法直接被实例化</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Datr中的多态：</span><br><span class="line">    允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。</span><br><span class="line"></span><br><span class="line">    子类的实例赋值给父类的引用。</span><br><span class="line">    </span><br><span class="line">    多态就是父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">  eat();   //抽象方法 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">     print(&#x27;小狗在吃骨头&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;   </span><br><span class="line">    print(&#x27;小猫在吃老鼠&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">  // Dog d=new Dog();</span><br><span class="line">  // d.eat();</span><br><span class="line">  // d.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Cat c=new Cat();</span><br><span class="line">  // c.eat();</span><br><span class="line"></span><br><span class="line">  Animal d=new Dog();</span><br><span class="line"></span><br><span class="line">  d.eat();</span><br><span class="line">  Animal c=new Cat();</span><br><span class="line"></span><br><span class="line">  c.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="接口：进行文件分离"><a href="#接口：进行文件分离" class="headerlink" title="接口：进行文件分离"></a>接口：进行文件分离</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">和Java一样，dart也有接口，但是和Java还是有区别的。</span><br><span class="line"></span><br><span class="line">  首先，dart的接口没有interface关键字定义接口，而是普通类或抽象类都可以作为接口被实现。</span><br><span class="line"></span><br><span class="line">  同样使用implements关键字进行实现。</span><br><span class="line"></span><br><span class="line">  但是dart的接口有点奇怪，如果实现的类是普通类，会将普通类和抽象中的属性的方法全部需要覆写一遍。</span><br><span class="line">  </span><br><span class="line">  而因为抽象类可以定义抽象方法，普通类不可以，所以一般如果要实现像Java接口那样的方式，一般会使用抽象类。</span><br><span class="line"></span><br><span class="line">  建议使用抽象类定义接口。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">定义一个DB库 支持 mysql  mssql  mongodb</span><br><span class="line"></span><br><span class="line">mysql  mssql  mongodb三个类里面都有同样的方法</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Db&#123;   //当做接口   接口：就是约定 、规范</span><br><span class="line">    late String uri;      //数据库的链接地址</span><br><span class="line">    add(String data);</span><br><span class="line">    save();</span><br><span class="line">    delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mysql implements Db&#123;</span><br><span class="line">  </span><br><span class="line">  @override</span><br><span class="line">  String uri;</span><br><span class="line"></span><br><span class="line">  Mysql(this.uri);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  add(data) &#123;</span><br><span class="line">    // TODO: implement add</span><br><span class="line">    print(&#x27;这是mysql的add方法&#x27;+data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  delete() &#123;</span><br><span class="line">    // TODO: implement delete</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  save() &#123;</span><br><span class="line">    // TODO: implement save</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove()&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MsSql implements Db&#123;</span><br><span class="line">  @override</span><br><span class="line">  late String uri;</span><br><span class="line">  @override</span><br><span class="line">  add(String data) &#123;</span><br><span class="line">    print(&#x27;这是mssql的add方法&#x27;+data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  delete() &#123;</span><br><span class="line">    // TODO: implement delete</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  save() &#123;</span><br><span class="line">    // TODO: implement save</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">  Mysql mysql=new Mysql(&#x27;xxxxxx&#x27;);</span><br><span class="line"></span><br><span class="line">  mysql.add(&#x27;1243214&#x27;);</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="Dart中一个类实现多个接口"><a href="#Dart中一个类实现多个接口" class="headerlink" title="Dart中一个类实现多个接口"></a>Dart中一个类实现多个接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Dart中一个类实现多个接口：</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">abstract class A&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  printA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class B&#123;</span><br><span class="line">  printB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implements A,B&#123;  </span><br><span class="line">  @override</span><br><span class="line">  late String name;  </span><br><span class="line">  @override</span><br><span class="line">  printA() &#123;</span><br><span class="line">    print(&#x27;printA&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  printB() &#123;</span><br><span class="line">    // TODO: implement printB</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  C c=new C();</span><br><span class="line">  c.printA();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mixins："><a href="#mixins：" class="headerlink" title="mixins："></a>mixins：</h6><p>/*<br>mixins的中文意思是混入，就是在类中混入其他功能。</p><p>在Dart中可以使用mixins实现类似多继承的功能</p><p>因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.x中使用mixins的条件：</p><p>  1、作为mixins的类只能继承自Object，不能继承其他类<br>  2、作为mixins的类不能有构造函数<br>  3、一个类可以mixins多个mixins类<br>  4、mixins绝不是继承，也不是接口，而是一种全新的特性<br>*/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  String info=&quot;this is A&quot;;</span><br><span class="line">  void printA()&#123;</span><br><span class="line">    print(&quot;A&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  void printB()&#123;</span><br><span class="line">    print(&quot;B&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C with A,B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  var c=new C();  </span><br><span class="line">  c.printA();</span><br><span class="line">  c.printB();</span><br><span class="line">  print(c.info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">mixins的实例类型是什么？</span><br><span class="line"></span><br><span class="line">很简单，mixins的类型就是其超类的子类型。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  String info=&quot;this is A&quot;;</span><br><span class="line">  void printA()&#123;</span><br><span class="line">    print(&quot;A&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  void printB()&#123;</span><br><span class="line">    print(&quot;B&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C with A,B&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;  </span><br><span class="line">   var c=new C();  </span><br><span class="line">   </span><br><span class="line">  print(c is C);    //true</span><br><span class="line">  print(c is A);    //true</span><br><span class="line">  print(c is B);   //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // var a=new A();</span><br><span class="line"></span><br><span class="line">  // print(a is Object);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h6><p>通俗理解：泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持(类型校验)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//只能返回string类型的数据</span><br><span class="line"></span><br><span class="line">  // String getData(String value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//同时支持返回 string类型 和int类型  （代码冗余）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String getData1(String value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // int getData2(int value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//同时返回 string类型 和number类型       不指定类型可以解决这个问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // getData(value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//不指定类型放弃了类型检查。我们现在想实现的是传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型</span><br><span class="line"> 对传入参数和返回参数校验</span><br><span class="line">  // T getData&lt;T&gt;(T value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line">只对传入参数校验</span><br><span class="line">  getData&lt;T&gt;(T value)&#123;</span><br><span class="line">      return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">    // print(getData(21));</span><br><span class="line"></span><br><span class="line">    // print(getData(&#x27;xxx&#x27;));</span><br><span class="line"></span><br><span class="line">    // getData&lt;String&gt;(&#x27;你好&#x27;);</span><br><span class="line"></span><br><span class="line">    print(getData&lt;int&gt;(12));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//集合List 泛型类的用法</span><br><span class="line"></span><br><span class="line">//案例：把下面类转换成泛型类，要求MyList里面可以增加int类型的数据，也可以增加String类型的数据。但是每次调用增加的类型要统一</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">class MyList &#123;</span><br><span class="line">  List list = &lt;int&gt;[];</span><br><span class="line">  void add(int value) &#123;</span><br><span class="line">    this.list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">  List getList() &#123;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyList l = new MyList();</span><br><span class="line">l.add(1);</span><br><span class="line">l.add(12);</span><br><span class="line">l.add(5);</span><br><span class="line">print(l.getList());</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class MyList&lt;T&gt; &#123;</span><br><span class="line">  List list = &lt;T&gt;[];</span><br><span class="line">  void add(T value) &#123;</span><br><span class="line">    this.list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List getList() &#123;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  // MyList l1=new MyList();</span><br><span class="line">  // l1.add(&quot;张三&quot;);</span><br><span class="line">  // l1.add(12);</span><br><span class="line">  // l1.add(true);</span><br><span class="line">  // print(l1.getList());</span><br><span class="line"></span><br><span class="line">  // MyList l2 = new MyList&lt;String&gt;();</span><br><span class="line">  // l2.add(&quot;张三1&quot;);</span><br><span class="line">  // // l2.add(11);  //错误的写法</span><br><span class="line">  // print(l2.getList());</span><br><span class="line"></span><br><span class="line">  MyList l3 = new MyList&lt;int&gt;();</span><br><span class="line">  l3.add(11);</span><br><span class="line">  l3.add(12);</span><br><span class="line">  l3.add(&quot;aaaa&quot;);</span><br><span class="line">  print(l3.getList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // List list = List.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  // List list = new List.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三1&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  // List list = new List&lt;String&gt;.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三1&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  //  List list2 = new List&lt;int&gt;.filled(2, 0);</span><br><span class="line">  //   list2[0] = 12;</span><br><span class="line">  //   list2[1] = 13;</span><br><span class="line">  //   print(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型接口："><a href="#泛型接口：" class="headerlink" title="泛型接口："></a>泛型接口：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Dart中的泛型接口:</span><br><span class="line"></span><br><span class="line">    实现数据缓存的功能：有文件缓存、和内存缓存。内存缓存和文件缓存按照接口约束实现。</span><br><span class="line"></span><br><span class="line">    1、定义一个泛型接口 约束实现它的子类必须有getByKey(key) 和 setByKey(key,value)</span><br><span class="line"></span><br><span class="line">    2、要求setByKey的时候的value的类型和实例化子类的时候指定的类型一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // abstract class ObjectCache &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, Object value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // abstract class StringCache &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, String value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // abstract class Cache&lt;T&gt; &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, T value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Cache&lt;T&gt;&#123;</span><br><span class="line">  getByKey(String key);</span><br><span class="line">  void setByKey(String key, T value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlieCache&lt;T&gt; implements Cache&lt;T&gt;&#123;</span><br><span class="line">  @override</span><br><span class="line">  getByKey(String key) &#123;    </span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void setByKey(String key, T value) &#123;</span><br><span class="line">   print(&quot;我是文件缓存 把key=$&#123;key&#125;  value=$&#123;value&#125;的数据写入到了文件中&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MemoryCache&lt;T&gt; implements Cache&lt;T&gt;&#123;</span><br><span class="line">  @override</span><br><span class="line">  getByKey(String key) &#123;   </span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void setByKey(String key, T value) &#123;</span><br><span class="line">       print(&quot;我是内存缓存 把key=$&#123;key&#125;  value=$&#123;value&#125; -写入到了内存中&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // MemoryCache m=new MemoryCache&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    //  m.setByKey(&#x27;index&#x27;, &#x27;首页数据&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     MemoryCache m=new MemoryCache&lt;Map&gt;();</span><br><span class="line"></span><br><span class="line">     m.setByKey(&#x27;index&#x27;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:20&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Dart中的库"><a href="#Dart中的库" class="headerlink" title="Dart中的库"></a>Dart中的库</h6><p>/*</p><p>前面介绍Dart基础知识的时候基本上都是在一个文件里面编写Dart代码的，但实际开发中不可能这么写，模块化很重要，所以这就需要使用到库的概念。</p><p>在Dart中，库的使用时通过import关键字引入的。</p><p>library指令可以创建一个库，每个Dart文件都是一个库，即使没有使用library指令来指定。</p><p>Dart中的库主要有三种：</p><pre><code>1、我们自定义的库           import &#39;lib/xxx.dart&#39;;2、系统内置库             import &#39;dart:math&#39;;          import &#39;dart:io&#39;;       import &#39;dart:convert&#39;;3、Pub包管理系统中的库      https://pub.dev/packages    https://pub.flutter-io.cn/packages    https://pub.dartlang.org/flutter/    1、需要在自己想项目根目录新建一个pubspec.yaml    2、在pubspec.yaml文件 然后配置名称 、描述、依赖等信息    3、然后运行 pub get 获取包下载到本地      4、项目中引入库 import &#39;package:http/http.dart&#39; as http; 看文档使用</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导入自己的本地库：</span><br><span class="line">import &#x27;lib/Animal.dart&#x27;;</span><br><span class="line">main()&#123;</span><br><span class="line">  var a=new Animal(&#x27;小黑狗&#x27;, 20);</span><br><span class="line">  print(a.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">导入系统库 </span><br><span class="line">// import &#x27;dart:io&#x27;;</span><br><span class="line">import &quot;dart:math&quot;;</span><br><span class="line">main()&#123;</span><br><span class="line"> </span><br><span class="line">    print(min(12,23));</span><br><span class="line"></span><br><span class="line">    print(max(12,25));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &#x27;dart:io&#x27;;</span><br><span class="line">import &#x27;dart:convert&#x27;;</span><br><span class="line">void main() async&#123;</span><br><span class="line">  var result = await getDataFromZhihuAPI();</span><br><span class="line">  print(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//api接口： http://news-at.zhihu.com/api/3/stories/latest</span><br><span class="line">getDataFromZhihuAPI() async&#123;  //async异步方法</span><br><span class="line">  //1、创建HttpClient对象</span><br><span class="line">  var httpClient = new HttpClient();  </span><br><span class="line">  //2、创建Uri对象</span><br><span class="line">  var uri = new Uri.http(&#x27;news-at.zhihu.com&#x27;,&#x27;/api/3/stories/latest&#x27;);</span><br><span class="line">  //3、发起请求，等待请求</span><br><span class="line">  var request = await httpClient.getUrl(uri);</span><br><span class="line">  //4、关闭请求，等待响应</span><br><span class="line">  var response = await request.close();</span><br><span class="line">  //5、解码响应的内容</span><br><span class="line">  return await response.transform(utf8.decoder).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">async和await</span><br><span class="line">  这两个关键字的使用只需要记住两点：</span><br><span class="line">    只有async方法才能使用await关键字调用方法</span><br><span class="line">    如果调用别的async方法必须使用await关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async是让方法变成异步。</span><br><span class="line">await是等待异步方法执行完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void main() async&#123;</span><br><span class="line">  var result = await testAsync();</span><br><span class="line">  print(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步方法</span><br><span class="line">testAsync() async&#123;</span><br><span class="line">  return &#x27;Hello async&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">导入pub包管理系统中的库</span><br><span class="line">/*</span><br><span class="line">pub包管理系统:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、从下面网址找到要用的库</span><br><span class="line">        https://pub.dev/packages</span><br><span class="line">        https://pub.flutter-io.cn/packages</span><br><span class="line">        https://pub.dartlang.org/flutter/</span><br><span class="line"></span><br><span class="line">2、创建一个pubspec.yaml文件，内容如下</span><br><span class="line"></span><br><span class="line">    name: xxx</span><br><span class="line">    description: A new flutter module project.</span><br><span class="line">    dependencies:  </span><br><span class="line">        http: ^0.12.0+2</span><br><span class="line">        date_format: ^1.0.6</span><br><span class="line"></span><br><span class="line">3、配置dependencies</span><br><span class="line"></span><br><span class="line">4、运行pub get 获取远程库</span><br><span class="line"></span><br><span class="line">5、看文档引入库使用</span><br><span class="line">*/</span><br><span class="line">import &#x27;dart:convert&#x27; as convert;</span><br><span class="line">import &#x27;package:http/http.dart&#x27; as http;</span><br><span class="line">import &#x27;package:date_format/date_format.dart&#x27;;</span><br><span class="line"></span><br><span class="line">main() async &#123;</span><br><span class="line">  // var url = &quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&quot;;</span><br><span class="line"></span><br><span class="line">  //   // Await the http get response, then decode the json-formatted responce.</span><br><span class="line">  //   var response = await http.get(url);</span><br><span class="line">  //   if (response.statusCode == 200) &#123;</span><br><span class="line">  //     var jsonResponse = convert.jsonDecode(response.body);</span><br><span class="line">     </span><br><span class="line">  //     print(jsonResponse);</span><br><span class="line">  //   &#125; else &#123;</span><br><span class="line">  //     print(&quot;Request failed with status: $&#123;response.statusCode&#125;.&quot;);</span><br><span class="line">  //   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    print(formatDate(DateTime(1989, 2, 21), [yyyy, &#x27;*&#x27;, mm, &#x27;*&#x27;, dd]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1、冲突解决</span><br><span class="line">当引入两个库中有相同名称标识符的时候，如果是java通常我们通过写上完整的包名路径来指定使用的具体标识符，甚至不用import都可以，但是Dart里面是必须import的。当冲突的时候，可以使用as关键字来指定库的前缀。如下例子所示：</span><br><span class="line"></span><br><span class="line">    import &#x27;package:lib1/lib1.dart&#x27;;</span><br><span class="line">    import &#x27;package:lib2/lib2.dart&#x27; as lib2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Element element1 = new Element();           // Uses Element from lib1.</span><br><span class="line">    lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;lib/Person1.dart&#x27;;</span><br><span class="line">import &#x27;lib/Person2.dart&#x27; as lib;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  Person p1=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  lib.Person p2=new lib.Person(&#x27;李四&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  p2.printInfo();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">部分导入</span><br><span class="line">  如果只需要导入库的一部分，有两种模式：</span><br><span class="line"></span><br><span class="line">     模式一：只导入需要的部分，使用show关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">      import &#x27;package:lib1/lib1.dart&#x27; show foo;</span><br><span class="line"></span><br><span class="line">     模式二：隐藏不需要的部分，使用hide关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">      import &#x27;package:lib2/lib2.dart&#x27; hide foo;      </span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// import &#x27;lib/myMath.dart&#x27; show getAge;</span><br><span class="line"></span><br><span class="line"> import &#x27;lib/myMath.dart&#x27; hide getName;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">//  getName();</span><br><span class="line">  getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">延迟加载</span><br><span class="line"></span><br><span class="line">    也称为懒加载，可以在需要的时候再进行加载。</span><br><span class="line">    懒加载的最大好处是可以减少APP的启动时间。</span><br><span class="line"></span><br><span class="line">    懒加载使用deferred as关键字来指定，如下例子所示：</span><br><span class="line"></span><br><span class="line">    import &#x27;package:deferred/hello.dart&#x27; deferred as hello;</span><br><span class="line"></span><br><span class="line">    当需要使用的时候，需要使用loadLibrary()方法来加载：</span><br><span class="line"></span><br><span class="line">    greet() async &#123;</span><br><span class="line">      await hello.loadLibrary();</span><br><span class="line">      hello.printGreeting();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Null安全"><a href="#Null安全" class="headerlink" title="Null安全"></a>Null安全</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">  null safety 可以帮助开发者避免一些日常开发中很难被发现的错误，并且额外的好处是可以改善性能。</span><br><span class="line"></span><br><span class="line">  Flutter2.2.0（2021年5月19日发布） 之后的版本都要求使用null safety。</span><br><span class="line"></span><br><span class="line">  ? 可空类型</span><br><span class="line"></span><br><span class="line">  ! 类型断言</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">String? getData(apiUrl)&#123;</span><br><span class="line">  if(apiUrl!=null)&#123;</span><br><span class="line">    return &quot;this is server data&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// void printLength(String? str)&#123;</span><br><span class="line">//   // print(str!.length);</span><br><span class="line">//   if (str!=null)&#123;</span><br><span class="line">//     print(str.length);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">void printLength(String? str)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    print(str!.length); </span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">     print(&quot;str is null&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line"></span><br><span class="line">//1、 ? 可空类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int a=123;</span><br><span class="line">  // print(a);</span><br><span class="line">  </span><br><span class="line">  // String username=&quot;张三&quot;;</span><br><span class="line">  // print(username);</span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt; l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // print(l1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int a=123;  //非空的int类型</span><br><span class="line">  // a=null;  //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;int&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String username=&quot;张三&quot;;  //非空的String类型</span><br><span class="line">  // username=null;   //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;String&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String? username=&quot;张三&quot;;   // String?  表示username是一个可空类型</span><br><span class="line">  // username=null;</span><br><span class="line">  // print(username);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int? a=123;  //  int? 表示a是一个可空类型</span><br><span class="line">  // a=null; </span><br><span class="line">  // print(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt; l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // l1=null;  //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;List&lt;String&gt;&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt;? l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // l1=null;  </span><br><span class="line">  // print(l1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //调用方法</span><br><span class="line">  // print(getData(&quot;http://www.itying.com&quot;));</span><br><span class="line"></span><br><span class="line">  // print(getData(null));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ! 类型断言</span><br><span class="line"></span><br><span class="line">  // String? str=&quot;this is str&quot;;</span><br><span class="line"></span><br><span class="line">  // str=null;</span><br><span class="line"></span><br><span class="line">  // print(str!.length);  </span><br><span class="line">  </span><br><span class="line">   //类型断言: 如果str不等于null 会打印str的长度，如果等于null会抛出异常</span><br><span class="line"></span><br><span class="line">  //  printLength(&quot;str&quot;);</span><br><span class="line">  </span><br><span class="line">   printLength(null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">late 关键字主要用于延迟初始化。</span><br><span class="line">Dart2.13之后</span><br><span class="line">*/</span><br><span class="line">class Person &#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  void setName(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">  Person p = new Person();</span><br><span class="line">  p.setName(&quot;张三&quot;, 20);</span><br><span class="line">  print(p.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">String printUserInfo(String username, &#123;int age=10, String sex=&quot;男&quot;&#125;) &#123;//行参    </span><br><span class="line">  return &quot;姓名:$username---性别:$sex--年龄:$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line">不指定默认值的时候需要加个required，必须要传入的参数</span><br><span class="line">String printInfo(String username, &#123;required int age, required String sex&#125;) &#123;//行参    </span><br><span class="line">  return &quot;姓名:$username---性别:$sex--年龄:$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">    print(printUserInfo(&#x27;张三&#x27;));</span><br><span class="line"></span><br><span class="line">    print(printUserInfo(&#x27;张三&#x27;,age: 20,sex: &quot;女&quot;));</span><br><span class="line">    </span><br><span class="line">    //age 和 sex必须传入</span><br><span class="line">    print(printInfo(&#x27;张三&#x27;,age: 22,sex: &quot;女&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//表示 name 和age 是必须传入的命名参数</span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  Person(&#123;required this.name,required this.age&#125;);  //表示 name 和age 必须传入</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">   Person p=new Person(</span><br><span class="line">     name: &quot;张三&quot;,</span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// name 可以传入也可以不传入   age必须传入</span><br><span class="line">class Person &#123;</span><br><span class="line">  String? name;   //可空属性</span><br><span class="line">  int age;</span><br><span class="line">  Person(&#123;this.name,required this.age&#125;);  //表示 name 和age 必须传入</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">   Person p=new Person(</span><br><span class="line">     name: &quot;张三&quot;,</span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p.getName());  //张三---20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Person p1=new Person(    </span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p1.getName());  //null---20</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTP/HTTPS</title>
      <link href="2021/07/12/%E7%9E%8E%E8%81%8AHTTP-HTTPS/"/>
      <url>2021/07/12/%E7%9E%8E%E8%81%8AHTTP-HTTPS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊TCP/UDP</title>
      <link href="2021/07/12/%E7%9E%8E%E8%81%8ATCP-UDP/"/>
      <url>2021/07/12/%E7%9E%8E%E8%81%8ATCP-UDP/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-12</title>
      <link href="2021/07/12/7-12/"/>
      <url>2021/07/12/7-12/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer链表</title>
      <link href="2021/07/11/%E5%89%91%E6%8C%87offer%E9%93%BE%E8%A1%A8/"/>
      <url>2021/07/11/%E5%89%91%E6%8C%87offer%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer链表题目一"><a href="#剑指offer链表题目一" class="headerlink" title="剑指offer链表题目一"></a>剑指offer链表题目一</h1><h6 id="题目：offer06：-从尾到头打印链表"><a href="#题目：offer06：-从尾到头打印链表" class="headerlink" title="题目：offer06： 从尾到头打印链表"></a>题目：offer06： 从尾到头打印链表</h6><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p><p>解析：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-11</title>
      <link href="2021/07/11/7-11/"/>
      <url>2021/07/11/7-11/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-10</title>
      <link href="2021/07/11/7-10/"/>
      <url>2021/07/11/7-10/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-9</title>
      <link href="2021/07/11/7-9/"/>
      <url>2021/07/11/7-9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="2021/07/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>2021/07/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>滑动窗口是一种解决问题的思路和方法，通常用来解决一些连续问题。比如：求解“连续子串XXX”，连续子数组“XXXX”。</p><p>从类型上说：</p><p>​        1.固定窗口大小</p><p>​        2.窗口大小不固定，求解最大的满足条件的窗口</p><p>​        3.窗口大小不固定，求解最小的满足条件的窗口</p><p>对于固定窗口大小，只需要固定初始化左右指针l和r，分别表示窗口的左右顶点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、l 初始化为 0</span><br><span class="line">二、初始化 r，使得 r - l + 1 等于窗口大小</span><br><span class="line">三、同时移动 l 和 r</span><br><span class="line">四、判断窗口内的连续元素是否满足题目限定的条件</span><br><span class="line">4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解</span><br><span class="line">4.2 如果不满足，则继续。</span><br></pre></td></tr></table></figure><p>可变窗口大小，同样固定初始化左右指针l和r，分别表示窗口的左右顶点，需要保证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、l 和 r 都初始化为 0</span><br><span class="line">二、r 指针移动一步</span><br><span class="line">三、判断窗口内的连续元素是否满足题目限定的条件</span><br><span class="line">3.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 l 指针缩小窗口大小。循环执行 3.1</span><br><span class="line">3.2 如果不满足，则继续。</span><br><span class="line">形象地来看的话，就是 r 指针不停向右移动，l 指针仅仅在窗口满足条件之后才会移动，起到窗口收缩的效果。</span><br></pre></td></tr></table></figure><h1 id="练习题目1：leetcode209，长度最小的子数组"><a href="#练习题目1：leetcode209，长度最小的子数组" class="headerlink" title="练习题目1：leetcode209，长度最小的子数组"></a>练习题目1：leetcode209，长度最小的子数组</h1><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p><p>输入：target = 4, nums = [1,4,4]<br>输出：1<br>示例 3：</p><p>输入：target = 11, nums = [1,1,1,1,1,1,1,1]<br>输出：0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int minSubArrayLen(int[] nums, int target)&#123;</span><br><span class="line">       int l = 0, r = 0;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       int ans = Integer.MAX_VALUE;</span><br><span class="line">       //窗口结束条件</span><br><span class="line">       while (r &lt; nums.length)&#123;</span><br><span class="line">           //更新右边界并更新窗口状态</span><br><span class="line">           sum =sum +nums[r];</span><br><span class="line">           //窗口达到什么状态需要收缩</span><br><span class="line">           while (sum &gt;= target)&#123;</span><br><span class="line">               //缩小左边界并更新窗口状态</span><br><span class="line">               ans = Math.min(ans, r - l +1);</span><br><span class="line">               sum = sum - nums[l];</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           r++;</span><br><span class="line">       &#125;</span><br><span class="line">      return ans == Integer.MAX_VALUE ? 0 : ans;</span><br></pre></td></tr></table></figure><h1 id="题目2：leetcode-76，最小覆盖子串"><a href="#题目2：leetcode-76，最小覆盖子串" class="headerlink" title="题目2：leetcode 76，最小覆盖子串"></a>题目2：leetcode 76，最小覆盖子串</h1><p>题目：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：</p><p>输入：s = “a”, t = “a”<br>输出：”a”</p><h1 id="题目3：无重复字符的最长子串"><a href="#题目3：无重复字符的最长子串" class="headerlink" title="题目3：无重复字符的最长子串"></a>题目3：无重复字符的最长子串</h1><p>题目：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s = “”<br>输出: 0</p><p>思路：不固定窗口大小。用map存储字符和个数，当有字符个数大于1的情况说明含有重复字符，此时应该移动左边的字符直至出现的相同字符个数小于等于1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int  lengthOfLongestSubstring(String s)&#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">       for (int left = 0, right = 0; right &lt; s.length(); right++)&#123;</span><br><span class="line">           char rightChar = s.charAt(right);</span><br><span class="line">           hashMap.put(rightChar, hashMap.getOrDefault(rightChar, 0) + 1);</span><br><span class="line">           while (hashMap.get(rightChar) &gt; 1)&#123;</span><br><span class="line">               char leftChar = s.charAt(left);</span><br><span class="line">               hashMap.put(leftChar, hashMap.get(leftChar) - 1);</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ans = Math.max(ans, right - left + 1);</span><br><span class="line">       &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="题目四：找到字符串中所有字母异位词"><a href="#题目四：找到字符串中所有字母异位词" class="headerlink" title="题目四：找到字符串中所有字母异位词"></a>题目四：找到字符串中所有字母异位词</h1><p>题目：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:</p><p>输入:<br>s: “cbaebabacd” p: “abc”</p><p>输出:<br>[0, 6]</p><p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。<br> 示例 2:</p><p>输入:<br>s: “abab” p: “ab”</p><p>输出:<br>[0, 1, 2]</p><p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">比较两个map里面的内容是否相等：</span><br><span class="line">Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map2 = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">比较方法一：map1.equals(map2))</span><br><span class="line">比较方法二：</span><br><span class="line">Iterator&lt;Entry&lt;String, Integer&gt;&gt; it1 = map1.entrySet().iterator();</span><br><span class="line">while(it1.hasNext())&#123;</span><br><span class="line">Entry&lt;String, Integer&gt; entry1 = it1.next();</span><br><span class="line">Integer integer2 = tempMap.get(entry1.getKey());</span><br><span class="line">if(integer2 == null||(!integer2.equals(entry1.getValue())))&#123;</span><br><span class="line">b = false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个超出时间限制：我的想法是固定滑动窗口，先把p字符串放到map中，有什么字符和对应的个数。然后长的字符串s，用一个固定窗口在s上滑动。每个窗口中字符放到map中，比较两个map 是否相等。相等的话，每次窗口的left放到list中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findAnagrams(String s, String p)&#123;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap_P = new HashMap&lt;&gt;();</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap_S = new HashMap&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">       int revIndex = 0;</span><br><span class="line">       for (int i = 0; i &lt; p.length(); i++)&#123;</span><br><span class="line">           char charOfP = p.charAt(i);</span><br><span class="line">           hashMap_P.put(charOfP, hashMap_P.getOrDefault(charOfP, 0) + 1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for (int j = 0; j &lt;= s.length() - p.length(); j++)&#123;</span><br><span class="line">           int left = j;</span><br><span class="line">           int right = j + p.length() - 1;</span><br><span class="line">           for (int k = left; k &lt;= right; k++)&#123;</span><br><span class="line">               char charOfS = s.charAt(k);</span><br><span class="line">               hashMap_S.put(charOfS, hashMap_S.getOrDefault(charOfS, 0) + 1);</span><br><span class="line">           &#125;</span><br><span class="line">          if (hashMap_S.equals(hashMap_P))&#123;</span><br><span class="line">              list.add(left);</span><br><span class="line">          &#125;</span><br><span class="line">          hashMap_S.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>考虑怎么样优化：我上边的时间复杂度o(s.length*p.length)，要优化到怎么一次遍历就可以完成。把时间复杂度降到0（s.length）。通过常量flag来判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findAnagrams(String s, String p)&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMapOfS = new HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMapOfP = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char c:p.toCharArray()) hashMapOfP.put(c, hashMapOfP.getOrDefault(c, 0) + 1);</span><br><span class="line">        int left = 0, right = 0, flag = 0;</span><br><span class="line">        while (right &lt; s.length())&#123;</span><br><span class="line">            char c = s.charAt(right);</span><br><span class="line">            if (hashMapOfP.containsKey(c))&#123;</span><br><span class="line">                hashMapOfS.put(c, hashMapOfS.getOrDefault(c, 0) + 1);</span><br><span class="line">                if (hashMapOfS.get(c).equals(hashMapOfP.get(c)))&#123;</span><br><span class="line">                    flag++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (p.length() == right - left + 1)&#123;</span><br><span class="line">                if (flag == p.length())&#123;</span><br><span class="line">                    list.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                char c1 = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                if (hashMapOfP.containsKey(c1))&#123;</span><br><span class="line">                    if (hashMapOfS.get(c1).equals(hashMapOfP.get(c1)))&#123;</span><br><span class="line">                        flag--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hashMapOfS.put(c1, hashMapOfS.getOrDefault(c1, 0) - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为只有26个小写字母，所以可以利用26位长度的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">         List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(s.length() == 0 || p.length() == 0)</span><br><span class="line">            return ans;</span><br><span class="line">        int[] dict = new int[26];</span><br><span class="line">        for(int i = 0;i&lt;p.length();i++)&#123;</span><br><span class="line">            dict[p.charAt(i)-&#x27;a&#x27;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        int[] window = new int[26];</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = 0;</span><br><span class="line">        while(right&lt;s.length())&#123;</span><br><span class="line">            int curR = s.charAt(right)-&#x27;a&#x27;;</span><br><span class="line">            right++;</span><br><span class="line">            window[curR] += 1;</span><br><span class="line">            while(window[curR] &gt; dict[curR])&#123;</span><br><span class="line">                int curL = s.charAt(left)-&#x27;a&#x27;;</span><br><span class="line">                window[curL] -= 1;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(right - left == p.length())&#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="leetcode水果成篮904"><a href="#leetcode水果成篮904" class="headerlink" title="leetcode水果成篮904"></a>leetcode水果成篮904</h1><p>在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>你可以从你选择的任何树开始，然后重复执行以下步骤：</p><p>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。<br>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。<br>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p><p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p><p>用这个程序你能收集的水果树的最大总量是多少？ </p><p>示例 1：</p><p>输入：[1,2,1]<br>输出：3<br>解释：我们可以收集 [1,2,1]。<br>示例 2：</p><p>输入：[0,1,2,2]<br>输出：3<br>解释：我们可以收集 [1,2,2]<br>如果我们从第一棵树开始，我们将只能收集到 [0, 1]。<br>示例 3：</p><p>输入：[1,2,3,2,2]<br>输出：4<br>解释：我们可以收集 [2,3,2,2]<br>如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</p><p>解析：理解题目也就是两种类型的水果，求最多的数量。我们可以用一个map来存储类型和数量。何时left移动？当map的size大于2，也就是此时map中存在不止两种类型水果时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int totalFruit(int[] fruits)&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">       int left = 0, right = 0;</span><br><span class="line">       int ans = 0;</span><br><span class="line">       while (right &lt; fruits.length)&#123;</span><br><span class="line">           int fruit = fruits[right];</span><br><span class="line">           hashMap.put(fruit, hashMap.getOrDefault(fruit, 0) + 1);</span><br><span class="line">           while (hashMap.size() &gt; 2)&#123;</span><br><span class="line">               int leftFruit = fruits[left];</span><br><span class="line">               hashMap.put(leftFruit, hashMap.get(leftFruit) - 1);</span><br><span class="line">               if (hashMap.get(leftFruit) == 0)&#123;</span><br><span class="line">                   hashMap.remove(leftFruit);</span><br><span class="line">               &#125;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           ans = Math.max(ans, right - left + 1);</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode930-：和相同的二元子数组"><a href="#leetcode930-：和相同的二元子数组" class="headerlink" title="leetcode930,：和相同的二元子数组"></a>leetcode930,：和相同的二元子数组</h1><p>给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。</p><p>子数组 是数组的一段连续部分。</p><p>示例 1：</p><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]<br>示例 2：</p><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-8</title>
      <link href="2021/07/08/7-8/"/>
      <url>2021/07/08/7-8/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode930：和相同的二元子数组"><a href="#leetcode930：和相同的二元子数组" class="headerlink" title="leetcode930：和相同的二元子数组"></a>leetcode930：和相同的二元子数组</h1><p>题目描述：给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。</p><p>子数组 是数组的一段连续部分。</p><p>示例 1：</p><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>示例 2：</p><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p><p>解析：有点滑动窗口的味道。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart</title>
      <link href="2021/07/08/Dart/"/>
      <url>2021/07/08/Dart/</url>
      
        <content type="html"><![CDATA[<h1 id="Dart介绍"><a href="#Dart介绍" class="headerlink" title="Dart介绍"></a>Dart介绍</h1><p>Dart是由谷歌开发的计算机编程语言,它可以被用于web、服务器、移动应用 和物联网等领域的开发。Dart诞生于2011年，号称要取代JavaScript。但是过去的几年中一直不温不火。直到Flutter的出现现在被人们重新重视。要学Flutter的话我们必须首先得会Dart。</p><h1 id="Dart入口方法、变量、常量、命名规则"><a href="#Dart入口方法、变量、常量、命名规则" class="headerlink" title="Dart入口方法、变量、常量、命名规则"></a>Dart入口方法、变量、常量、命名规则</h1><h6 id="Dart变量："><a href="#Dart变量：" class="headerlink" title="Dart变量："></a>Dart变量：</h6><p>dart是一个强大的脚本类语言，可以不预先定义变量类型 ，自动会类型推倒。  dart中定义变量可以通过var关键字可以通过类型来申明变量，也可以直接通过变量类型进行定义。</p><p>Dart有类型校验：就是定义的字符串不能赋其他类型的值。</p><p>注意： var 后就不要写类型 ，  写了类型 不要var   两者都写   var  a int  = 5;  报错</p><h6 id="Dart常量：-final-和-const修饰符"><a href="#Dart常量：-final-和-const修饰符" class="headerlink" title="Dart常量： final 和 const修饰符"></a>Dart常量： final 和 const修饰符</h6><p>const值不变 一开始就得赋值， </p><p>final 可以开始不赋值 只能赋一次 ;</p><p>而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final a=new DateTime.now();</span><br><span class="line">print(a);   //2019-05-10 15:59:02.966122</span><br><span class="line"></span><br><span class="line">//const a=new DateTime.now();   //报错了</span><br></pre></td></tr></table></figure><p>永远不改量的量，请使用final或const修饰它，而不是使用var或其他变量类型。</p><h6 id="入口方法："><a href="#入口方法：" class="headerlink" title="入口方法："></a>入口方法：</h6><p>第一种定义方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main（）&#123;</span><br><span class="line">print（&#x27;hello Dart&#x27;）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种定义方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">print(&#x27;你好 Dart&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="命名规则："><a href="#命名规则：" class="headerlink" title="命名规则："></a>命名规则：</h6><p>Dart的命名规则：</p><pre><code>      1、变量名称必须由数字、字母、下划线和美元符($)组成。      2.注意：标识符开头不能是数字      3.标识符不能是保留字和关键字。         4.变量的名字是区分大小写的如: age和Age是不同的变量。在实际的运用中,也建议,不要用一个单词大小写区分两个变量。          5、标识符(变量名称)一定要见名思意 ：变量名称建议用名词，方法名称建议用动词  </code></pre><h1 id="Dart数据类型"><a href="#Dart数据类型" class="headerlink" title="Dart数据类型"></a>Dart数据类型</h1><h6 id="常用数据类型："><a href="#常用数据类型：" class="headerlink" title="常用数据类型："></a>常用数据类型：</h6><p> Numbers（数值）:<br>          int<br>          double<br>      Strings（字符串）<br>          String<br>      Booleans(布尔)<br>          bool<br>      List（数组）<br>          在Dart中，数组是列表对象，所以大多数人只是称它们为列表<br>      Maps（字典）<br>          通常来说，Map 是一个键值对相关的对象。 键和值可以是任何类型的对象。每个 键 只出现一次， 而一个值则可以出现多次</p><p>  项目中用不到的数据类型 （用不到）：<br>      Runes<br>        Rune是UTF-32编码的字符串。它可以通过文字转换成符号表情或者代表特定的文字。</p><p>Symbols<br>        Symbol对象表示在Dart程序中声明的运算符或标识符。您可能永远不需要使用符号，但它们对于按名称引用标识符的API非常有用，因为缩小会更改标识符名称而不会更改标识符符号。要获取标识符的符号，请使用符号文字，它只是＃后跟标识符：在Dart中符号用#开头表示。</p><h6 id="字符串类型："><a href="#字符串类型：" class="headerlink" title="字符串类型："></a>字符串类型：</h6><p>定义的几种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &#x27;str1&#x27;;</span><br><span class="line">var str2 = &quot;str2&quot;;</span><br><span class="line">在Dart中字符串用单引号和双引号都可以</span><br><span class="line">String str1 = &#x27;str1&#x27;;</span><br><span class="line">String str2 = &quot;str2&quot;;</span><br><span class="line"></span><br><span class="line">String str3 = &#x27;&#x27;&#x27;str1</span><br><span class="line">str2</span><br><span class="line">str3&#x27;&#x27;&#x27;</span><br><span class="line">三个单引号会保留之间的所有内容，原样输出。类似于kotlin中</span><br></pre></td></tr></table></figure><p>字符串的拼接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1=&#x27;你好&#x27;;</span><br><span class="line"></span><br><span class="line">  String str2=&#x27;Dart&#x27;;</span><br><span class="line">  </span><br><span class="line">//kotlin中的字符串模板，双引号中的变量之前加上$，会输出对应的变量</span><br><span class="line">  print(&quot;$str1 $str2&quot;);</span><br><span class="line"></span><br><span class="line">//java中的“+”，实现的字符串拼接</span><br><span class="line">  print(str1 + str2);</span><br><span class="line">//同上</span><br><span class="line">  print(str1 +&quot; &quot;+ str2);</span><br></pre></td></tr></table></figure><h6 id="数值类型：int、"><a href="#数值类型：int、" class="headerlink" title="数值类型：int、"></a>数值类型：int、</h6><p>int：必须是整形</p><p>double：可以是整形，也可以是浮点型</p><h6 id="布尔类型：bool"><a href="#布尔类型：bool" class="headerlink" title="布尔类型：bool"></a>布尔类型：bool</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag = true;</span><br><span class="line">var flag = false;</span><br></pre></td></tr></table></figure><h6 id="List-数组-集合-："><a href="#List-数组-集合-：" class="headerlink" title="List(数组/集合)："></a>List(数组/集合)：</h6><p>定义list的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">var list1 = [&quot;张三&quot;, 20, true];</span><br><span class="line">第二种：指定类型</span><br><span class="line">var list2 = &lt;String&gt;[&quot;张三&quot;, &quot;李四&quot;];</span><br><span class="line">var list2 = &lt;int&gt;[12, 30];</span><br><span class="line">第三种：通过[]创建的集合，容量可以变化。上述的两种方式容量就可以变化</span><br><span class="line">var list3 = [];</span><br><span class="line">list3.add(&quot;张三&quot;);</span><br><span class="line">第四种：</span><br><span class="line">var list4 = new List();//在新版本的dart中无法使用这个方法</span><br><span class="line">var list5 = List.filled(5, &quot;&quot;);//创建一个固定长度的集合</span><br><span class="line">创建了固定长度的集合之后，只能修改，不能添加了，也不能修改集合的长度。</span><br></pre></td></tr></table></figure><h6 id="Map：字典"><a href="#Map：字典" class="headerlink" title="Map：字典"></a>Map：字典</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//第一种定义 Maps的方式</span><br><span class="line"></span><br><span class="line">    // var person=&#123;</span><br><span class="line">    //   &quot;name&quot;:&quot;张三&quot;,</span><br><span class="line">    //   &quot;age&quot;:20,</span><br><span class="line">    //   &quot;work&quot;:[&quot;程序员&quot;,&quot;送外卖&quot;]</span><br><span class="line">    // &#125;;</span><br><span class="line"></span><br><span class="line">    // print(person);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;age&quot;]);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;work&quot;]);</span><br><span class="line"></span><br><span class="line">   //第二种定义 Maps的方式</span><br><span class="line"></span><br><span class="line">    var p=new Map();</span><br><span class="line"></span><br><span class="line">    p[&quot;name&quot;]=&quot;李四&quot;;</span><br><span class="line">    p[&quot;age&quot;]=22;</span><br><span class="line">    p[&quot;work&quot;]=[&quot;程序员&quot;,&quot;送外卖&quot;];</span><br><span class="line">    print(p);</span><br><span class="line"></span><br><span class="line">    print(p[&quot;age&quot;]);</span><br></pre></td></tr></table></figure><p>类型判断：is关键词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// var str=&#x27;1234&#x27;;</span><br><span class="line"></span><br><span class="line">  // if(str is String)&#123;</span><br><span class="line">  //   print(&#x27;是string类型&#x27;);</span><br><span class="line">  // &#125;else if(str is int)&#123;</span><br><span class="line"></span><br><span class="line">  //    print(&#x27;int&#x27;);</span><br><span class="line">  // &#125;else&#123;</span><br><span class="line">  //    print(&#x27;其他类型&#x27;);</span><br><span class="line">  // &#125;</span><br></pre></td></tr></table></figure><h1 id="运算符-类型转换"><a href="#运算符-类型转换" class="headerlink" title="运算符+类型转换"></a>运算符+类型转换</h1><h6 id="运算符和类型转换："><a href="#运算符和类型转换：" class="headerlink" title="运算符和类型转换："></a>运算符和类型转换：</h6><p>算术运算符</p><pre><code>  +    -    *    /     ~/ (取整)     %（取余）  关系运算符  ==    ！=   &gt;    &lt;    &gt;=    &lt;=逻辑运算符    !（取反）  &amp;&amp;（且，全真才真）   ||（或，全假才为假）赋值运算符 基础赋值运算符   =   ??=（b??=23，表示b为空的话，把23赋值给它） 复合赋值运算符   +=  -=  *=   /=   %=  ~/= 自增自减运算符：++，--++  --   表示自增 自减 1    在赋值运算里面 如果++ -- 写在前面 这时候先运算 再赋值，如果++ --写在后面 先赋值后运行运算条件表达式     if  else   switch case     三目运算符    ??运算符：如果为空              // var a;              // var b= a ?? 10;              // print(b);   10</code></pre><p>​<br>                  var a=22;<br>                  var b= a ?? 10;</p><pre><code>              print(b); //22</code></pre><p>2、类型转换</p><pre><code>1、Number与String类型之间的转换2、其他类型转换成Booleans类型</code></pre><p>  1、Number与String类型之间的转换</p><pre><code>  // Number类型转换成String类型 toString()  // String类型转成Number类型  int.parse()，double.parse()</code></pre><p>2、其他类型转换成Booleans类型</p><pre><code>    // isEmpty:判断字符串是否为空</code></pre><h6 id="break和continue："><a href="#break和continue：" class="headerlink" title="break和continue："></a>break和continue：</h6><p>break语句功能:<br>          1、在switch语句中使流程跳出switch结构。<br>          2、在循环语句中使流程跳出当前循环,遇到break 循环终止，后面代码也不会执行</p><pre><code>      强调:      1、如果在循环中已经执行了break语句,就不会执行循环体中位于break后的语句。      2、在多层循环中,一个break语句只能向外跳出一层    break可以用在switch case中 也可以用在 for 循环和 while循环中  continue语句的功能:              【注】只能在循环语句中使用,使本次循环结束，即跳过循环体重下面尚未执行的语句，接着进行下次的是否执行循环的判断。    continue可以用在for循环以及 while循环中，但是不建议用在while循环中，不小心容易死循环</code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h6 id="for基本语法"><a href="#for基本语法" class="headerlink" title="for基本语法"></a>for基本语法</h6><p>​          for (int i = 1; i&lt;=100; i++) {<br>​            print(i);<br>​          }</p><pre><code>        //第一步，声明变量int i = 1;        //第二步，判断i &lt;=100        //第三步，print(i);        //第四步，i++        //第五步 从第二步再来，直到判断为false</code></pre><h6 id="while语法格式"><a href="#while语法格式" class="headerlink" title="while语法格式:"></a>while语法格式:</h6><pre><code>    while(表达式/循环条件)&#123;                        &#125;        do&#123;        语句/循环体            &#125;while(表达式/循环条件);        注意： 1、最后的分号不要忘记            2、循环条件中使用的变量需要经过初始化          3、循环体中，应有结束循环的条件，否则会造成死循环。</code></pre><p> while 和 do while的区别   第一次循环条件不成立的情况下</p><p>​    // int i=10;<br>​      // while(i&lt;2){<br>​      //     print(‘执行代码’);<br>​      // }</p><pre><code>  var j=10;        do&#123;      print(&#39;执行代码&#39;);  &#125;while(j&lt;2);</code></pre><h1 id="Dart集合类型以及循环语句"><a href="#Dart集合类型以及循环语句" class="headerlink" title="Dart集合类型以及循环语句"></a>Dart集合类型以及循环语句</h1><h6 id="List集合："><a href="#List集合：" class="headerlink" title="List集合："></a>List集合：</h6><p>List里面常用的属性和方法：</p><pre><code>常用属性：    length          长度    reversed        翻转    isEmpty         是否为空    isNotEmpty      是否不为空常用方法：      add         增加    addAll      拼接数组    indexOf     查找  传入具体值    remove      删除  传入具体值    removeAt    删除  传入索引值    fillRange   修改       insert(index,value);            指定位置插入        insertAll(index,list)           指定位置插入List    toList()    其他类型转换成List      join()      List转换成字符串    split()     字符串转化成List    forEach       map    where    any    every</code></pre><h6 id="Set集合："><a href="#Set集合：" class="headerlink" title="Set集合："></a>Set集合：</h6><p>用它最主要的功能就是去除数组重复内容</p><p>Set是没有顺序且不能重复的集合，所以不能通过索引去获取值</p><h6 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h6><p>映射(Maps)是无序的键值对：</p><pre><code>常用属性：    keys            获取所有的key值    values          获取所有的value值    isEmpty         是否为空    isNotEmpty      是否不为空常用方法:    remove(key)     删除指定key的数据    addAll(&#123;...&#125;)   合并映射  给映射内增加属性    containsValue   查看映射内的值  返回true/false    forEach       map    where    any    every</code></pre><h6 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// for(var i=0;i&lt;myList.length;i++)&#123;</span><br><span class="line">     //   print(myList[i]);</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // for(var item in myList)&#123;</span><br><span class="line">     //   print(item);</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // myList.forEach((value)&#123;</span><br><span class="line">     //     print(&quot;$value&quot;);</span><br><span class="line">     // &#125;);</span><br></pre></td></tr></table></figure><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4];      </span><br><span class="line">     // var newList=myList.map((value)&#123;</span><br><span class="line">     //     return value*2;</span><br><span class="line">     // &#125;);</span><br><span class="line">     //  print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="where："><a href="#where：" class="headerlink" title="where："></a>where：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">    // var newList=myList.where((value)&#123;</span><br><span class="line">    //     return value&gt;5;</span><br><span class="line">    // &#125;);</span><br><span class="line">    // print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="any："><a href="#any：" class="headerlink" title="any："></a>any：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">    // var f=myList.any((value)&#123;   //只要集合里面有满足条件的就返回true</span><br><span class="line"></span><br><span class="line">    //     return value&gt;5;</span><br><span class="line">    // &#125;);</span><br><span class="line">    // print(f);</span><br></pre></td></tr></table></figure><h6 id="every："><a href="#every：" class="headerlink" title="every："></a>every：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">      // var f=myList.every((value)&#123;   //每一个都满足条件返回true  否则返回false</span><br><span class="line"></span><br><span class="line">      //     return value&gt;5;</span><br><span class="line">      // &#125;);</span><br><span class="line">      // print(f);</span><br></pre></td></tr></table></figure><h6 id="set："><a href="#set：" class="headerlink" title="set："></a>set：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// set</span><br><span class="line"></span><br><span class="line">// var s=new Set();</span><br><span class="line"></span><br><span class="line">// s.addAll([1,222,333]);</span><br><span class="line"></span><br><span class="line">// s.forEach((value)=&gt;print(value));</span><br></pre></td></tr></table></figure><h6 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map person=&#123;</span><br><span class="line">      &quot;name&quot;:&quot;张三&quot;,</span><br><span class="line">      &quot;age&quot;:20</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    person.forEach((key,value)&#123;            </span><br><span class="line">        print(&quot;$key---$value&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>  内置方法/函数：</p><pre><code>  print();</code></pre><p>  自定义方法：<br>      自定义方法的基本格式：</p><pre><code>  返回类型  方法名称（参数1，参数2,...）&#123;    方法体    return 返回值;    //可以在这里在定义一个函数，也就是允许函数嵌套  &#125;</code></pre><p>dart中的方法可以嵌套：演示方法作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//演示方法的作用域</span><br><span class="line">//全局作用域</span><br><span class="line">List getList()&#123;</span><br><span class="line"></span><br><span class="line">  return [&#x27;111&#x27;,&#x27;2222&#x27;,&#x27;333&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">  void xxx()&#123;</span><br><span class="line">//局部作用域</span><br><span class="line">      aaa()&#123;</span><br><span class="line"></span><br><span class="line">          print(getList());</span><br><span class="line">          print(&#x27;aaa&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      aaa();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // aaa();  错误写法 </span><br></pre></td></tr></table></figure><p>例一：int sunNum(int n){</p><p>}</p><p>例二：// String printUserInfo(String username, int age) {<br>  //   //行参<br>  //   return “姓名:$username—年龄:$age”;<br>  // }</p><p>  // print(printUserInfo(‘张三’, 20)); //实参</p><p>例三：定义一个带可选参数的方法，最新的dart定义可选参数需要指定类型默认值</p><p>String printUserInfo(String username,[int age， String sex]){  //可选参数age、sex<br>     if(age!=null){<br>       return “姓名:$username—年龄:$age”;<br>     }<br>     return “姓名:$username—年龄保密”;<br>   }<br>   print(printUserInfo(‘张三’,21)); //实参<br>   print(printUserInfo(‘张三’));</p><p>例四：带默认参数，</p><p>String printUserInfo(String username,[String sex=’男’,int age]){  //默认参数sex、可选参数age。注意顺序<br>  //   if(age!=0){<br>  //     return “姓名:$username—性别:$sex–年龄:$age”;<br>  //   }<br>  //   return “姓名:$username—性别:$sex–年龄保密”;<br>  // }<br>  // print(printUserInfo(‘张三’));<br>  // print(printUserInfo(‘小李’,’女’));<br>  // print(printUserInfo(‘小李’,’女’,30));</p><p>例五：定义一个命名参数的方法，最新的dart定义命名参数需要指定类型默认值</p><p>  // String printUserInfo(String username, {int age = 0, String sex = ‘男’}) {//行参<br>  //   if (age != 0) {<br>  //     return “姓名:$username—性别:$sex–年龄:$age”;<br>  //   }<br>  //   return “姓名:$username—性别:$sex–年龄保密”;<br>  // }<br>  // print(printUserInfo(‘张三’, age: 20, sex: ‘未知’));</p><p>例六：方法作为另一个方法的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// var fn=()&#123;</span><br><span class="line"></span><br><span class="line">  //   print(&#x27;我是一个匿名方法&#x27;);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // fn();</span><br><span class="line"></span><br><span class="line">  //方法</span><br><span class="line">  fn1() &#123;</span><br><span class="line">    print(&#x27;fn1&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //方法</span><br><span class="line">  fn2(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //调用fn2这个方法 把fn1这个方法当做参数传入</span><br><span class="line">  fn2(fn1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="箭头函数："><a href="#箭头函数：" class="headerlink" title="箭头函数："></a>箭头函数：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">/*需求：使用forEach打印下面List里面的数据*/</span><br><span class="line"></span><br><span class="line">  // List list=[&#x27;苹果&#x27;,&#x27;香蕉&#x27;,&#x27;西瓜&#x27;];</span><br><span class="line">  // list.forEach((value)&#123;</span><br><span class="line">  //   print(value);</span><br><span class="line">  // &#125;);</span><br><span class="line"></span><br><span class="line">  // list.forEach((value)=&gt;print(value));</span><br><span class="line"></span><br><span class="line">  //注意和方法的区别: 箭头函数内只能写一条语句，并且语句后面没有分号(;)</span><br><span class="line">  // list.forEach((value)=&gt;&#123;</span><br><span class="line">  //   print(value)</span><br><span class="line">  // &#125;);</span><br><span class="line"></span><br><span class="line">/*需求：修改下面List里面的数据，让数组中大于2的值乘以2*/</span><br><span class="line"></span><br><span class="line">  // List list=[4,1,2,3,4];</span><br><span class="line">  // var newList=list.map((value)&#123;</span><br><span class="line">  //     if(value&gt;2)&#123;</span><br><span class="line">  //       return value*2;</span><br><span class="line">  //     &#125;</span><br><span class="line">  //     return value;</span><br><span class="line"></span><br><span class="line">  // &#125;);</span><br><span class="line">  // print(newList.toList());</span><br><span class="line"></span><br><span class="line">  //  var newList=list.map((value)=&gt;value&gt;2?value*2:value);</span><br><span class="line">  //  print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="函数的相互调用："><a href="#函数的相互调用：" class="headerlink" title="函数的相互调用："></a>函数的相互调用：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">需求：    1、定义一个方法isEvenNumber来判断一个数是否是偶数  </span><br><span class="line">         2、定义一个方法打印1-n以内的所有偶数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 1、定义一个方法isEvenNumber来判断一个数是否是偶数  </span><br><span class="line">  bool isEvenNumber(int n) &#123;</span><br><span class="line">    if (n % 2 == 0) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">//  2、定义一个方法打印1-n以内的所有偶数</span><br><span class="line">  printNum(int n) &#123;</span><br><span class="line">    for (var i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">      if (isEvenNumber(i)) &#123;</span><br><span class="line">        print(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printNum(10);//打印1-10以内的所有函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="匿名方法："><a href="#匿名方法：" class="headerlink" title="匿名方法："></a>匿名方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int getNum(int n) &#123;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // print(getNum(12));</span><br><span class="line"></span><br><span class="line">  //匿名方法</span><br><span class="line"></span><br><span class="line">  // var printNum=()&#123;</span><br><span class="line">  //   print(123);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // printNum();</span><br><span class="line"></span><br><span class="line">  // var printNum=(int n)&#123;</span><br><span class="line">  //   print(n+2);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // printNum(12);</span><br></pre></td></tr></table></figure><h6 id="自执行方法："><a href="#自执行方法：" class="headerlink" title="自执行方法："></a>自执行方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((int n)&#123;</span><br><span class="line">  //   print(n);</span><br><span class="line">  //   print(&#x27;我是自执行方法&#x27;);</span><br><span class="line">  // &#125;)(12);</span><br></pre></td></tr></table></figure><h6 id="方法递归："><a href="#方法递归：" class="headerlink" title="方法递归："></a>方法递归：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// var sum = 1;</span><br><span class="line"> // fn(int n) &#123;</span><br><span class="line"> //   sum *= n;</span><br><span class="line"> //   if (n == 1) &#123;</span><br><span class="line"> //     return;</span><br><span class="line"> //   &#125;</span><br><span class="line"> //   fn(n - 1);</span><br><span class="line"> // &#125;</span><br><span class="line"></span><br><span class="line"> // fn(5);</span><br><span class="line"> // print(sum);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> var sum=0;</span><br><span class="line"> fn(int n)&#123;</span><br><span class="line">     sum+=n;</span><br><span class="line">     if(n==0)&#123;</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">     fn(n-1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(100);</span><br><span class="line"> print(sum);</span><br></pre></td></tr></table></figure><h6 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h6><p>  1、全局变量特点:    全局变量常驻内存、全局变量污染全局<br>  2、局部变量的特点：  不常驻内存会被垃圾机制回收、不会污染全局  </p><p>  /*  想实现的功能：</p><p>​    1.常驻内存<br>​    2.不污染全局   </p><p>​      产生了闭包,闭包可以解决这个问题…..  </p><p>​      闭包: 函数嵌套函数, 内部函数会调用外部函数的变量或参数, 变量或参数不会被系统回收(不会释放内存)</p><p>​      闭包的写法： 函数嵌套函数，并return 里面的函数，这样就形成了闭包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*全局变量*/</span><br><span class="line">var a = 123;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // print(a);</span><br><span class="line"></span><br><span class="line">  // fn()&#123;</span><br><span class="line">  //   a++;</span><br><span class="line">  //   print(a);</span><br><span class="line">  // &#125;</span><br><span class="line">  // fn();</span><br><span class="line">  // fn();</span><br><span class="line">  // fn();</span><br><span class="line"></span><br><span class="line">//局部变量</span><br><span class="line">  // printInfo() &#123;</span><br><span class="line">  //   var myNum = 123;</span><br><span class="line">  //   myNum++;</span><br><span class="line">  //   print(myNum);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // printInfo();</span><br><span class="line">  // printInfo();</span><br><span class="line">  // printInfo();</span><br><span class="line"></span><br><span class="line">//闭包</span><br><span class="line"></span><br><span class="line">  fn() &#123;</span><br><span class="line">    var a = 123; /*不会污染全局   常驻内存*/</span><br><span class="line">    return () &#123;</span><br><span class="line">      a++;</span><br><span class="line">      print(a);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var b = fn();</span><br><span class="line">  b();</span><br><span class="line">  b();</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象编程(OOP)的三个基本特征是：封装、继承、多态      </p><p>  封装：封装是对象和类概念的主要特性。封装，把客观事物封装成抽象的类，并且把自己的部分属性和方法提供给其他对象调用, 而一部分属性和方法则隐藏。</p><p>  继承：面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>  多态：允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。</p><p>Dart所有的东西都是对象，所有的对象都继承自Object类。</p><p>Dart是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是Object的子类</p><p>一个类通常由属性和方法组成。</p><h6 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h6><p>Dart是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是Object的子类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  String name=&quot;张三&quot;;</span><br><span class="line">  int age=23;</span><br><span class="line">  void getInfo()&#123;</span><br><span class="line">      // print(&quot;$name----$age&quot;);</span><br><span class="line">      print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void setInfo(int age)&#123;</span><br><span class="line">    this.age=age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  //实例化</span><br><span class="line"></span><br><span class="line">  // var p1=new Person();</span><br><span class="line">  // print(p1.name);</span><br><span class="line">  // p1.getInfo();</span><br><span class="line"></span><br><span class="line">  Person p1=new Person();</span><br><span class="line">  // print(p1.name);</span><br><span class="line"></span><br><span class="line">  p1.setInfo(28);</span><br><span class="line">  p1.getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// class Person&#123;</span><br><span class="line">//   String name=&#x27;张三&#x27;;</span><br><span class="line">//   int age=20; </span><br><span class="line">//   //默认构造函数</span><br><span class="line">   Person()&#123;</span><br><span class="line">     print(&#x27;这是构造函数里面的内容  这个方法在实例化的时候触发&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line">Person(String name, int age)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//上边构造函数的简写</span><br><span class="line">Person(this.name, this.age);</span><br><span class="line">//   void printInfo()&#123;   </span><br><span class="line">//     print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命名构造函数：</span><br><span class="line">class Person&#123;</span><br><span class="line">String name;</span><br><span class="line">int age ;</span><br><span class="line">//默认构造函数</span><br><span class="line">Person(String name, int age)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//命名构造函数</span><br><span class="line">Person.now()&#123;</span><br><span class="line">print(&#x27;我是命名构造函数&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">Person.setInfo(String name, int age)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">void printInfo()&#123;   </span><br><span class="line">     print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main&#123;</span><br><span class="line">Person p1 = new Person(&#x27;张三&#x27;, 20);//调用的默认构函数</span><br><span class="line">Person p2 = new Person.now();//调用的命名构造函数</span><br><span class="line">&#125;</span><br><span class="line">默认构造函数只能有一个，命名构造函数可以有多个</span><br></pre></td></tr></table></figure><p>import ‘lib/Person.dart’;//导入类</p><h6 id="私有方法、私有属性"><a href="#私有方法、私有属性" class="headerlink" title="私有方法、私有属性"></a>私有方法、私有属性</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Dart和其他面向对象语言不一样，Data中没有 public  private protected这些访问修饰符合</span><br><span class="line"></span><br><span class="line">但是我们可以使用_把一个属性或者方法定义成私有。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;lib/Animal.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"> </span><br><span class="line"> Animal a=new Animal(&#x27;小狗&#x27;, 3);</span><br><span class="line"></span><br><span class="line"> print(a.getName());</span><br><span class="line"></span><br><span class="line"> a.execRun();   //间接的调用私有方法</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">加了下划线，如果在同一个文件中也是能够访问到的。也可以在私有属性的类中定义方法，在另一个文件中通过方法访问</span><br><span class="line">私有方法只能在当前类中访问，也可以通过公共方法（公共方法中调用了私有方法），然后调用公共方法来访问</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="getter和setter方法："><a href="#getter和setter方法：" class="headerlink" title="getter和setter方法："></a>getter和setter方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rect&#123;</span><br><span class="line">  late num height;</span><br><span class="line">  late num width;   </span><br><span class="line">  Rect(this.height,this.width);</span><br><span class="line">  get area&#123;</span><br><span class="line">    return this.height*this.width;</span><br><span class="line">  &#125;</span><br><span class="line">  set areaHeight(value)&#123;</span><br><span class="line">    this.height=value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  Rect r=new Rect(10,4);</span><br><span class="line">  // print(&quot;面积:$&#123;r.area()&#125;&quot;);   </span><br><span class="line">  r.areaHeight=6;</span><br><span class="line"></span><br><span class="line">  print(r.area);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">get和set相当于一个计算属性，只是没有方法后边的括号。</span><br></pre></td></tr></table></figure><h6 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Dart中我们也可以在构造函数体运行之前初始化实例变量</span><br><span class="line"></span><br><span class="line">class Rect&#123;</span><br><span class="line">  int height;</span><br><span class="line">  int width;</span><br><span class="line">  Rect():height=2,width=10&#123;</span><br><span class="line">    </span><br><span class="line">    print(&quot;$&#123;this.height&#125;---$&#123;this.width&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  getArea()&#123;</span><br><span class="line">    return this.height*this.width;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  Rect r=new Rect();</span><br><span class="line">  print(r.getArea());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-7</title>
      <link href="2021/07/07/7-7/"/>
      <url>2021/07/07/7-7/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode大餐计数1711"><a href="#leetcode大餐计数1711" class="headerlink" title="leetcode大餐计数1711"></a>leetcode大餐计数1711</h1><p>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 任意 两道餐品做一顿大餐。</p><p>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><p>示例 1：</p><p>输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。<br>示例 2：</p><p>输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</p><h6 id="思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness-i-相加成为2的幂。"><a href="#思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness-i-相加成为2的幂。" class="headerlink" title="思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness[i]相加成为2的幂。"></a>思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness[i]相加成为2的幂。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int countPairs(int[] deliciousness)&#123;</span><br><span class="line">    List&lt;Double&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; deliciousness.length; i++)&#123;</span><br><span class="line">        for (int j = i + 1; j &lt; deliciousness.length; j++)&#123;</span><br><span class="line">            int k = deliciousness[i] +deliciousness[j];</span><br><span class="line">            //判断某一个数是否为2的次幂</span><br><span class="line">            //(number &amp; number - 1) == 0</span><br><span class="line">            if ((k &amp; (k - 1)) == 0 &amp;&amp; k != 0)&#123;</span><br><span class="line">                list.add(k % ((Math.pow(10, 9)) + 7));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为o（n^2）,</p><h6 id="判断某一个数是否为2的次幂："><a href="#判断某一个数是否为2的次幂：" class="headerlink" title="判断某一个数是否为2的次幂："></a>判断某一个数是否为2的次幂：</h6><p> 1、将2的幂次方写成二进制形式后，很容易就会发现有一个特点：二进制中只有一个1，并且1后面跟了n个0； 因此问题可以转化为判断1后面是否跟了n个0就可以了。</p><pre><code>    如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零。   最快速的方法：  (number &amp; number - 1) == 0</code></pre><p>2、看的宫水三叶<a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/</a></p><p>插入一小段话，我是偶然发现了宝藏姐姐的公众号，然后无法自拔，然后每天都有关注公众号和三叶的leetcode。每当看到大佬的解法总是无比的崇拜，感叹自己怎么这么菜，但是每个人的成长总是披荆斩棘的，所以coding吧兄弟们。</p><p>判断某个数是否为2的次幂。</p><p>朴素做法对x应用试除法，因为精度问题，需要使用乘法实现试除。</p><p>另外一个优秀的做法是利用位运算找到符合【大于等于x】的最近的2的幂，然后判断是否与x相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean check(long x) &#123;</span><br><span class="line">        // 方法一</span><br><span class="line">        // long cur = 1;</span><br><span class="line">        // while (cur &lt; x) &#123;</span><br><span class="line">        //     cur = cur * 2;</span><br><span class="line">        // &#125;</span><br><span class="line">        // return cur == x;</span><br><span class="line">        </span><br><span class="line">        // 方法二</span><br><span class="line">        return getVal(x) == x;</span><br><span class="line">    &#125;</span><br><span class="line">    long getVal(long x) &#123;</span><br><span class="line">        long n = x - 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 2;</span><br><span class="line">        n |= n &gt;&gt;&gt; 4;</span><br><span class="line">        n |= n &gt;&gt;&gt; 8;</span><br><span class="line">        n |= n &gt;&gt;&gt; 16;</span><br><span class="line">        return n &lt; 0 ? 1 : n + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述的两个for循环解法存在重复计算。可以用哈希表记录某个数出现的次数，但是这种算法的时间复杂度还是o（n^2）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int countPairs(int[] deliciousness)&#123;</span><br><span class="line">        long ans = 0;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; deliciousness.length; i++)&#123;</span><br><span class="line">            int k = deliciousness[i];</span><br><span class="line">            for (int other : hashMap.keySet())&#123;</span><br><span class="line">                int z = k + other;</span><br><span class="line">                if ((z &amp; (z - 1)) == 0 &amp;&amp; z != 0)&#123;</span><br><span class="line">                    ans += hashMap.get(other);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(k, hashMap.getOrDefault(k, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) (ans % 10000007);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我的疑问：我一开始不明白为什么哈希表为什么是一边遍历一边统计的。</p><p>上边的第一种思路理解：枚举后边的数。对于一开始的两个for循环，我们对于第一个for循环，然后找当前位置后边的数，看两个数相加是否为2的幂。</p><p>另外一种思路：枚举前一个数。其实我们也可以理解为对于第一个for循环，我们找当前位置前边的数，看两个数相加是否为2的次幂。</p><h6 id="思路2：枚举2的幂（容斥原理）"><a href="#思路2：枚举2的幂（容斥原理）" class="headerlink" title="思路2：枚举2的幂（容斥原理）"></a>思路2：枚举2的幂（容斥原理）</h6><p>宫水三叶<a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-6</title>
      <link href="2021/07/06/7-6/"/>
      <url>2021/07/06/7-6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-5</title>
      <link href="2021/07/06/7-5/"/>
      <url>2021/07/06/7-5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-4</title>
      <link href="2021/07/06/7-4/"/>
      <url>2021/07/06/7-4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-1</title>
      <link href="2021/07/06/7-1/"/>
      <url>2021/07/06/7-1/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode07传递信息"><a href="#leetcode07传递信息" class="headerlink" title="leetcode07传递信息"></a>leetcode07传递信息</h1><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： </p><p> 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 </p><p>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</p><p>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 </p><p>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。  </p><p>示例 1：  输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3  输出：3  解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。  </p><p>示例 2：  输入：n = 3, relation = [[0,2],[2,1]], k = 2  输出：0  解释：信息不能从小 A 处经过 2 轮传递到编号 2</p><h6 id="解析：BFS、DFS、动态规划"><a href="#解析：BFS、DFS、动态规划" class="headerlink" title="解析：BFS、DFS、动态规划"></a>解析：BFS、DFS、动态规划</h6><p>BFS方法：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3</title>
      <link href="2021/07/03/7-3/"/>
      <url>2021/07/03/7-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2</title>
      <link href="2021/07/02/7-2/"/>
      <url>2021/07/02/7-2/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer：单链表、链表"><a href="#剑指offer：单链表、链表" class="headerlink" title="剑指offer：单链表、链表"></a>剑指offer：单链表、链表</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>androidSomething</title>
      <link href="2021/07/02/androidSomething/"/>
      <url>2021/07/02/androidSomething/</url>
      
        <content type="html"><![CDATA[<h1 id="something"><a href="#something" class="headerlink" title="something"></a>something</h1><p>要理解设计者意图，就需要抽象。我们需要在哲学意义空间中去考虑系统的描述，即系统在本质上要表达什么。在逻辑空间上去考虑系统基本构成和动态结构。从现实到虚拟对象的映射去理解系统对象的组成，在从数据流的角度分析数据的产生者和消费者之间作用关系，从控制流的角度去分析对象之间的交互关系，从函数调用去分析具体的层次关系。</p><p>在系统设计上，原型是最能表达哲学空间和逻辑空间中系统本质的东西，原型是事物本质的第一层体现。我以为任何复杂的系统都一个简洁的系统原型，都有它简洁的意义。系统原型是设计者意图的第一体现，所以我们需要从几个方向上去提炼系统原型：</p><p>（1）从系统本质和基本原理出发</p><p>（2）从分析系统数据流和控制流分析出发。</p><p>从设计者意图出发，得出系统原型，提取到大的逻辑结构和系统构成是第一步。之后我们可以从设计者的角度考虑系统猜想系统设计，为什么要这样设计，为什么要有这些构成。这样的基本原型是什么？系统的限制是什么，应用场景有哪些，有些设计的引进还是系统收敛性而为之呢。我们还可以从代码痕迹上去分析，这些概念是如何的得来的？从一定的抽象和高度去理解这些问题，遵循系统原型出发之原则，在深入分析代码的时候，就不容易陷入细节中。我们就可以随时跳出来想，这些代码在整体上载表达一个什么概念，在描绘一个什么逻辑，他要构成一个虚拟层吗？他是在管理这个硬件吗？他在虚拟这个对象吗？他在构建管理机构？还是在构建一个对象管理？空间管理，为了快速引入了什么样的复杂算法，实际上的原型算法应该是什么样的？</p><p>只有深入到这个抽象层次，我们才能很好的把握住系统的每一条线，每一个对象的意义。只用从原型出发，我们才能把握住这个系统的实质所在，在干什么？他要表达什么？设计者为什么要这样想？最终极的想法是什么？这样，代码分析就变得简单明了，读代码就变成了是在印证猜想，修正方向。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode图</title>
      <link href="2021/07/01/leetcode%E5%9B%BE/"/>
      <url>2021/07/01/leetcode%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeBFS</title>
      <link href="2021/06/30/leetcodeBFS/"/>
      <url>2021/06/30/leetcodeBFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeDFS</title>
      <link href="2021/06/30/leetcodeDFS/"/>
      <url>2021/06/30/leetcodeDFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcood动态规划相关题目</title>
      <link href="2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode22：括号生成"><a href="#leetcode22：括号生成" class="headerlink" title="leetcode22：括号生成"></a>leetcode22：括号生成</h1>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood链表相关题目</title>
      <link href="2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood二叉树相关题目</title>
      <link href="2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode栈和队列相关题目</title>
      <link href="2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode20：有效括号（栈可以解决）"><a href="#leetcode20：有效括号（栈可以解决）" class="headerlink" title="leetcode20：有效括号（栈可以解决）"></a>leetcode20：有效括号（栈可以解决）</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员代码面试指南第一章题目</title>
      <link href="2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h1><h2 id="1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"><a href="#1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。" class="headerlink" title="1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"></a>1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。</h2><p>思路：因为要返回栈中最小的元素，所以需要找个地方把最小的元素给存起来。这个存起来的过程涉及到判断最小的元素。</p><p>方法1：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​            压入规则：1、判断stackData是否为空。</p><p>​                                    1.1：为空，两个栈压入</p><p>​                                    1.2：不为空，stackData压入，然后判断压入数据和stackMin栈顶元素的大小，如果压入数据小或等于，也压入stackMin中。压入数据大于stackMin栈顶的元素，则不用压入。</p><p>​            弹出规则：压入规则的对应。</p><p>​            查询当前栈最小值的操作：stackMin保存着最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackNormal = new Stack();</span><br><span class="line">    Stack&lt;Integer&gt; stackSpecial = new Stack();</span><br><span class="line">//构造函数</span><br><span class="line">    public GetMin() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GetMin(Stack&lt;Integer&gt; stackNormal, Stack&lt;Integer&gt; stackSpecial) &#123;</span><br><span class="line">        this.stackNormal = stackNormal;</span><br><span class="line">        this.stackSpecial = stackSpecial;</span><br><span class="line">    &#125;</span><br><span class="line">//压入规则</span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">       stackNormal.push(input);</span><br><span class="line">       if (stackSpecial.size() == 0)&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stackSpecial.size() != 0 &amp;&amp; input &lt;= stackSpecial.peek())&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//弹出规则</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stackNormal.pop();</span><br><span class="line">        if (value == stackSpecial.peek())&#123;</span><br><span class="line">            stackSpecial.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">//查询规则</span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackSpecial.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​        压入规则：先判断stackData栈是否为空，为空的话两个栈同时压入。</p><p>​                            不为空：stackData压入数据，然后判断压入的数据和stackMin栈顶的元素的大小。如果大于stackMin栈顶的元素，stackMin再次压入当前栈顶的元素，如果小于stackMin栈顶的元素，则也直接压入stackMin。</p><p>​        弹出规则：压入规则的对应</p><p>​        查询规则：stackMin栈的栈顶元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin2 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackData = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackMin = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public GetMin2(Stack&lt;Integer&gt; stackData, Stack&lt;Integer&gt; stackMin) &#123;</span><br><span class="line">        this.stackData = stackData;</span><br><span class="line">        this.stackMin = stackMin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">        stackData.push(input);</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            stackMin.push(input);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (input &lt;= stackMin.peek())&#123;</span><br><span class="line">                stackMin.push(input);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stackMin.push(stackMin.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackData.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stackMin.pop();</span><br><span class="line">        return stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackMin.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="两个栈组成的队列"><a href="#两个栈组成的队列" class="headerlink" title="两个栈组成的队列"></a>两个栈组成的队列</h1><h5 id="2、编写一个类，用两个栈实现队列，支持队列的基本操作"><a href="#2、编写一个类，用两个栈实现队列，支持队列的基本操作" class="headerlink" title="2、编写一个类，用两个栈实现队列，支持队列的基本操作"></a>2、编写一个类，用两个栈实现队列，支持队列的基本操作</h5><p>思路：栈的特点是先进后出，队列的特点是先进先出。所以我们需要从stackIn中数据倒入stackOut中，在出栈就会满足队列的特点。注意点1：就是从stackIn转移数据到stackOut中的时候，需要把stackIn中的数据全部出栈，再stackOut中进栈。注意点2：如果stackOut不空的时候stackIn不能向stackOut中压入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TwoStackToQueue &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackOut = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(int input)&#123;</span><br><span class="line">        stackIn.push(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int poll()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode168Excel表列名称</title>
      <link href="2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
      <url>2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode168：Excel表列名称"><a href="#leetcode168：Excel表列名称" class="headerlink" title="leetcode168：Excel表列名称"></a>leetcode168：Excel表列名称</h1><p>题目：给你一个整数，返回它在Excel表中相应的列名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">例如：</span><br><span class="line">输入：columnNumber = 1</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">输入：columnNumber = 28</span><br><span class="line">输出：&quot;AB&quot;</span><br><span class="line">输入：columnNumber = 2147483647</span><br><span class="line">输出：&quot;FXSHRXW&quot;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>这道题属于简单题。首先要能够意识这道题考察了进制之间的转换。另外本题中的范围为【1-26】，要变化为【0-25】。</p><h5 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h5><p>1、m进制转化为10进制。</p><p>​        方法：从低位到高位按权展开</p><p>2、10进制转换为n进制</p><p>​        方法：除留取余，逆序排序</p><p>3、本题中的范围是【1-26】，需要对每个进行求余和整除的数减一，在对26进行求余运算，把范围变成【0-25】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String convertToTitle(int columnNumber)&#123;</span><br><span class="line">    //用的stringBuilder进行储存</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    while (columnNumber &gt; 0)&#123;</span><br><span class="line">        columnNumber--;</span><br><span class="line">        //减一,为什么减一。因为26在本题中对应的Z，但是和26除余之后为0.</span><br><span class="line">        //举个例子，比如1--&gt;A.减一除余之后为0，在加A（是加的ASCII码）就变成了A。</span><br><span class="line">        stringBuilder.append((char)((columnNumber % 26) + &#x27;A&#x27;));</span><br><span class="line">        columnNumber = columnNumber / 26;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.reverse();</span><br><span class="line">    return stringBuilder.toString();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin基础</title>
      <link href="2021/06/28/kotlin%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/28/kotlin%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin从入门到进阶实战"><a href="#Kotlin从入门到进阶实战" class="headerlink" title="Kotlin从入门到进阶实战"></a>Kotlin从入门到进阶实战</h1><h2 id="变量和标识符"><a href="#变量和标识符" class="headerlink" title="变量和标识符"></a>变量和标识符</h2><p>变量标识一个对象的地址，称之为标识符。具体存放的数据占用的内存的大小和存放的形式由其类型来决定。</p><p>kotlin中所有的变量类型都是引用类型。kotlin变量分为</p><p>​        val（不可变的）：只读的，仅能赋值一次</p><p>​        var（可写的）：可以被多次赋值</p><h2 id="关键字和修饰符"><a href="#关键字和修饰符" class="headerlink" title="关键字和修饰符"></a>关键字和修饰符</h2><p>关键字：类修饰符、成员修饰符、访问权限修饰符、协变逆变修饰符、函数修饰符、属性修饰符、参数修饰符等</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>分支语句（if、when）</p><p>​        在Kotlin中，if是一个表达式，会返回一个值</p><p>​        if的分支可以是代码块，最后的表达式作为该块的值</p><p>​        when表达式类似于switch..case表达式</p><p>循环语句（for、while）</p><p>​        for循环可以对任何提供迭代器（iterator）的对象进行遍历</p><p>​        while循环类似于java</p><p>跳转语句（return、break、continue、throw）</p><p>​        break：用于完全结束一个循环，直接跳出循环体，然后执行循环后面的语句。<br>​        continue：只终止本轮循环，但是还会继续下一轮循环。</p><p>​        return：kotlin中除了表达式的值，有返回值的函数都要求显示使用return语句返回其值。kotlin中可以直接使用“=”符号返回一个函数的值，这样的函数称为函数字面量。</p><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>kotlin中任何表达式都可以用标签来标记。标签的格式为标识符后跟@符号，可以用标签来控制return、break、continue等语句的跳转行为。</p><h5 id="基本类型："><a href="#基本类型：" class="headerlink" title="基本类型："></a>基本类型：</h5><p>​        在kotlin中，所有东西都是对象，我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示–数字、字符、布尔值在运行时表示为原生类型值，但对于用户来说，看起来就像是普通的类。kotlin中的基本类型：数字、字符、布尔值、数组与字符串。</p><p>整型：Byte、Short、Int、Long。</p><p>​        所有未超出Int最大值的整形值且未显示指定类型，都会被推断为Int类型。如果初始值超过了其最大值且未显示指定类型会被推断为Long类型。</p><p>浮点型：Float、Double。</p><p>​        对于以小数初始化的变量，编译器会推断为Double类型。可以添加f或F将值显示指定为Float类型。</p><p>​        三个特殊的浮点型数值：正无穷大、负无穷大和非数。所有的正无穷大数值都相等，所有的负无穷大数值都相等，非数不与任何数值相等且非数之间也不相等（因为非数之间比较没有意义）</p><p>​        kotlin没有隐式拓宽转换，具有Double参数的函数只能对Double值调用，而不能对Float、Int其他数字值调用 。</p><p>字符型：kotlin语言使用16位的unicode字符集作为编码方式。kotlin中的Char型变量不能当成整数值使用，Char型变量不能赋值给整型变量，整型变量也不能赋值给Char型变量。</p><p>字面值常量：</p><p>​        十进制：123.  Long类型用大写L标记：123L</p><p>​        十六进制：0x0F</p><p>​        二进制：0b00001011</p><p>​        不支持八进制</p><p>支持浮点数的常规表示方法：</p><p>​        默认double:123.5</p><p>​        Float用f或者F标记：123.5f</p><p> kotlin中，较小类型不是较大类型的子类型，所以较小类型不能隐式转换为较大类型。必须通过显示转换。toByte（）、toShort（）、toInt（）、toLong（）等。</p><p>kotlin在表达式中可以自动转换，这种转换是基于上下文推断出来的，算术运算符会有重载做适当转换。</p><p>布尔：布尔用Boolean类型表示，有两个值true和false</p><p>121000004352307294</p><h1 id="疯狂kotlin讲义"><a href="#疯狂kotlin讲义" class="headerlink" title="疯狂kotlin讲义"></a>疯狂kotlin讲义</h1><h2 id="kotlin的基础类型："><a href="#kotlin的基础类型：" class="headerlink" title="kotlin的基础类型："></a>kotlin的基础类型：</h2><p>声明变量：var | val  变量名 【：类型】【= 初始值】</p><p>var声明的变量可被多次赋值，val声明的变量不可被重新赋值</p><p>kotlin是强类型的语言，要求所有的变量必须先声明、后使用，声明变量时必须显示或隐式指定变量的类型。</p><p>程序要么通过“：类型”的形式显示指定该变量的类型，要么为该变量指定初始值-kotlin编译器会根据初始值确定变量的类型。不能声明变量时既不指定变量类型、也不指定变量的初始值。</p><p>常量：</p><p>​        局部范围的常量：允许在声明时不指定初始值，只要在第一次使用之前指定初始值就可以。</p><p>​        类的常量属性：这种常量属性既可以在声明时指定初始值，也可以在类或结构体的构造器中指定初始值。</p><p>kotlin程序编译的字节码必须遵守JVM规范，直接在kotlin程序中定义变量、函数，kotlinc将会自动生成一个名为“文件名首字母大写+Kt”的类，并将变量转换为该类的静态getter、setter方法（val声明的只有getter方法），函数转换为该类的静态方法。</p><p>null安全：只有可空类型的变量或常量才能接受null，非空类型的变量或常量不能接受null。</p><p>kotlin对可空类型进行了限制，可空类型不允许直接调用方法、访问属性。需要先判断该变量不为null，然后再调用该变量的方法和属性。kotlin：“！！”强制调用可空变量的方法和属性，可能引发NPE</p><h5 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h5><p>​        kotlin中的字符串有两种字面值：</p><p>​            转义字符串：可以有转义字符，转移字符串很像普通的java字符串。</p><p>​            原始字符串：可以包含换行和任意文本，原始字符串需要3个引号引起来。</p><p>​        字符串模板：允许在字符串中嵌入变量或表达式，只要将变量或表达式放入${}中，kotlin会把该变量或表达式的值嵌入该字符串中。</p><h5 id="类型别名："><a href="#类型别名：" class="headerlink" title="类型别名："></a>类型别名：</h5><p>​        kotlin提供typealias来定义类型别名。</p><p>​        typealias 类型别名 = 已有类型</p><h2 id="第三章：运算符和表达式"><a href="#第三章：运算符和表达式" class="headerlink" title="第三章：运算符和表达式"></a>第三章：运算符和表达式</h2><p>java支持的运算符包括算数运算符、赋值运算符、扩展后的赋值运算符、比较运算符、逻辑运算符。kotlin也完全支持。</p><p>kotlin不支持三目运算符，kotlin使用if表达式代替了三目运算符。kotlin的运算符都是以方法形式实现的。</p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划总结</title>
      <link href="2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer42：连续子数组的最大和"><a href="#剑指offer42：连续子数组的最大和" class="headerlink" title="剑指offer42：连续子数组的最大和"></a>剑指offer42：连续子数组的最大和</h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>暴力递归：遍历数组，以i为子数组开始的所有子数组。并且比较大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">    int ans = Integer.MIN_VALUE;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        for (int j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum = sum + nums[j];</span><br><span class="line">            if (sum &gt; ans)&#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>如果当前子数组加上下一位变小了，说明需要重新选择子数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">        int currSum = 0;</span><br><span class="line">        int maxSum = Integer.MIN_VALUE;       //全负情况，返回最大数</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            currSum = (nums[j] &gt; currSum + nums[j]) ? nums[j] : currSum + nums[j];</span><br><span class="line">            maxSum = (maxSum &gt; currSum) ? maxSum : currSum;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转换成动态规划的过程：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        for(int j = 1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(dp[j-1]&gt;0)&#123;</span><br><span class="line">                dp[j] = dp[j-1]+nums[j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[j] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            if(dp[i]&gt;max)</span><br><span class="line">                max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法之动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin</title>
      <link href="2021/06/24/kotlin/"/>
      <url>2021/06/24/kotlin/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-docs（基本语法）"><a href="#Kotlin-docs（基本语法）" class="headerlink" title="Kotlin-docs（基本语法）"></a>Kotlin-docs（基本语法）</h1><p>包的定义和导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包的声明应处于源文件的顶部：</span><br><span class="line">package my.demo</span><br><span class="line">import kotlin.txt</span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kotlin的入口点是main函数</span><br><span class="line">带有两个Int参数、返回Int的函数</span><br><span class="line">fun sum(a: Int, b: Int): Int&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">将表达式作为函数体、返回值类型自动推断的函数</span><br><span class="line">fun sum(a: Int, b: Int) = a + b</span><br><span class="line">函数返回无意义的值：</span><br><span class="line">fun printSum(a: Int, b: Int): Unit&#123;</span><br><span class="line">println(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">Unit返回类型可以省略</span><br><span class="line">fun printSum(a: Int, b: Int)&#123;</span><br><span class="line">printLn(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var maximun:Int = 5</span><br><span class="line">变量定义关键字 变量名 类型定义 赋值运算符 赋值</span><br><span class="line">简写：var maximun = 5</span><br><span class="line">变量名关键字 变量名 赋值运算符 赋值（相比少了一个类型定义，因为kotlin可以进行类型推断）</span><br><span class="line"></span><br><span class="line">var关键字修饰的是可修改变量</span><br><span class="line">val关键字修饰的是只读变量</span><br><span class="line"></span><br><span class="line">类型推断：对与以声明并赋值的变量，允许省略类型定义</span><br><span class="line"></span><br><span class="line">定义只读局部变量使用关键字val定义，只能为其赋值一次</span><br><span class="line">val a: Int = 1//立即赋值</span><br><span class="line">val b = 2//自动推断出Int类型</span><br><span class="line">val c: Int //如果没有初始值类型不能省略</span><br><span class="line">c = 3 //明确赋值</span><br><span class="line"></span><br><span class="line">可重新赋值的变量使用var关键字</span><br><span class="line">var x = 5 //自动推断出Int类型</span><br><span class="line">x += 1</span><br><span class="line">顶层变量</span><br><span class="line">val PI = 3.14</span><br><span class="line">var x = 0</span><br><span class="line">fun incre()&#123;</span><br><span class="line">x += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时常量：只能定义在函数之外，因为编译时常量必须在编译时赋值，函数都是在运行时才调用，函数内的变量是在运行时赋值，编译时常量要在这些变量赋值前就已经存在。</p><p>编译时常量只能是常见的基本数据类型：String、Int、Double、Float、Long、Short、Byte、Char、Boolean</p><p>kotlin只提供引用类型这一种数据类型，但是kotlin编译器会在java字节码中改用基本数据类型</p><p>空值和null检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当某个变量的值可以为null的时候，必须在声明处的类型后添加？，来标识该引用可以为空</span><br><span class="line">fun parseInt(str: String): Int?&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型检测与自动类型转换:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is运算符检测一个表达式是否某类型的一个实例。如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显示转换。</span><br><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">if (obj is String) &#123;</span><br><span class="line">// `obj` 在该条件分⽀内⾃动转换成`String`</span><br><span class="line">return obj.length</span><br><span class="line">&#125;</span><br><span class="line">// 在离开类型检测分⽀后，`obj` 仍然是`Any` 类型</span><br><span class="line">return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>for循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;,&quot;kiwifruit&quot;)</span><br><span class="line">for(item in items)&#123;</span><br><span class="line">println(item)</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">for (index in items.indices) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>while循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">var index = 0</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>when表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun describe(obj: Any): String =</span><br><span class="line">when (obj) &#123;</span><br><span class="line">1 -&gt; &quot;One&quot;</span><br><span class="line">&quot;Hello&quot; -&gt; &quot;Greeting&quot;</span><br><span class="line">is Long -&gt; &quot;Long&quot;</span><br><span class="line">!is String -&gt; &quot;Not a string&quot;</span><br><span class="line">else -&gt; &quot;Unknown&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用区间（range）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">使用in运算符来检测某个数字是否在指定区间内</span><br><span class="line">val x = 10</span><br><span class="line">val y = 9</span><br><span class="line">if (x in 1..y+1) &#123;</span><br><span class="line">println(&quot;fits in range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">检测某个数字是否在指定区间外：</span><br><span class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">if (-1 !in 0..list.lastIndex) &#123;</span><br><span class="line">println(&quot;-1 is out of range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if (list.size !in list.indices) &#123;</span><br><span class="line">println(&quot;list size is out of valid list indices range, too&quot;)</span><br><span class="line">&#125;</span><br><span class="line">区间迭代：</span><br><span class="line">for (x in 1..5) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">数列迭代：</span><br><span class="line">for (x in 1..10 step 2) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line">for (x in 9 downTo 0 step 3) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="kotlin小知识点"><a href="#kotlin小知识点" class="headerlink" title="kotlin小知识点"></a>kotlin小知识点</h1><h5 id="强类型语言："><a href="#强类型语言：" class="headerlink" title="强类型语言："></a>强类型语言：</h5><p>​        一旦某一个变量被定义类型，如果不经过强制转换，就永远是该数据类型</p><h5 id="弱类型语言："><a href="#弱类型语言：" class="headerlink" title="弱类型语言："></a>弱类型语言：</h5><p>​        某一个变量被定义类型，该变量可以根据环境变化自动变化。</p><h5 id="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"><a href="#强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。" class="headerlink" title="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"></a>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</h5><h5 id="动态类型语言："><a href="#动态类型语言：" class="headerlink" title="动态类型语言："></a>动态类型语言：</h5><p>​        动态性语言是指在运行期间才去做数据类型检查的语言，也就是动态类型语言编程时，永远不用给任何变量指定数据类型。该语言会在第一次赋值给变量时，在内部将数据类型记录下来。python、ruby</p><h5 id="静态类型语言："><a href="#静态类型语言：" class="headerlink" title="静态类型语言："></a>静态类型语言：</h5><p>​        数据类型在编译期间检查，也就是在写程序的时候要声明变量的数据类型。</p><h5 id="kotlin中的常量问题？"><a href="#kotlin中的常量问题？" class="headerlink" title="kotlin中的常量问题？"></a><em><u>kotlin中的常量问题？</u></em></h5><h5 id="kotlin是null安全的语言："><a href="#kotlin是null安全的语言：" class="headerlink" title="kotlin是null安全的语言："></a>kotlin是null安全的语言：</h5><p>​        Byte、Short、Int、Long型变量都不能接受null值，如果要存储null值，应该使用Byte？、Short？、Int？、Long？类型（相当于支持null值的对应类型）。</p><p>​        加不加？后缀的另一个区别：普通类型的整形变量将会映射成java的基本类型，带？后缀的整形变量将会映射成基本类型的包装类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">val pm1 = 200;</span><br><span class="line">val pm2 = 200;</span><br><span class="line">println(pm1 == pm2);</span><br><span class="line">println(pm1 === pm2)</span><br><span class="line"></span><br><span class="line">val ob1: Int? = 200</span><br><span class="line">val ob2: Int? = 200</span><br><span class="line">println(ob1 == ob2)</span><br><span class="line">println(ob1 === ob2)</span><br><span class="line"></span><br><span class="line">val  ob3: Int? = 100</span><br><span class="line">val  ob4: Int? = 100</span><br><span class="line">println(ob3 == ob4)</span><br><span class="line">println(ob3 === ob4)</span><br><span class="line">结果如下：</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS服务和参数</title>
      <link href="2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/"/>
      <url>2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"><a href="#ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。" class="headerlink" title="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"></a>ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。</h2><h1 id="使用rosservice"><a href="#使用rosservice" class="headerlink" title="使用rosservice"></a>使用rosservice</h1><p>rosservice可以很容易通过服务附加到ROS客户端/服务器框架上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rosservice list         输出活跃服务的信息</span><br><span class="line">rosservice call         用给定的参数调用服务</span><br><span class="line">rosservice type         输出服务的类型</span><br><span class="line">rosservice find         按服务的类型查找服务</span><br><span class="line">rosservice uri          输出服务的ROSRPC uri</span><br></pre></td></tr></table></figure><p>rosservice type [service]:进一步查看服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /clear</span><br><span class="line">结果是：std_srvs/Empty</span><br></pre></td></tr></table></figure><p>服务的类型为empty，表明调用这个服务时不需要参数。（它在发出<strong>请求</strong>时不发送数据，在接收<strong>响应</strong>时也不接收数据）</p><p>rosservice call [service] [args]:call命令调用服务，args是给定的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear：</span><br><span class="line">call:表明调用clear服务</span><br></pre></td></tr></table></figure><p>查看spawn（产卵）服务的信息，此服务具有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /spawn | rossrv show</span><br></pre></td></tr></table></figure><p>​        spawn服务的参数：name字段是可选的        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">string name</span><br><span class="line">---</span><br><span class="line">string name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn 2 2 0.2 &quot;&quot;</span><br><span class="line">调用spawn服务，并且需要参数。</span><br><span class="line">clear服务不需要参数</span><br></pre></td></tr></table></figure><h1 id="使用rosparam"><a href="#使用rosparam" class="headerlink" title="使用rosparam"></a>使用rosparam</h1><p><code>rosparam</code>能让我们在ROS[参数服务器（Parameter Server）](<a href="http://wiki.ros.org/Parameter">http://wiki.ros.org/Parameter</a> Server)上存储和操作数据。参数服务器能够存储整型（integer）、浮点（float）、布尔（boolean）、字典（dictionaries）和列表（list）等数据类型。rosparam使用YAML标记语言的语法。一般而言，YAML的表述很自然：<code>1</code>是整型，<code>1.0</code>是浮点型，<code>one</code>是字符串，<code>true</code>是布尔型，<code>[1, 2, 3]</code>是整型组成的列表，<code>&#123;a: b, c: d&#125;</code>是字典。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS话题</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="理解ROS话题（乌龟走动幕后的故事）"><a href="#理解ROS话题（乌龟走动幕后的故事）" class="headerlink" title="理解ROS话题（乌龟走动幕后的故事）"></a>理解ROS话题（乌龟走动幕后的故事）</h1><p>roscore：只运行一个roscore就够了。</p><p>乌龟走动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个新终端：roscore</span><br><span class="line">新终端：rosrun turtlesim turtlesim_node</span><br><span class="line">新终端：rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><h2 id="ROS话题："><a href="#ROS话题：" class="headerlink" title="ROS话题："></a>ROS话题：</h2><p>​            turtlesim_node节点和turtle_teleop_key节点之间通过ROS话题相互通信。turtle_teleop_key在话题上发布键盘按下的信息，turtlesim_node订阅该话题以接收消息。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure><p>上述命令之后，rqt_graph会用动态的图显示系统中发生的事情。</p><h2 id="rostopic：rostopic命令工具能获取ROS话题的信息。"><a href="#rostopic：rostopic命令工具能获取ROS话题的信息。" class="headerlink" title="rostopic：rostopic命令工具能获取ROS话题的信息。"></a>rostopic：rostopic命令工具能获取ROS话题的信息。</h2><p>rostopic -h：查看可用的rostopic的子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">        rostopic bw     display bandwidth used by topic</span><br><span class="line">        rostopic delay  display delay of topic from timestamp in header</span><br><span class="line">        rostopic echo   print messages to screen</span><br><span class="line">        rostopic find   find topics by type</span><br><span class="line">        rostopic hz     display publishing rate of topic    </span><br><span class="line">        rostopic info   print information about active topic</span><br><span class="line">        rostopic list   list active topics</span><br><span class="line">        rostopic pub    publish data to topic</span><br><span class="line">        rostopic type   print topic or field type</span><br></pre></td></tr></table></figure><p>rostopic echo [topic]:查看在某个话题上发布的数据。（也就是去订阅了话题）</p><p>rostopic list -h：查看可用的rostopic list子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -b BAGFILE, --bag=BAGFILE</span><br><span class="line">                        list topics in .bag file</span><br><span class="line">  -v, --verbose         list full details about each topic</span><br><span class="line">  -p                    list only publishers</span><br><span class="line">  -s                    list only subscribers</span><br></pre></td></tr></table></figure><p>rostopic list -v：会列出所有发布者和订阅的主题及其类型的相关信息。</p><h1 id="ROS消息"><a href="#ROS消息" class="headerlink" title="ROS消息"></a>ROS消息</h1><p>话题的通信是通过节点间发送ROS消息实现的。为了使发布者和订阅者进行通信，发布者和订阅者必须发送和接收相同类型的消息。所以话题的类型是由发布在上面的消息的类型决定的。</p><p>rostopic type 【topic】:查看所发布话题的消息类型。    </p><p>​        使用rosmsg show  【geometry_msgs/Twist】查看消息的详细信息。</p><h2 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic:"></a>rostopic:</h2><p>rostopic pub 【topic】【msg_type】【args】:把数据发布到当前某个正在广播的话题上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, 1.8]&#x27;</span><br></pre></td></tr></table></figure><p>rostopic pub:将消息发布到指定的话题。</p><p>-1：让rostopic只发布一条消息，然后退出</p><p>/turtle1/cmd_vel：要发布到的话题的名称</p><p>geometry_msgs/Twist：发布到话题时要使用的消息的类型</p><p>–：两个破折号，用来告诉解析器，之后的参数都不是选项</p><p>如前所述，一个turtlesim/Velocity消息有两个浮点型元素：<code>linear</code>和<code>angular</code>。在本例中，<code>&#39;[2.0, 0.0, 0.0]&#39;</code>表示<code>linear</code>的值为<code>x=2.0</code>, <code>y=0.0</code>, <code>z=0.0</code>，而<code>&#39;[0.0, 0.0, 1.8]&#39;</code>是说<code>angular</code>的值为<code>x=0.0</code>, <code>y=0.0</code>, <code>z=1.8</code>。这些参数实际上使用的是YAML语法，在<a href="http://wiki.ros.org/ROS/YAMLCommandLine">YAML命令行文档</a>中有描述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, -1.8]&#x27;</span><br></pre></td></tr></table></figure><p>turtle以一个稳定的频率为1Hz的指令流才能保持移动状态。我们可以使用<code>rostopic pub -r</code>命令来发布源源不断的命令。</p><p>rostopic hz 【topic】：报告数据发布的速率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic type /turtle1/cmd_vel | rosmsg show</span><br></pre></td></tr></table></figure><p>结合rostopic、type、rosmsg show、命令来获取关于某个话题的更深层次的信息。</p><h1 id="使用rqt-plot"><a href="#使用rqt-plot" class="headerlink" title="使用rqt_plot"></a>使用rqt_plot</h1><p><code>rqt_plot</code>命令可以在滚动时间图上显示发布到某个话题上的数据。这里我们将使用<code>rqt_plot</code>命令来绘制正被发布到<code>/turtle1/pose</code>话题上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS节点</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p>计算图是一个由ROS进程组成的点对点网络，能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Services）、话题（Topics）、包（Bags）。</p><p>节点：是ROS软件包中的一个可执行文件，可以通过ROS来与其他节点通信。</p><p>​            ROS节点使用ROS客户端与其他节点通信。节点可以发布或订阅话题，也可以提供或使用服务。</p><p>消息：订阅或发布话题时所使用的的ROS数据类型。</p><p>话题：节点可以将消息发布到话题或者通过订阅话题来接收消息。</p><p>主节点：ROS的命名服务，帮助节点发现彼此。</p><p>rosout：相当于stdout/stderr（标准输出、标准错误）</p><p>​                rosout节点，用于收集和记录节点的调试输出，所以总是在运行。</p><p>roscore：主节点+rosout+参数服务器</p><p>​                运行所有ROS程序前需要运行的命令。</p><p>客户端库：ROS客户端库可以让不同编程语言编写的节点进行相互通信</p><p>​                    rospy=python客户端库</p><p>​                    roscpp=c++客户端库</p><p>rosnode:获取接地那信息的ros工具</p><p>​                rosnode list：列出活动的节点</p><p>​                rosnode info：返回某个节点的信息。rosnode info /rosout</p><p>​                rosnode cleanup：尝试清除rosnode列表</p><p>rosrun：运行给定的软件包中的节点</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terminator常用快捷键</title>
      <link href="2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //移动到上面的终端</span><br><span class="line">Alt+Down                        //移动到下面的终端</span><br><span class="line">Alt+Left                        //移动到左边的终端</span><br><span class="line">Alt+Right                       //移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line">Ctrl+Shift+S                    //隐藏/显示滚动条</span><br><span class="line">Ctrl+Shift+F                    //搜索</span><br><span class="line">Ctrl+Shift+C                    //复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V                    //粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+W                    //关闭当前终端</span><br><span class="line">Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭</span><br><span class="line">Ctrl+Shift+X                    //最大化显示当前终端</span><br><span class="line">Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大</span><br><span class="line">Ctrl+Shift+N or Ctrl+Tab        //移动到下一个终端</span><br><span class="line">Ctrl+Shift+P or Ctrl+Shift+Tab  //Crtl+Shift+Tab 移动到之前的一个终端</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="标签之间的操作"><a href="#标签之间的操作" class="headerlink" title="标签之间的操作"></a>标签之间的操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F11                             //全屏开关</span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line">Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置</span><br><span class="line">Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置</span><br><span class="line">Ctrl+Plus (+)                   //增大字体</span><br><span class="line">Ctrl+Minus (-)                  //减小字体</span><br><span class="line">Ctrl+Zero (0)                   //恢复字体到原始大小</span><br><span class="line">Ctrl+Shift+R                    //重置终端状态</span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line">Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端</span><br><span class="line">Super+Shift+G                   //解除绑定</span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line">Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程</span><br><span class="line">Super+i                         //打开一个新窗口，新窗口与原来的窗口使用不同的进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS软件包</title>
      <link href="2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
      <url>2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="创建ROS软件包"><a href="#创建ROS软件包" class="headerlink" title="创建ROS软件包"></a>创建ROS软件包</h1><ol><li><p>catkin软件包的组成：</p><ol><li>必须有一个符合catkin规范的package.xml文件。</li><li>必须有一个CMakeLists.txt文件</li><li>每个包必须有自己的目录。同一目录下不能嵌套或者多个软件包存在</li></ol></li><li><p>catkin工作空间中的软件包</p><ol><li><p>推荐使用catkin工作空间，也可以单独开发catkin软件包</p></li><li><p>创建软件包之前需要创建工作空间</p></li><li><pre><code>workspace_folder/        -- WORKSPACE  src/                   -- SOURCE SPACE    CMakeLists.txt       -- &#39;Toplevel&#39; CMake file, provided by catkin    package_1/      CMakeLists.txt     -- CMakeLists.txt file for package_1      package.xml        -- Package manifest for package_1    ...    package_n/      CMakeLists.txt     -- CMakeLists.txt file for package_n      package.xml        -- Package manifest for package_n<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 创建catkin软件包（功能包）</span><br><span class="line"></span><br><span class="line">   1. 切换到catkin工作空间中的源文件空间目录</span><br><span class="line"></span><br></pre></td></tr></table></figure> cd ~/catkin_ws/src<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用catkin_create_pkg命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>catkin_create_pkg catkin软件包名 std_msgs rospy roscpp<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      catkin软件包内包含[package.xml](http://wiki.ros.org/catkin/package.xml)文件和一个[CMakeLists.txt](http://wiki.ros.org/catkin/CMakeLists.txt)文件，文件中有执行catkin_create_pkg命令时提供的信息。</span><br><span class="line"></span><br><span class="line">      std_msgs rospy roscpp三个包是依赖。</span><br><span class="line"></span><br><span class="line">4. 包依赖关系</span><br><span class="line"></span><br><span class="line">   1. 一级依赖</span><br><span class="line">   2. 间接依赖</span><br><span class="line"></span><br><span class="line"># 构建ROS软件包</span><br><span class="line"></span><br><span class="line">在catkin工作空间构建ros软件包</span><br><span class="line"></span><br><span class="line">catkin_make:是一个命令行工具，它简化了标准catkin工作流程。你可以认为`catkin_make`是在标准CMake工作流程中依次调用了`cmake`和`make`。</span><br><span class="line"></span><br></pre></td></tr></table></figure>#在catkin工作空间下catkin_make<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">build:构建空间的默认位置，同时cmake和make在这里被调用用来配置和构建软件包。</span><br><span class="line"></span><br><span class="line">devel：开发空间的默认位置，在安装软件包之前，这里存放可执行文件和库。</span><br><span class="line"></span><br><span class="line">src：源码文件</span><br><span class="line"></span><br><span class="line"># 创建ROS工作空间（先于创建ROS软件包）</span><br><span class="line"></span><br></pre></td></tr></table></figure>$ mkdir -p ~/工作空间名/src$ cd ~/catkin_ws/$ catkin_make</code></pre></li></ol></li></ol><p>catkin_make命令：在工作空间第一次运行的时候，会在src目录下创建CMakeLists.txt链接。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS文件系统</title>
      <link href="2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>软件包（packages）：包是ROS代码的软件组织单元，每个软件包都可以包含程序库、可执行文件、脚本或其他构件。</p><p>Manifests（package.xml）:清单是对软件包的描述，用于定义软件包之间的依赖关系，并记录有关软件包的元信息。如版本、维护者、许可证</p><h1 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h1><p>ROS提供了专门的命令工具来实现ros软件包的查找和导航。</p><ul><li><p>rospack：获取软件包的有关信息。find选项返回软件包所在路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack find roscpp</span><br></pre></td></tr></table></figure><p>结果：/opt/ros/<distro>/share/roscpp</p></li><li><p>roscd:直接切换目录到某个软件包或者软件包集中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd roscpp</span><br><span class="line">roscd roscpp/cmake</span><br></pre></td></tr></table></figure><p>只能切换到那些路径包含在ROS_PACKAGE_PATH环境变量中的软件包。</p></li><li><p>roscd log:进入存储ROS日志文件的目录，如果没有执行过任何ROS程序，系统会报错说该目录不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd log</span><br></pre></td></tr></table></figure></li><li><p>rosls: 允许直接按软件包的名称执行，而不必输入绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosls roscpp_tutorials</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="VIM常用命令："><a href="#VIM常用命令：" class="headerlink" title="VIM常用命令："></a>VIM常用命令：</h1><h2 id="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"><a href="#vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。" class="headerlink" title="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"></a>vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。</h2><p>命令模式（一般模式）：启动vim就进入了命令模式。此时键盘动作被识别为命令，比如：i切换到输入模式、x删除当前光标所在处的字符、：切换到底线命令模式、u撤回上一步的操作。</p><p>输入模式（编辑模式）：ESC键退出输入模式，切换到命令模式。</p><p>底线命令模式：命令模式下按:（英文）进入底线命令模式。q退出程序、w保存文件、ESC退出底线命令模式。</p><p>搜索替换：命令模式下，（/word，代表向光标之下寻找一个字符串）（？word，代表向光标之上寻找一个字符串），n代表重复前一个搜索动作，N反向搜索的动作。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rosDay1</title>
      <link href="2021/06/03/rosDay1/"/>
      <url>2021/06/03/rosDay1/</url>
      
        <content type="html"><![CDATA[<h1 id="helloworld实现过程（C-）："><a href="#helloworld实现过程（C-）：" class="headerlink" title="helloworld实现过程（C++）："></a>helloworld实现过程（C++）：</h1><p>1.创建工作空间并编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 工作空间名称/src</span><br><span class="line">cd 工作空间</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>首先会创建一个工作空间和一个src子目录，进入工作空间调用catkin_make命令编译。</p><p>2.进入工作空间下的src目录，创建ros功能包并添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src</span><br><span class="line">catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure><p>会在工作空间下生成一个功能包，该功能包依赖于 roscpp、rospy 与 std_msgs，其中roscpp是使用C++实现的库，而rospy则是使用python实现的库，std_msgs是标准消息库，创建ROS功能包时，一般都会依赖这三个库实现。</p><p>3.进入ros功能包下的src目录编辑源文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src/功能包/src</span><br></pre></td></tr></table></figure><p>注意是功能包下的src目录，编辑源文件。</p><p>4.编辑配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">配置文件位置：和功能包下的src平级的</span><br><span class="line">cd 工作空间/src/功能包/CMakeLists.txt</span><br><span class="line">编辑内容如下：</span><br><span class="line">add_executable(步骤3的源文件名</span><br><span class="line">  src/步骤3的源文件名.cpp</span><br><span class="line">)</span><br><span class="line">两个参数：分别修改为如下</span><br><span class="line">1.相当于后边原文件名的别名，可以任意名字，一般建议为原文件名</span><br><span class="line">2：功能包/src/源文件名.cpp</span><br><span class="line"></span><br><span class="line">修改链接库：</span><br><span class="line">target_link_libraries(步骤3的源文件名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line">修改第一个参数：</span><br><span class="line">1.修改为add_executable中的一个参数名（也就是源文件名的别名）</span><br></pre></td></tr></table></figure><p>5.编译执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在工作空间目录下编译</span><br><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行过程：</span><br><span class="line">启动命令：roscore</span><br><span class="line">另外一个终端：</span><br><span class="line">cd 工作空间</span><br><span class="line">source ./devel/setup.bash（作用：把当前工作空间刷新到当前窗口下的环境变量。缺点是：只在当前终端管用）</span><br><span class="line">rosrun 包名 C++节点（源文件的映射名字）</span><br></pre></td></tr></table></figure><p><code>source ~/工作空间/devel/setup.bash</code>可以添加进<code>.bashrc</code>文件，使用上更方便</p><p>添加方式1: 直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容</p><p>添加方式2:<code>echo &quot;source ~/工作空间/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p><h1 id="helloworld实现过程（python）"><a href="#helloworld实现过程（python）" class="headerlink" title="helloworld实现过程（python）"></a>helloworld实现过程（python）</h1><p>1.创建工作空间和功能包（如上cpp过程）</p><h1 id="ROS工作空间目录"><a href="#ROS工作空间目录" class="headerlink" title="ROS工作空间目录"></a>ROS工作空间目录</h1><p>工作空间：是一个存放工程开发相关文件的文件夹</p><ol><li>build:编译空间，编译过程产生的中间文件</li><li>devel：开发空间，可执行文件和相关脚本</li><li>src：代码空间</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="新建文章步骤："><a href="#新建文章步骤：" class="headerlink" title="新建文章步骤："></a>新建文章步骤：</h1><p>1.在你的博客目录下，右键Git Bash Here。输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章的名字&quot;</span><br></pre></td></tr></table></figure><p>2.在博客目录下/source/_posts/文件夹下，会生成”文章的名字.md”文件</p><p>3.在文件中编辑博客内容。hexo发布的文章是Markdown格式的文件。我使用的Typora软件进行编辑的。Markdown语法可以参考如下网址：<a href="http://www.markdown.cn/">语法网址</a>。</p><p>4.给文章添加分类和标签：在md文件中设置tags和categories属性就行了。</p><p>5.hexo s，启动本地服务器进行测试</p><p>6.hexo clean：清楚命令</p><p>hexo g：重新生成</p><p>hexo d：发布命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="2021/06/02/ros/"/>
      <url>2021/06/02/ros/</url>
      
        <content type="html"><![CDATA[<p>机器人操作系统(ROS)是一个用于编写机器人软件的灵活框架。它是一个工具、库和约定的集合，旨在简化跨各种机器人平台创建复杂和健壮的机器人行为的任务。ROS操作系统是目前使用最广泛的开源机器人软件平台，在无人驾驶系统的实现上，ROS是开源框架中的最好的选择。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。</p><span id="more"></span><p>ROS1.0的架构核心是基于message的松耦合、分布式架构。核心概念有：Node、Master、Message、Topic、Services等。因为ROS1.0在设计之初没有考虑到安全问题，所以ROS 1.0框架主要安全风险充分暴露：匿名通信无身份认证、消息明文传输、缺少访问控制等。</p><p>ROS2.0采用DDS替换了ROS1.0的publish-subscribe通信机制，因为DDS本身是有Security安全协议规范的，因此ROS2.0的安全主要基于DDS-Security。</p><p>DDS-Security规范对DDS规范进行了扩展，通过定义服务插件接口(Service Plugin Interface，SPI)体系结构、SPI的一组内置实现以及SPI实施的安全模型，增加了安全增强功能。具体地说，定义了五个SPI：</p><p>身份验证：验证给定域参与者的身份。</p><p>访问控制：对可由验证域参与者执行的与DDS相关的操作实施限制。 </p><p>加密：处理所有必需的加密、签名和散列操作。</p><p>日志记录：提供审计与DDS安全相关的事件的能力。 </p><p>数据标记：提供向数据样本添加标记的功能。</p><p>ROS 2的安全功能目前只使用前三个功能。这是因为为了符合DDS-Security规范，既不需要日志记录，也不需要数据标记，因此并不是所有的DDS实现都支持它们。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 自动驾驶操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/25/hello-world/"/>
      <url>2021/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
