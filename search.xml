<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序算法</title>
      <link href="2021/07/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2021/07/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="2021/07/27/jvm/"/>
      <url>2021/07/27/jvm/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-27</title>
      <link href="2021/07/27/7-27/"/>
      <url>2021/07/27/7-27/</url>
      
        <content type="html"><![CDATA[<h1 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671.二叉树中第二小的节点"></a>671.二叉树中第二小的节点</h1><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p>更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</p><p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p><p>思路：BFS和集合排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int findSecondMinimumValue(TreeNode root)&#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty())&#123;</span><br><span class="line">        int size = queue.size();</span><br><span class="line">        TreeNode node = queue.remove();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        if (node.left != null)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = list.get(0);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    for (int rev : list)&#123;</span><br><span class="line">        if (rev &gt; ans)&#123;</span><br><span class="line">            return rev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="2021/07/27/java/"/>
      <url>2021/07/27/java/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h1 id="java笔记复习"><a href="#java笔记复习" class="headerlink" title="java笔记复习"></a>java笔记复习</h1><h6 id="方法重载：与返回值类型无关，与修饰符列表无关"><a href="#方法重载：与返回值类型无关，与修饰符列表无关" class="headerlink" title="方法重载：与返回值类型无关，与修饰符列表无关"></a>方法重载：与返回值类型无关，与修饰符列表无关</h6><p>什么时候考虑方法重载：在同一个类中，方法一和方法二功能相似，可以考虑将它们的方法名一致。</p><p>什么时候会发生重载：同一个类中，方法名相同，参数列表不同（参数个数、参数类型、参数顺序不同）会发生重载。</p><h6 id="方法递归："><a href="#方法递归：" class="headerlink" title="方法递归："></a>方法递归：</h6><p>​        方法自己调用自己，递归一定要有结束条件。</p><p>​        先检查递归的结束条件对不对</p><p>​        手动调整JVM栈内存初始化大小，将栈内存大小调大</p> <h6 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h6><p>​        变量根据出现的位置：局部变量、成员变量（实例变量和静态变量）</p><p>​        局部变量：方法体内声明，不会默认赋值。变量必须先声明再赋值才能访问。局部变量只在方法体（在自己的作用域）中有效，方法结束，内存释放。</p><p>​        实例变量：方法体外声明，实例变量没有手动赋值，系统会默认赋值（构造方法执行的时候）。实例变量时对象级别的变量，必须先创建对象才能访问，不能通过类名直接访问。</p><p>​        静态变量：类变量。</p><h6 id="对象和引用的区别？"><a href="#对象和引用的区别？" class="headerlink" title="对象和引用的区别？"></a>对象和引用的区别？</h6><p>​        对象是通过new出来的，在堆内存中存储。</p><p>​        引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。保存地址指向堆内存中的对象</p><p>​        保存对象内存地址的变量称为引用</p><p>​        对象在内存中的内存地址，附给实例化过程中的变量名</p><p>​        访问实例变量：引用.实例变量名    </p><p>​        因为java中没有指针，所以只能通过引用来操作堆内存</p><p>​        <u><em><strong>引用不一定是局部变量，也可能是实例变量</strong></em>。</u></p><h2 id="方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。"><a href="#方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。" class="headerlink" title="方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。"></a>方法调用时参数的传递问题：java中参数传递的时候和类型无关，不管是基本数据类型还是应用数据类型，都是将盒子中的值，复制一份传递下去。</h2><p>​        Java中其实都是值传递，只是有的时候是传递的数据的值，有的时候呢传递的是引用地址的值</p><h6 id="对于基本数据类型来说："><a href="#对于基本数据类型来说：" class="headerlink" title="对于基本数据类型来说："></a>对于基本数据类型来说：</h6><p>传递的是数据的值，在接受参数的函数里改变的时候原来的是不会有任何影响的。</p><h6 id="对于引用类型来说："><a href="#对于引用类型来说：" class="headerlink" title="对于引用类型来说："></a>对于引用类型来说：</h6><p>传递的是一个引用、这个引用存放的是<strong>参数的地址的值</strong>，如果在函数中没有改变这个参数的引用地址（没有new一个新的地址—这也叫做浅拷贝），那么就会改变原来的值，影响到传入的参数。（比如数组、集合就是很明显的例子）；如果在函数中改变了参数的引用地址,也就是new了一个，那就不会改变参数的值了，这也叫做深拷贝。</p><h6 id="对于String类型和包装类型来说："><a href="#对于String类型和包装类型来说：" class="headerlink" title="对于String类型和包装类型来说："></a>对于String类型和包装类型来说：</h6><hr><blockquote><p>String类型和包装类型都是对象类型，所以必然是引用传递</p></blockquote><hr><p>​        但是由于String类和包装类都被设定成不可变的&lt;这里应该可以理解为什么说String是不可变的，StringBuilder是可变的&gt;，没有提供value对应的setter方法，而且很多都是final的，我们无法改变其内容，所以导致我们看起来好像是值传递（即没有影响原来的值）。</p><p>​        理由很简单，Integer 类中value字段是final的，说明一旦integer类创建之后他的值就不能被修改，在 index++ 的时候Integer是创建一个新的类，所以这个第二次输出的时候结果是一样的！所以对于包装类和String来说，他们是不可变类，进入一个方法后，在里面的值的改变不会影响方法外的引用</p><h2 id="类方法和实例方法："><a href="#类方法和实例方法：" class="headerlink" title="类方法和实例方法："></a>类方法和实例方法：</h2><p><strong>类方法</strong></p><p>用static修饰的方法。</p><p>由于类方法是属于整个类的，所以类方法的方法体中不能有与类的对象有关的内容。</p><p>即类方法体有如下限制：</p><p>1.类方法中不能引用对象变量；</p><p>2.类方法中不能调用类的对象方法；</p><p>3.在类方法中不能调使用super，this关键字；</p><p>4.类方法不能被覆盖。</p><p><strong>实例方法</strong></p><p>当一个类创建了一个对象后，这个对象就可以调用该类的方法（对象方法）。</p><p>1.实例方法中可以引用对象变量，也可以引用类变量；</p><p>2.实例方法中可以调用类方法；</p><p>3.对象方法中可以使用super，this关键字。</p><p><strong>区别和注意事项</strong></p><p>区别：类方法可以通过类名调用，实例方法不能通过类名调用</p><p>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址</p><p>当该类创建对象后，类中的实例方·法才分配入口地址，</p><p>从而实例方法可以被类创建的任何对象调用执行。</p><p>类方法在该类被加载到内存时，就分配了相应的入口地址。</p><p>从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。</p><p>类方法的入口地址直到程序退出时才被取消。</p><p>注意：</p><p>当我们创建第一个对象时，类中的实例方法就分配了入口地址（也就是实例方法的引用，在堆区。真正的方法体在方法区），当再创建对象时，不再分配入口地址。</p><p>也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。</p><p>在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址</p><p>如果一个类中所有的方法都是静态的，需要将该类的构造方法私有化。目的是防止在其他类中创建该类的实例对象，通过实例对象来调用这些静态方法，浪费空间。</p><p>只要是方法，不管是静态方法（类级别的）、实例方法（实例、对象级别）、构造方法（用来完成对象的创建和实例边变量的赋值）、main方法，运行的时候都需要压栈</p><h2 id="静态变量和实例变量："><a href="#静态变量和实例变量：" class="headerlink" title="静态变量和实例变量："></a>静态变量和实例变量：</h2><p>静态变量一般都会赋值，不赋值类加载会初始化，静态变量只能是成员变量（也就是说只能定义在方法体外，类体中）</p><p>静态变量方法区中（类相关的，使用类名.的方式访问）、实例变量堆中（对象级别的，必须先new对象，通过引用.的方式访问）、局部变量栈中  。</p><p> 只有类才存在静态的变量 方法只能对静态变量的操作 不能在方法内试图定义静态变量。</p><p>实例变量必须用引用来访问</p><p>静态变量，建议使用类名访问，但是也可以使用引用点的方式访问</p><p>类方法可以通过类名调用，实例方法不能通过类名调用</p><p>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址</p><p>当该类创建对象后，类中的实例方·法才分配入口地址，</p><p>从而实例方法可以被类创建的任何对象调用执行。</p><p>类方法在该类被加载到内存时，就分配了相应的入口地址。</p><p>从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。</p><p>类方法的入口地址直到程序退出时才被取消。</p><h2 id="静态代码块和动态代码块："><a href="#静态代码块和动态代码块：" class="headerlink" title="静态代码块和动态代码块："></a>静态代码块和动态代码块：</h2><p>静态变量和静态代码块都是类加载的时候执行，只能根据代码的先后来判断</p><p>&lt;img src=”java/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97.png” alt=”计算机生成了可选文字: 总结： 到目前为止，你遇到的所有java程序，有顺序要隶的是哪些？ 第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行” 第二：静态代码块1和静态代码块2是有先后顺序的” 第三．静态代码块和静态变虽是有先后顺序的“” style=”zoom:200%;” /&gt;</p><h2 id="this关键字和super关键字："><a href="#this关键字和super关键字：" class="headerlink" title="this关键字和super关键字："></a>this关键字和super关键字：</h2><p>1.1、this是一个关键字，是一个引用，保存内存地址指向自身。</p><p>1.2、this可以使用在实例方法中，也可以使用在构造方法中。</p><p>1.3、this出现在实例方法中其实代表的是当前对象。</p><p>1.4、this不能使用在静态方法中。</p><p>1.5、this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。</p><p>1.6、this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/this.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="计算机生成了可选文字: this： 1、this是一个关键字，全部小写。 2、this是什么，在内存方面是怎样的？ 一个对象一个thi“ this是一个变量，是一个引用·this保存当前对象的内存地址，指向自身。 所以，严格意义上来说，th“代表的就是" alt="当前对象“ th“存储在堆内存当中对象的内部· 3、th“只能使用在实例方法中·谁调用这个实例方法，th“就是谁· 所以this代表的是：当前对象· 4、"><p>super关键字（构造方法默认是有super（））。super代表当前对象的父类型特征</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/super.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="计算机生成了可选文字: 1、super是一个关键字．全部小写“ 2～super和this对比着学习· this： this能出现在实例方法和构造方法中。 this的语法是：" alt="this． ”this0“ th这不能使用在静态方法中． th“．大部分情况下是可以省略的“ th．什么时候不能省略呢？在区分局部变量和实例变量的时候不能省略。 publicvoidset-Name(Stringname》{ this·name this()只能出现在构造方法第一行，通过当前的构造方法去调用"><h2 id="final关键字："><a href="#final关键字：" class="headerlink" title="final关键字："></a>final关键字：</h2><p>final：关键字，表示的是最后的、不能变的、不能改的</p><p>可以修饰变量、方法、类</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/final.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="计算机生成了可选文字: final “nal是java语言中的一个关键字． final表示最终的，不可变的。 2、 3、“nal可以修饰变量以及方法，还有类等。 final修饰的变量？ final修饰的方法？ final修饰的类？ 6、"><p>final修饰的类无法被继承</p><p>final修饰的方法无法被覆盖，被重新 </p><p>final修饰的局部变量（包括引用），一旦赋值不能重新赋值。（只能赋一次值）</p><p>final修饰的引用只能指向1个对象，并且只能永远指向该对象，无法在指向其他的对象。并且在该方法执行过程中，该引用指向对象后，该对象不会被垃圾回收期回收。但是所指向的对象内部数据可以改变</p><p>final修饰的实例变量，系统不会赋默认值，必须手动赋值，但是赶在系统赋默认值之前就行。</p><p>直接在变量后边赋值或者在构造方法中赋值</p><p>（实例变量没有赋默认值的时候，系统会赋默认值，构造方法执行的过程中赋值，new的时候）</p><p>常量：final修饰的实例变量都加上一个static</p><p>方法重载和方法覆盖有什么区别？</p><p>方法重载发生在同一个类当中。</p><p>方法覆盖是发生在具有继承关系的父子类之间。</p><p>方法重载是一个类中，方法名相同，参数列表不同。</p><p>方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：</p><p>方法名一致、参数列表一致、返回值类型一致。</p><h2 id="Object类中的相关方法：toString（）方法、equals（）方法"><a href="#Object类中的相关方法：toString（）方法、equals（）方法" class="headerlink" title="Object类中的相关方法：toString（）方法、equals（）方法"></a>Object类中的相关方法：toString（）方法、equals（）方法</h2><p>toString()方法存在的作用就是：将java对象转换成字符串形式。</p><p>大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()</p><p>方法输出的是一个java对象的内存地址。</p><p>至于toString()方法具体怎么进行覆盖？</p><p>格式可以自己定义，或者听需求的。（听项目要求的。）</p><img "" class="lazyload placeholder" data-original="/2021/07/27/java/toString.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="计算机生成了可选文字: 关于Object类中的tostring0方法 1、t。string()方法的作用是什么？ 作用：将”艹对象" alt="转换成”字符串的形式 2、Obje。t类中t。string()方法的默认实现是什么？ publicStringtoString0{ returngetC1ass0.getName()+@+Integer．toHexString(hashCode0）， tostring：方法名的意思是转换成string 含义：调用一个艹a对象的st“ng()方法就可以将该j艹a对象转换成字符串的表示 3、那么t。st“ng()方法给的默认实现够用吗？ public01as5OverrideTest04{ publicstaticvoidmaid(String囗args){ &#x2F;／创建一个日期对象 MyDatet1-newMyDate0， &#x2F;&#x2F;调用tostring()方法（将对象转换成字符串形式。） &#x2F;&#x2F;向：你对这个输出结果满意吗？不满意，希望输出：xxxx年“月“曰 &#x2F;&#x2F;重写MyDa的t。singo方法之前结果 &#x2F;&#x2F;System.out．printlnt1toString0）；&#x2F;&#x2F;MyDate@28a418f0 &#x2F;&#x2F;重写Date的t。st“ng()方法之后的结果 System，out，printin()1，toString0》， &#x2F;&#x2F;大家是否还记得：当输出一个引用的时候， System．out.println(t1)； MyDatet2-new心Date（2008，8，8）， System．out．print-In〈t2）；&#x2F;／2008噁月8日 会自动用引用的"><p>public String toString(){</p><p>​        return year + “年” + month + “月” + day + “日”；</p><p>}</p><p>equals方法里边内容为空，会出现空指针异常</p><p>判断两个基本数据类型直接使用“==”</p><p>判断两个java对象是否相等，不能使用“==”，其实双等号比较的两个对象的内存地址</p><h2 id="抽象类和接口："><a href="#抽象类和接口：" class="headerlink" title="抽象类和接口："></a>抽象类和接口：</h2><p><img "" class="lazyload placeholder" data-original="java/%E6%8A%BD%E8%B1%A1%E7%B1%BB.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="计算机生成了可选文字: 类到对象是实例化。对象到类是抽象“ 抽象类： 、什么是抽象类？ 类和类之间具有共同特征，将这贱共同特征提取出来，形成的就是楠象类“ 类本身是不存在的，所以抽象类无法创建对象《无法实例化》“ 抽象类属于什么类型？ 2、 抽象类也属于引用数据类型“ 《能把基础语法先学会》 [修饰符列表]abstract。la艹类名{ 类休；I 、抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的“ 5、fin和abstr艹t不能联合使用，这两个关键字是对立的。 6、抽象类的子类可以是抽象类“ 7、抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的“"></p><p>接口的基础语法：接口也是一种引用数据类型</p><p>接口是完全抽象的，（抽象类是半抽象的）</p><p>定义：【修饰符列表】 interface 接口名{</p><p>}</p><p>【修饰符列表】class 类名{</p><p>}</p><p>【修饰符列表】abstract class 类名{</p><p>}</p><p><img "" class="lazyload placeholder" data-original="java/%E6%8E%A5%E5%8F%A3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="计算机生成了可选文字: 、接凵也是一种”引用数据类型“。编译之后也是一个cl艹s字节码文件。 2、接凵是完全抽象的·（抽象类是半抽象·）或者也可以说接凵是特殊的抽象类． 接口怎么定义，语法是什么？ 3、 [修饰符列表]interface接凵名0 接口支持多继承，一个接口可以继承多个接口“ 4、 5、接凵中只包含两部分内容，一部分是：常量·一都分是：抽象方法“接囗中没有其它 接口中所有的元素都是publi。修饰的“（都是公开的“） 6、 接凵中的抽象方法定义时：publicabstrac上修饰符可以省略。 7、 趴接口中的方法都是抽象方法，所以接囗中的方法不能有方法休“ 接口中的常量的publicst以。final可以省略。 9、"></p><p><img "" class="lazyload placeholder" data-original="java/%E6%8E%A5%E5%8F%A34.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="计算机生成了可选文字: 1.2、接口的基础谙法 1、接凵是一种”引用数据类型““ 接口是完全抽象的。 2、 3、接口怎么定义：[修饰符列表]interface接口名0 、接口支持多继承． 接口中只有常量+抽象方法“ 5、 6、接口中所有的元素都是publi。修饰的 接口中抽象方法的publi。abstract可以省略“ 7、 接凵中常量的publi。噁tat-igfinal可以省略 9、接口中方法不能有方法休· 10、一个非抽象的类，实现接囗的时候，必须将接口中所有方法加以实现“ 11、一个类可以实现多个接口“ extends和implementsüT以丿存，，imlements:在．后“ 12、 13、使用接口，写代码的时候，可以使用多态〈父类霜引用指向子类型对象）“"></p><p>抽象类和接口有什么区别？</p><p>在这里我们只说一下抽象类和接口在语法上的区别。</p><p>至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会/学习。</p><p>抽象类是半抽象的。</p><p>接口是完全抽象的。</p><p>抽象类中有构造方法。</p><p>接口中没有构造方法。（只有常量和抽象方法）</p><p>接口和接口之间支持多继承。</p><p>类和类之间只能单继承。</p><p>一个类可以同时实现多个接口。</p><p>一个抽象类只能继承一个类（单继承）。</p><p>接口中只允许出现常量和抽象方法。</p><p>这里先透露一个信息：</p><p>以后接口使用的比抽象类多。一般抽象类使用的还是少。</p><p>接口一般都是对“行为”的抽象。</p><p>接口的祖先也是object</p><h2 id="访问控制权限："><a href="#访问控制权限：" class="headerlink" title="访问控制权限："></a>访问控制权限：</h2><h2 id="内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰"><a href="#内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰" class="headerlink" title="内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰"></a>内部类：内部类在类的内部又定义了一个新的类，可以用public、private、protected修饰</h2><p>匿名内部类：是局部内部类的一种</p><h2 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h2><h1 id="常见错误积累"><a href="#常见错误积累" class="headerlink" title="常见错误积累"></a>常见错误积累</h1><h6 id="1-空指针异常"><a href="#1-空指针异常" class="headerlink" title="1.空指针异常"></a>1.空指针异常</h6><p>空指针异常只有在空应用访问实例相关的才会出现</p><p>但是用空引用或者引用访问静态相关的，实际运行的时候还是会变成类名.的访问方式。</p><p>静态变量还可以有set get方法，通过set，get方法访问</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_四大组件</title>
      <link href="2021/07/26/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
      <url>2021/07/26/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h1><p>​        组件启动后，首先需要依赖进程，那么就需要先创建进程，系统需要记录每个进程，这便产生了ProcessRecord。 Android中，对于进程的概念被弱化，通过抽象后的四大组件。让开发者几乎感受不到进程的存在。 当应用退出时，进程也并非马上退出，而是成为cache/empty进程，下次该应用再启动的时候，可以不用 再创建进程直接初始化组件即可，提高启动速度。</p><p>​        Android系统中用于描述进程的数据结构是ProcessRecord对象，AMS便是管理进程的核心模块。四大组件 （Activity,Service, BroadcastReceiver, ContentProvider）定义在AndroidManifest.xml文件， 每一项都可以用属性android:process指定所运行的进程。同一个app可以运行在同一个进程，也可以运行在多个进程， 甚至多个app可以共享同一个进程</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_service</title>
      <link href="2021/07/26/android-service/"/>
      <url>2021/07/26/android-service/</url>
      
        <content type="html"><![CDATA[<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-26</title>
      <link href="2021/07/26/7-26/"/>
      <url>2021/07/26/7-26/</url>
      
        <content type="html"><![CDATA[<h1 id="1713-得到子序列的最少操作次数"><a href="#1713-得到子序列的最少操作次数" class="headerlink" title="1713.得到子序列的最少操作次数"></a>1713.得到子序列的最少操作次数</h1><p>给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。</p><p>每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。</p><p>请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。</p><p>一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。</p><p>示例 1：</p><p>输入：target = [5,1,3], arr = [9,4,2,3,4]<br>输出：2<br>解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。<br>示例 2：</p><p>输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]<br>输出：3</p><p>思路：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_binder</title>
      <link href="2021/07/25/android-binder/"/>
      <url>2021/07/25/android-binder/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_系统架构</title>
      <link href="2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
      <url>2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>​        Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/android-stack.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="android-stack"><p>​        Google提供的经典分层架构图，从下往上依次分为linux内核层、HAL、系统Native库和android运行时环境、java Framework、应用层。</p><p>​        从进程角度诠释android系统的全貌。</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/android-boot.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="android-boot"><p><strong>Loader层：</strong></p><ul><li>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片代码开始从固化在<code>ROM</code>里的预设代码开始执行，然后加载引导程序（BootLoader）到<code>RAM</code>；</li><li>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能，将操作系统OS拉起来并运行</li></ul><p><strong>Linux内核层：</strong>linux内核的安全机制为android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。</p><ul><li>swapper进程（pid=0）：又被称为idle进程，是系统初始化过程Kernel有无到有开创的第一个进程，用于初始化进程管理、内存管理、加载Display、Camera Driver、Binder Driver等工作。</li><li>kthreadd进程（pid=2）：是linux系统的内核进程，会创建内核工作线程kworkder、软中断线程ksoftirqd、thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。</li></ul><p><strong>硬件抽象层（HAL）：</strong></p><p>​        硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。</p><p><strong>Android Runtime 和 系统库：</strong></p><p>​        每个应用都在自己的进程中运行，都有自己的虚拟机实例。ART通过DEX文件可在设备运行多个虚拟机。DEX文件是一种专门为android设计的字节码格式文件。ART主要功能包括：预先（AOT）和即时编译（JIT），优化的垃圾回收（GC），以及相关调试的支持。</p><p>​        Native系统库主要包括init孵化来的用户空间的守护进程、HAL层、开机动画等。init进程是所有用户进程的鼻祖。</p><ul><li>init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</li><li>init进程还启动<code>servicemanager</code>(binder服务管家)、<code>bootanim</code>(开机动画)等重要服务</li><li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，<code>Zygote是所有Java进程的父进程</code>，Zygote进程本身是由init进程孵化而来的。</li></ul><p><strong>Framework层：</strong></p><p>​        （1）Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：</p><p>​        加载ZygoteInit类，注册Zygote Socket服务端套接字<br>​        加载虚拟机<br>​        提前加载类preloadClasses<br>​        提前加载资源preloadResouces</p><p>​        （2）System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。<br>​        （3）Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</p><p><strong>APP层：</strong></p><p>​        Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；</p><p>​        Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。<br>​        所有的App进程都是由Zygote进程fork生成的。</p><p><strong>Native与Kernel之间有一层系统调用SysCall层。</strong></p><p><strong>java层与Native层之间的纽带JNI。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_系统启动</title>
      <link href="2021/07/25/android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
      <url>2021/07/25/android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h1><p>​        Android系统底层基于Linux Kernel, 当Kernel启动过程会创建init进程, 该进程是所有用户空间的鼻祖, init进程会启动servicemanager(binder服务管家), Zygote进程(Java进程的鼻祖). Zygote进程会创建 system_server进程以及各种app进程，</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/android-booting.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="android-booting"><p><strong>swapper进程（pid=0）</strong>：又被称为idle进程，是系统初始化过程Kernel有无到有开创的第一个进程，用于初始化进程管理、内存管理、加载Display、Camera Driver、Binder Driver等工作。</p><p><strong>kthreadd进程（pid=2）</strong>：是linux系统的内核进程，会创建内核工作线程kworkder、软中断线程ksoftirqd、thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。</p><p>内核完成系统设置时，首先在系统文件中启动属性服务，并且启动Zygote进程。</p><p><strong>init进程：</strong></p><p>​        是什么？：init是linux系统中用户空间的第一个进程（pid=0）。</p><p>​        来源：kerner启动后会调用system/core/init/init.cpp文件中的main（）方法来启动init进程。由多个源文件组成，对应的源码目录在system/core/init中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    // 如果是初始化第一阶段，则需要执行下面的步骤1</span><br><span class="line">    if (is_first_stage) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 清理umask</span><br><span class="line">        umask(0);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 1、创建和挂载启动所需的文件目录</span><br><span class="line">        mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);</span><br><span class="line">        mkdir(&quot;/dev/pts&quot;, 0755);</span><br><span class="line">        mkdir(&quot;/dev/socket&quot;, 0755);</span><br><span class="line">        mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);</span><br><span class="line">        #define MAKE_STR(x) __STRING(x)</span><br><span class="line">        mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC));</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 初识化Kernel的Log，获取外界的Kernel日志</span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初识化Kernel的Log，获取外界的Kernel日志</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 2、初始化属性相关资源</span><br><span class="line">    property_init();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 创建epoll句柄</span><br><span class="line">    epoll_fd = epoll_createl(EPOLL_CLOEXEC);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 3、设置子信号处理函数</span><br><span class="line">    sigchld_handler_init();</span><br><span class="line"></span><br><span class="line">    // 导入默认的环境变量</span><br><span class="line">    property_load_boot_defaults();</span><br><span class="line"></span><br><span class="line">    // 4、启动属性服务</span><br><span class="line">    start_property_service();</span><br><span class="line">    set_usb_controller();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 加载引导脚本</span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line"></span><br><span class="line">    ...   </span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        if (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class="line">            // 内部会偏离执行每个action中携带的command对应的执行函数</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class="line">            if (!shutting_down) &#123;</span><br><span class="line">                // 重启死去的子进程</span><br><span class="line">                auto next_process_restart_time = RestartProcesses();</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If there&#x27;s more work to do, wake up again immediately.</span><br><span class="line">            if (am.HasMoreCommands()) epoll_timeout_ms = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        epoll_event ev;</span><br><span class="line">        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, epoll_timeout_ms));</span><br><span class="line">        if (nr == -1) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; &quot;epoll_wait failed&quot;;</span><br><span class="line">        &#125; else if (nr == 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void LoadBootScripts(ActionManager&amp;action_manager, ServiceList&amp; service_list) &#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    std::string bootscript = GetProperty(&quot;ro.boot.init_rc&quot;, &quot;&quot;);</span><br><span class="line">    // bootscript默认是空的</span><br><span class="line">    if (bootscript.empty()) &#123;</span><br><span class="line">        // 5、解析init.rc配置文件</span><br><span class="line">        parser.ParseConfig(&quot;/init.rc&quot;);</span><br><span class="line">        if (!parser.ParseConfig(&quot;/system/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/system/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/product/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/product/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/odm/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/odm/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!parser.ParseConfig(&quot;/vendor/etc/init&quot;)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(&quot;/vendor/etc/init&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        功能：主要是初始化和启动属性服务，并且启动Zygote进程。</p><ul><li>分析和运行所有init.rc文件</li></ul><p>这是Android初始化语言编写的一个非常重要的配置脚本文件。Android初始化语言主要包含5种类型的语句：Action（常用）、Service（常用）、Command、Option、Import</p><ul><li><p>生成设备驱动节点（通过rc文件创建）</p></li><li><p>创建和挂载启动所需的文件目录：挂载了tmpsf、devpts、proc、sysfs和selinuxfs共5种文件系统（它们均是系统运行时目录</p></li><li><p>处理子进程的终止（signal方式）</p></li></ul><p>设置子进程信号的处理函数，如果子进程（Zygote）异常退出，init进程会调用该函数中设定的信号处理函数—sigchld_handler_init()【防止子进程成为僵尸进程】。如果Zygote进程终止，sigchld_handler_init()会重启Zygote进程。</p><ul><li>对属性服务进行初始化（property service）：</li></ul><p>​        属性服务：Windows平台上有一个注册表管理器，注册表的内容采用键值对的形式来记录用户、软件等使用信息。如果系统或软件重启，还是能够根据这份注册表中的记录，进行相应的初识化工作。Android也提供了一个这样类型的机制，即属性服务。</p><p>​        init进程启动时会启动属性服务，并为其分配内存，用来存储这些属性，如果需要就可以直接读取，具体在代码里就是执行了property_init()函数中的__system_property_area_init()函数去初始化属性内存区域。</p><ul><li>启动属性服务：（启动servicemanager【binder服务管家】、bootanim【开机动画服务】）。</li></ul><p>system/core/init/property_service.cpp源码中的start_property_service()函数来启动服务。</p><p><strong>总结：1、创建和挂载启动所需的文件目录。2、初始化和启动属性服务。3、解析init.rc配置文件并启动Zygote进程</strong></p><p>​        <strong>补充：servicemanager进程</strong>：ServiceManager是Binder IPC通信过程中的守护进程，本身也是一个Binder服务，但并没有采用libbinder中的多线程模型来与Binder驱动通信，而是自行编写了binder.c直接和Binder驱动来通信，并且只有一个循环binder_loop来进行读取和处理事务，这样的好处是简单而高效。</p><p>​        ServiceManager本身工作相对简单，其功能：查询和注册服务。 对于Binder IPC通信过程中，其实更多的情形是BpBinder和BBinder之间的通信，比如ActivityManagerProxy和ActivityManagerService之间的通信等。</p><p>​        ServiceManger集中管理系统内的所有服务，通过权限控制进程是否有权注册服务,通过字符串名称来查找对应的Service; 由于ServiceManger进程建立跟所有向其注册服务的死亡通知, 那么当服务所在进程死亡后, 会只需告知ServiceManager. 每个Client通过查询ServiceManager可获取Server进程的情况，降低所有Client进程直接检测会导致负载过重。</p><p><strong>Zygote进程：</strong>由init进程启动。（进入java世界）</p><p>​        Zygote进程创建Java虚拟机,并注册JNI方法， 真正成为Java进程的母体，用于孵化Java进程. 在创建完system_server进程后,zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</p><p>​        Zygote是在init进程启动时创建的，它又称为孵化器，它可以通过fork（复制进程）的形式来创建应用程序进程和SystemServer进程。并且，Zygote进程在启动的时候回创建DVM或者ART，因此通过fork而创建的应用程序进程和SystemServer进程可以在内部获取一个DVM或者ART的实例副本。</p><p>​        Zygote进程的主要职责：</p><ul><li>1、创建AppRuntime，执行其start方法，启动Zygote进程。。</li><li>2、创建JVM并为JVM注册JNI方法。</li><li>3、使用JNI调用ZygoteInit的main函数进入Zygote的Java FrameWork层。</li><li>4、使用registerZygoteSocket方法创建服务器端Socket，并通过runSelectLoop方法等等AMS的请求去创建新的应用进程。</li><li>5、启动SystemServer进程。</li></ul><p><strong>System_server进程：</strong>Zygote通过fork后创建system_server进程。承载着framework的核心服务。</p><p>​        system_server进程中创建了SystemServerManager,作用是对系统服务进行创建、启动和声明周期管理。</p><p>​        通过startBootstarpServices()方法中使用SystemServiceManager启动了ActivityManagerService、PackageManagerService、PowerManagerService等引导服务。</p><p>​        通过startCoreServices()方法中则启动了BatteryService、WebViewUpdateService、DropBoxManagerService、UsageStatsService4个核心服务</p><p>​        通过startOtherServices()方法中启动了WindowManagerService、InputManagerService、CameraService等其它服务。这些服务的父类都是SystemService。</p><p>​        系统服务分为三类：引导服务、核心服务、其他服务。</p><p>​                引导服务：ActivityManagerService，负责四大组件的启动、切换、调度。</p><p>​                引导服务：PackageManagerService，负责对APK进行安装、解析、删除、卸载等操作。<br>​                引导服务：PowerManagerService，负责计算系统中与Power相关的计算，然后决定系统该如何反应。<br>​                核心服务：BatteryService，管理电池相关的服务。<br>​                其它服务：WindowManagerService，窗口管理服务。<br>​                其它服务：InputManagerService，管理输入事件。</p><p>SystemService进程被创建后，主要的处理如下：</p><ul><li>1、启动Binder线程池，这样就可以与其他进程进行Binder跨进程通信。</li><li>2、创建SystemServiceManager，它用来对系统服务进行创建、启动和生命周期管理。</li><li>3、启动各种系统服务：引导服务、核心服务、其他服务，共100多种。应用开发主要关注引导服务ActivityManagerService、PackageManagerService和其他服务WindowManagerService、InputManagerService即可。</li></ul><p><strong>Launcher进程：</strong>Android系统启动的最后一步就是启动了一个Launcher应用程序来显示系统中已经安装的应用程序。<strong>Launcher在启动的过程中会请求请求PMS返回系统中已安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，从而使得用户可以点击这些快捷图片来启动相应的应用程序。</strong></p><p>​        1.作为android系统的启动器，用于启动应用程序。</p><p>​        2.作为android系统的桌面，用于显示和管理应用程序的快捷图标或其他桌面组件。</p><p>​        <strong>Launcher启动：</strong>SystemServer进程在启动的过程中会启动PMS，PMS启动后会将系统中的应用程序安装完成，先前已经启动的AMS会将Launcher启动起来。在SystemServer的startOtherServices()方法中，调用了AMS的systemReady()方法，此即为Launcher的入口。</p><p>​        **Launcher应用图标的显示过程:**应用程序图标是进入应用程序的入口。Launcher是用工作区的形式来显示系统安装的应用程序快捷图标的，每一个工作区都是用来描述一个抽象桌面的，它由n个屏幕组成，每个屏幕又分为n个单元格，每个单元格用来显示一个应用程序的快捷图标。</p><p><strong>APP进程：</strong>普通的app进程跟system_server进程的启动有些类似，不同的是app进程是发消息给system_server进程，由system_server向zygote进程发出创建进程的请求。</p><p><strong>总结：</strong></p><p>1、启动电源以及系统启动：当电源按下时引导芯片从预定义的订房（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。<br>2、引导程序BootLoader：BootLoader是在Android系统开始运行前的一个小程序，主要用于把系统OS拉起来并运行。。<br>3、Linux内核启动：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当其完成系统设置时，会先在系统文件中寻找init.rc文件，并启动init进行。<br>4、init进程启动：初始化和启动属性服务，并且启动Zygote进程。<br>5、Zygote进程启动：创建JVM并为其注册JNI方法，创建服务器端Socket，启动SystemServer进程。<br>6、SystemServer进程启动：启动Binder线程池和SystemServiceManager，并且启动各种系统服务。<br>7、Launcher启动：被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到系统桌面上。</p><p><strong>Android系统启动流程</strong></p><p>​    Android系统的启动流程，从按power按键启动电源开始，到Launcher应用程序启动完成结束，这里大致可以分为如下7个步骤。</p><p> 1、开启电源执行BootLoader引导程序</p><p>​    当按下电源后，会引导芯片代码从预定义的地方开始执行（该预定义的地方固化在ROM中），将引导程序BootLoader加载到RAM中执行。ROM和RAM是内存的中的两个部分，前者是Read-Only-Memmory的缩写，顾名思义，就是只读的内存，这其中会预先存储一些信息，比如这里系统启动时需要的信息。后者是Random-Acess-Memmory的缩写，写入的内存，在程序运行过程中可以动态写入数据，系统关闭后，数据会被清除。</p><p> 2、BootLoader拉起并执行操作系统</p><p>​    BootLoader执行时，会拉起并运行操作系统。BootLoader是一个引导程序，是在Android操作系统开始运行前的一个小程序，它的作用就是拉起并运行操作系统。</p><p> 3、操作系统启动init进程</p><p>​    Android操作系统基于Linux内核实现，所以此时Linux内核开始启动，进行系统设置。当完成系统设置后，会首先在系统文件中寻找init.rc脚本文件，并启动init进程。</p><p> 4、init进程启动</p><p>​    init，通过名称可以判断它的作用是做一些初始化的工作。init进程是Android系统中用户空间的第一个进程，进程号为1，是Android系统启动中的一个关键进程，作为第一个进程，它被赋予了很多重要的职责，简单概括为：</p><p>   （1）创建和挂载启动系统所需要的文件目录。</p><p>   （2）初始化和启动属性服务。这里的属性服务，类似于Windows操作系统中的注册表管理器，用来记录用户、软件等的一些信息。</p><p>   （3）解析init.rc配置文件，并启动Zygote进程。</p><p> 5、Zygote进程启动</p><p>​    Zygote的中文翻译为“受精卵”，是生命的开始，从字面意思，我们大致可以领会到它在Android系统中的地位。Dalvik/ART，应用程序进程以及运行系统的关键服务SystemServer都是由Zygote进程创建的，所以一般也称它为孵化器。Zygote需要做很多工作，归纳起来大致有如下几条：</p><p>   （1）创建Dalvik/ART</p><p>   （2）从Native层进入到Java框架层。也就是说Zygote开创了Java框架层，这一步是通过Native层通过JNI方式调用ZygoteInit类的main方法来实现。Zygote的路径为：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><p>   （3）ZygoteInit的main方法中会创建一个Service端的Socket，名称为“zygote”，用于等待AMS请求Zygote创建新的应用程序进程。</p><p>   （4）ZygoteInit的main方法中还会通过fork方式创建并启动SystemServer进程。</p><p> 6、SytemServer进程启动</p><p>​    SytemServer是运行系统的关键服务，主要用于创建系统服务，比如AMS，WMS，PMS等。它的主要职责为：</p><p>   （1）启动Binder线程池。该过程主要通过ZygoteInit.nativeZygoteInit()来调用Native层的方法来实现启动Binder线程池的，这样SystemServer就可以使用Binder与其他进程进行通信。</p><p>   （2）创建SystemServerManager（SSM），并启动各种服务。这个过程是在SystemServer的main方法中调用实现的，可以参考如下的源码。SystemServerManager用于对系统的服务进行创建、启动和生命周期管理。这里启动的各种服务包括引导服务、核心服务、其他服务三类：引导服务包括AMS、PowerMS、PackageMS等；核心服务包括BatteryService等；其他服务包括WMS等，SystemUI也是在这里启动的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 1 //=========SystemServer.java=========</span><br><span class="line"> 2 public static void main(String[] args) &#123;</span><br><span class="line"> 3     new SystemServer().run();</span><br><span class="line"> 4 &#125;</span><br><span class="line"> 5 private void run() &#123;</span><br><span class="line"> 6     ......</span><br><span class="line"> 7     //创建消息Looper</span><br><span class="line"> 8     Looper.prepareMainLooper();</span><br><span class="line"> 9     // 加载动态库libandroid_servers.so，初始化native服务</span><br><span class="line">10     System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line">11     ......</span><br><span class="line">12     //初始化系统context</span><br><span class="line">13     createSystemContext();</span><br><span class="line">14     //创建SystemServiceManager</span><br><span class="line">15     mSystemServiceManager = new SystemServiceManager(mSystemContext);</span><br><span class="line">16     ......</span><br><span class="line">17     //启动引导服务，如AMS等</span><br><span class="line">18     startBootstrapServices();</span><br><span class="line">19     //启动核心服务</span><br><span class="line">20     startCoreServices();</span><br><span class="line">21     //启动其它服务，如WMS，SystemUI等</span><br><span class="line">22     startOtherServices();</span><br><span class="line">23     ....</span><br><span class="line">24 &#125;</span><br></pre></td></tr></table></figure><p>每一种服务类型包含哪些具体的服务，可以通过上述源码中第18、20、22行进入到对应的方法中查看。</p><p> 7、启动Launcher</p><p>​    系统启动的最后一步是启动一个应用程序来显示系统中已经安装的应用程序，这个应用程序就是Launcher。这一步由SystemServer创建的AMS来启动，前面第5点“Zygote进程启动”中讲过，创建一个Socket，来等待AMS请求Zygote创建新的应用程序。Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些图标来启动对应的应用程序。总结来说，就是两点：</p><p>   （1）作为Android系统的启动器，用于启动应用程序。</p><p>   （2）作为Android系统的桌面，用于显示和管理应用程序的快捷图标或者其它桌面组件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_activity</title>
      <link href="2021/07/25/android-activity/"/>
      <url>2021/07/25/android-activity/</url>
      
        <content type="html"><![CDATA[<h1 id="activity（应用）"><a href="#activity（应用）" class="headerlink" title="activity（应用）"></a>activity（应用）</h1><p>Activity：是一个应用程序组件（组件就是零件）、为应用程序提供了一个可视化界面（activity就是一个界面）、用户通过此页面与应用程序进行交互。activity是Context的子类，同时实现了window.callback和keyevent.callback，可以处理与窗体用户交互的事件。</p><p>启动activity要素：manifest.xml、MainActivity、layout</p><p>setContentView：为Activity添加所需要的设置的内容，传入指定的Layout所对应的id。activity和布局文件XML进行绑定</p><p>findViewById：获取控件的对象。</p><p>启动另一个Activity：findViewByid（），可以获得xml中的控件对象</p><p>​            设置监听器的四种方法。</p><p>​            显示：通过Intent启动另一个activity            </p><p>​            跳转到某一个网页：</p><p>​            隐式启动：配置action</p><h2 id="activity的生命周期："><a href="#activity的生命周期：" class="headerlink" title="activity的生命周期："></a>activity的生命周期：</h2><p>以下三种状态：长时间保持不变。</p><p>onResume（）：activity处在前台（任务栈的顶部），且用户可以交互。</p><p>onPause（）：Activity被在前台中处于半透明状态或者未覆盖全屏的其他Activity部分遮挡。 暂停的Activity不会接收用户输入，也无法执行任何代码。</p><p>onStop（）：Activity被完全隐藏，且对用户不可见；被视为后台Activity。 停止的Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码。</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-activity/activitylife.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="计算机生成了可选文字: 什么EActivity @直徭翻译为：" alt="活动而在android中申多的是 代表手机的屏已是android的四大组件之一，重 要的组成元，提供了与用户交互的可视化界面 （GUI)，大多的App都是由多个屏组成的 @andr0id*Ff#Task(W)F储Activity, 可以理解为A（tivity钱，即后透先出；当在一个 ActivityE动另一个ActivityBg,%二个Activity 压入第一个Activityfi#中．此时两个Activity 是放在同一个Task中的，当我们帻下回退第 二个从中出，第一个A（tivi呼回判钱顶，即显 示到当前屏皂 养廊c歹／万后出 生命周期图鰩忻 @当A（tivi呼首次帔创津时，会调用on（reate() 方法，吾当显示朋户调用onStart0，如里 要让A（tivity位于前台的话就需要调用 onResume()方*IttdjActivity4ü于饯顶 @当有另一个Activitßfiä前ActivityN.i* 个时候调用onPau“0方法，将前一个A（tivity 的据保存起来 @此时，如里你想让前一个A（tivity不会再显示 的话，调用onStop()方法停止该A（tivity；但是如 里你恁让他回到前台的重新获得焦点的话 可以调用onResume()方法 @on-Stop后，你可以调用onDestory()方法来 钅肖毁iA（tivi也是该众（tivity最后一次帔调 用了，可以iMÄfinish()关fiActivity 0当丙存资源不足的时候，就可能杀死处于 onPau0的A（tivity所在的进程，但是这种极 端的佶况很少会友生 由用户作返回该 Activity,iM*E*Eapp 透程帔杀死 内存低： 申高伉卉级的ap 需要内存 A（tivity的生命周期及回调方法 Activity开始 。nS0 Activityi$行中 用户了回灘 前一个Activi新获得焦点 另一个Activi转入该 Activi之前，获得焦点， 前一个Activi处可见 刖一个Activi呼已轻 不可见了 Activi呼完成了要元成的 工作或由系统消了 Activity*止 Activity再次回到前台 我们不能够去调用，我们 面的内容，什么候调用 只有丽曲0方该方 法用于关闭冥个 A确Y！"><p>一个页面启动另一个页面的生命周期：</p><p>​        第一步：A.一个activity被打开：onCreat—》onStart—-》onResume</p><p>​        第二步：从一个activity启动另一个activity：A onPause—》B onCreate—》B onStart—-》B onResume—-》A onStop（只要stop说明就不可见了）</p><p>​        也就是一开始A执行了onPause方法，然后B完全展现出来之后，A执行onStop。（这个B activity会完全遮盖住A activity）</p><p>​        当B不会完全遮盖A的时候，</p><p>​        <img "" class="lazyload placeholder" data-original="android-activity/clip_image001-16272835280171.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="clip_image001-16272835280171" style="zoom:200%;" /></p><p>​        这个时候，A还是可见的。所以A没有执行onStop方法。</p><p>​        然后B对画框消失：</p><p>​        <img "" class="lazyload placeholder" data-original="android-activity/clip_image001-16272836096582.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="计算机生成了可选文字: 3Pau；0 A0》飞师e 3OnStOD" style="zoom:200%;" /></p><h2 id="四种启动模式："><a href="#四种启动模式：" class="headerlink" title="四种启动模式："></a>四种启动模式：</h2><p>​        <img "" class="lazyload placeholder" data-original="android-activity/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="计算机生成了可选文字: standarc&t andard是默认的后动式，And℃id是便返回栈来管理活动的，下《每当后动一个新的活动，他就 系统不会在乎这个活动是否已经茌返回栈中存在每产 返回栈中入栈，葑处于栈顶的亻立舀对于便standard模式的活动 创亥活动的一的实例 stX嗵ard默，在不声行过内兄下，所0会凵心重叫抑扈。在aM3a 《认懦厩：下。孬当扈一个斯刊古，禎会伍屮入，再处于槿顶0．刈于叩snda閨」《活 鬲，衤不会在泫．±动岸百回中在．每欠0动都会釗亥±《一个新的． FirstActivity 启动新活动 D FirstActivity 启动新活动 0A山v叮 返回栈 singTopt*式 返回 返回 当活动的后动厦式指定为singTop，在宕动活动时如果发现返回栈的栈顶已经是该活动，则可以接便用它 的实例 当沽囟皂动僂式定为sig@T叩，在皂卉动时如顸回槿代顶已，处认可以自它，不会再 0建糟《动引．而0当0业、c肌岛于顶河，时的《眶t0彗，还巼0创新圈《。 不冉创建活动 检查栈顶判 是否需要 启动新活动 启动新活动 FirstActiVlty SecondActiV'ty FirstActivity 返回栈 返回 返回" style="zoom:200%;" /></p><h1 id="activity启动流程"><a href="#activity启动流程" class="headerlink" title="activity启动流程"></a>activity启动流程</h1><p>启动activity的场景：</p><p>（1）点击Launcher中的快捷图标，这种方式进入的是根Activity；</p><p> （2）从其它应用跳转到某个应用的activity，这种场景下启动的可以是根Activity，也可以是其它Activity，如：从某些应用拨打电话、开启相机、打开浏览器等；</p><p>  （3）同一个应用种从某个组件中启动Activity。</p><p>   而启动某个Activity的时候，也可能有两种情形：</p><p>  （1）目标Activity所在应用程序进程不存在，也就是此时该应用还没有启动的情形；</p><p>  （2）目标Activity所在应用程序进程存在，也就是该应用之前启动过。</p><p>大致流程：主要涉及到4个进程的交互：Launcher所在应用进程、ActivityManagerService（后文简称AMS）所在的SystemServe系统进程、Zygote系统进程、目标根Activity所在的应用程序进程</p><p>（1）Launcher进程请求AMS创建根Activity。我们知道，在系统启动过程中，会启动SystemServer进程， AMS、PackageManagerService（后文简称PMS）也是在这个环节中启动的，所以AMS是运行在SystemServer进程当中的。应用的根Activity会在AndroidManifest.xml文件中注册，PMS解析出这些信息，并在Launcher中对这些包名、Activity路径及名称等信息进行封装，当点击快捷图标时，Launcher会调用startActivity方法去启动该图标所对应的根Activity。然后在Luancher进程中通过层层调用，直到通过Binder方式实现IPC，流程就进入到AMS中，也就是SystemServer进程中。</p><p> （2）AMS请求创建根Activity所在的进程。AMS收到Launcher进程启动根Activity的请求后，会先判断根Activity所在的进程是否已经创建过了，如果没有创建过，则会向Zygote进程请求创建该进程，我们目前讨论的情形就是根Activity所在进程没有创建过的情况。我们知道，Zygote进程在启动的时候，会作为服务端创建一个名为“zygote”的Socket，用于监听AMS发起的创建新应用进程请求，所以此时流程进入到Zygote进程中。</p><p> （3）Zygote进程fork出目标进程。Zygote收到AMS的请求后，会以fork的方式创建这个新的应用进程，此过程中会实例化一个ActivityThread对象，也就是一般所说的主线程，运行其入口main方法。</p><p> （4）AMS调度应用进程创建和启动根Activity。根Activity所在的应用程序进程被创建后，AMS在SystemServer进程中也经过层层调用，最终又通过Binder方式实现IPC，将启动Activity的任务交给应用程序进程中的ApplicationThread本地代理，此后，流程进入到根Activity所在的应用程序进程中。这部分流程中，SystemServer中所做的工作主要是根Actifity创建和启动前的一些准备工作，比如判单当前用户权限，判断目标进程是否存在，判断activity是否已经创建，判断启动模式，判断是否注册等。</p><p> （5）在应用进程中完成根Activity的创建和启动。在这里将创建根Activity实例、Applicaiton实例，调用各个生命周期方法，并将DecorView（布局文件中的View会添加到DecorView中）添加到Window中显示出来。 </p><p>如下图所示：</p><img "" class="lazyload placeholder" data-original="/2021/07/25/android-activity/start_activity_process.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="start_activity_process"><ol><li>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</li><li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li><li>Zygote进程fork出新的子进程，即App进程；</li><li>App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li><li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；</li><li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li><li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</li></ol><h1 id="activity问题"><a href="#activity问题" class="headerlink" title="activity问题"></a>activity问题</h1><h2 id="两个activity之间传递数据："><a href="#两个activity之间传递数据：" class="headerlink" title="两个activity之间传递数据："></a>两个activity之间传递数据：</h2><p>1、intent、broadcast receiver、content provider</p><p>2、利用static静态数据</p><p>3、利用外部存储进行传输，例如file文件存储。SP和Sqlite数据库</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-25</title>
      <link href="2021/07/25/7-25/"/>
      <url>2021/07/25/7-25/</url>
      
        <content type="html"><![CDATA[<h1 id="1743-从相邻元素对还原数组"><a href="#1743-从相邻元素对还原数组" class="headerlink" title="1743.从相邻元素对还原数组"></a>1743.从相邻元素对还原数组</h1><p>存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。</p><p>给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。</p><p>题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。</p><p>返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。</p><p>示例 1：</p><p>输入：adjacentPairs = [[2,1],[3,4],[3,2]]<br>输出：[1,2,3,4]<br>解释：数组的所有相邻元素对都在 adjacentPairs 中。<br>特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。<br>示例 2：</p><p>输入：adjacentPairs = [[4,-2],[1,4],[-3,1]]<br>输出：[-2,4,1,-3]<br>解释：数组中可能存在负数。<br>另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。<br>示例 3：</p><p>输入：adjacentPairs = [[100000,-100000]]<br>输出：[100000,-100000]</p><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static int[] restoreArray(int[][] adjPairs)&#123;</span><br><span class="line">    int n = adjPairs.length + 1;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; listHashMap = new HashMap&lt;&gt;();</span><br><span class="line">    for (int[] array : adjPairs)&#123;</span><br><span class="line">        int a = array[0];</span><br><span class="line">        int b = array[1];</span><br><span class="line">        hashMap.put(a, hashMap.getOrDefault(a, 0) + 1);</span><br><span class="line">        hashMap.put(b, hashMap.getOrDefault(b, 0) + 1);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt;  listA = listHashMap.getOrDefault(a, new ArrayList&lt;&gt;());</span><br><span class="line">        listA.add(b);</span><br><span class="line">        listHashMap.put(a, listA);</span><br><span class="line">        List&lt;Integer&gt; listB = listHashMap.getOrDefault(b, new ArrayList&lt;&gt;());</span><br><span class="line">        listB.add(a);</span><br><span class="line">        listHashMap.put(b, listB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int start = -1;</span><br><span class="line">    for (int i : hashMap.keySet())&#123;</span><br><span class="line">        if (hashMap.get(i) == 1)&#123;</span><br><span class="line">            start = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int[] ans = new int[n];</span><br><span class="line">    ans[0] = start;</span><br><span class="line">    ans[1] = listHashMap.get(start).get(0);</span><br><span class="line">    for (int i = 2; i &lt; n; i++)&#123;</span><br><span class="line">        int x = ans[i - 1];</span><br><span class="line">        List&lt;Integer&gt; list = listHashMap.get(x);</span><br><span class="line">        for (int j : list)&#123;</span><br><span class="line">            if (j != ans[i - 2])&#123;</span><br><span class="line">                ans[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-24</title>
      <link href="2021/07/24/7-24/"/>
      <url>2021/07/24/7-24/</url>
      
        <content type="html"><![CDATA[<h1 id="1736-替换隐藏数字得到的最晚时间"><a href="#1736-替换隐藏数字得到的最晚时间" class="headerlink" title="1736.替换隐藏数字得到的最晚时间"></a>1736.替换隐藏数字得到的最晚时间</h1><p>给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。</p><p>有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。</p><p>替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。</p><p>示例 1：</p><p>输入：time = “2?:?0”<br>输出：”23:50”<br>解释：以数字 ‘2’ 开头的最晚一小时是 23 ，以 ‘0’ 结尾的最晚一分钟是 50 。<br>示例 2：</p><p>输入：time = “0?:3?”<br>输出：”09:39”<br>示例 3：</p><p>输入：time = “1?:22”<br>输出：”19:22”</p><p>思路：我的想法就是枚举情况，注意点就是情况分类比较多需要注意。</p><p>第一位：如果需要被替换，优先替换为 2，当然前提是第二位不能超过 4。否则会出现 24:xx、25:xx 等；<br>第二位：如果需要被替换，根据第一位是什么，决定替换为 9 还是 3；<br>第三位：固定为 :；<br>第四位：如果需要被替换，替换为 5；<br>第五位：如果需要被替换，替换为 9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public String maximumTime(String time) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(time.charAt(0) == &#x27;?&#x27; ? (time.charAt(1) == &#x27;?&#x27; || time.charAt(1) &lt; &#x27;4&#x27;) ? &#x27;2&#x27; : &#x27;1&#x27; : time.charAt(0));</span><br><span class="line">        sb.append(time.charAt(1) == &#x27;?&#x27; ? sb.charAt(0) == &#x27;2&#x27; ? &#x27;3&#x27; : &#x27;9&#x27; : time.charAt(1));</span><br><span class="line">        sb.append(&#x27;:&#x27;);</span><br><span class="line">        sb.append(time.charAt(3) == &#x27;?&#x27; ? &#x27;5&#x27; : time.charAt(3));</span><br><span class="line">        sb.append(time.charAt(4) == &#x27;?&#x27; ? &#x27;9&#x27; : time.charAt(4));</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static String maximumTime(String time)&#123;</span><br><span class="line">    char[] timeChar = time.toCharArray();</span><br><span class="line">    if (timeChar[0] == &#x27;?&#x27;)&#123;</span><br><span class="line">       if (timeChar[1] == &#x27;?&#x27;)&#123;</span><br><span class="line">           timeChar[0] = &#x27;2&#x27;;</span><br><span class="line">       &#125;else if (timeChar[1] - &#x27;0&#x27; &gt;= 4)&#123;</span><br><span class="line">           timeChar[0] = &#x27;1&#x27;;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           timeChar[0] = &#x27;2&#x27;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeChar[1] == &#x27;?&#x27;)&#123;</span><br><span class="line">        if (timeChar[0] == &#x27;1&#x27;)&#123;</span><br><span class="line">            timeChar[1] = &#x27;9&#x27;;</span><br><span class="line">        &#125;else if (timeChar[0] == &#x27;2&#x27;)&#123;</span><br><span class="line">            timeChar[1] = &#x27;3&#x27;;</span><br><span class="line">        &#125;else if (timeChar[0] == &#x27;0&#x27;)&#123;</span><br><span class="line">            timeChar[1] = &#x27;9&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeChar[3] == &#x27;?&#x27;)&#123;</span><br><span class="line">        timeChar[3] = &#x27;5&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeChar[4] == &#x27;?&#x27;)&#123;</span><br><span class="line">        timeChar[4] = &#x27;9&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(timeChar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记day02</title>
      <link href="2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day02/"/>
      <url>2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day02/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记02"><a href="#操作系统笔记02" class="headerlink" title="操作系统笔记02"></a>操作系统笔记02</h1><p>操作系统课程图：</p><p>操作系统知识体系图：</p><h2 id="程序的运行过程-从代码到机器运行"><a href="#程序的运行过程-从代码到机器运行" class="headerlink" title="程序的运行过程:从代码到机器运行"></a>程序的运行过程:从代码到机器运行</h2><h4 id="程序的编译过程：使用GCC相关工具链"><a href="#程序的编译过程：使用GCC相关工具链" class="headerlink" title="程序的编译过程：使用GCC相关工具链"></a>程序的编译过程：使用GCC相关工具链</h4><p>gcc的编译过程：</p><img "" class="lazyload placeholder" data-original="/2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day02/GCC_CompilationProcess.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="GCC_CompilationProcess"><p>依次执行了：预处理（preprocessing）—&gt;编译（compilation）—-&gt;汇编（Assemble）—-&gt;链接（linking）。</p><p><strong>预处理</strong>：以“#”号开头的预处理指令如包含#include,宏定义制定#define等。在源程序中这些指令都放在函数之外，而且一般放在源文件的前面。</p><p>使用预处理器把源文件test.c经过预处理生成test.i文件。</p><p>预处理的命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i。</span><br></pre></td></tr></table></figure><p>上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p><p><strong>编译</strong>：这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理文件（test.i）之后的程序转换成特定汇编（test.s）代码的过程。</p><p>编译的命令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure><p>上述命令中-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名。编译过程完成后，将生成程序的汇编代码test.s，这也是文本文件。</p><p><strong>汇编：</strong>汇编过程将上一步的汇编代码转换成机器码，这一步产生的文件叫做目标文件，是二进制格式。</p><p>编译的命令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure><p><strong>链接</strong></p><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><p>链接过程的命令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>生成可执行程序过程为成四个步骤：</p><p>1、由.c文件到.i文件，这个过程叫预处理。<br>2、由.i文件到.s文件，这个过程叫编译。<br>3、由.s文件到.o文件，这个过程叫汇编。<br>4、由.o文件到可执行文件，这个过程叫链接。</p><p>源文件生成可执行文件：gcc test.c -o test</p><h2 id="程序装载执行："><a href="#程序装载执行：" class="headerlink" title="程序装载执行："></a>程序装载执行：</h2><h4 id="图灵机："><a href="#图灵机：" class="headerlink" title="图灵机："></a>图灵机：</h4><h4 id="冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。"><a href="#冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。" class="headerlink" title="冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。"></a>冯诺依曼体系结构：电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。</h4><p>根据冯诺依曼体系结构构成的计算机，必须具有如下功能：</p><p>把程序和数据装入到计算机中；</p><p>必须具有长期记住程序、数据的中间结果及最终运算结果；</p><p>完成各种算术、逻辑运算和数据传送等数据加工处理；</p><p>根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；</p><p>能够按照要求将处理的数据结果显示给用户。</p><p>为了完成上述的功能，计算机必须具备五大基本组成部件：</p><p>装载数据和程序的输入设备；</p><p>记住程序和数据的存储器；</p><p>完成数据加工处理的运算器；</p><p>控制程序执行的控制器；</p><p>显示处理结果的输出设备。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统、 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-23</title>
      <link href="2021/07/23/7-23/"/>
      <url>2021/07/23/7-23/</url>
      
        <content type="html"><![CDATA[<h1 id="1893-检查是否区域内所有整数都被覆盖"><a href="#1893-检查是否区域内所有整数都被覆盖" class="headerlink" title="1893.检查是否区域内所有整数都被覆盖"></a>1893.检查是否区域内所有整数都被覆盖</h1><p>给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。</p><p>如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。</p><p>已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti &lt;= x &lt;= endi ，那么我们称整数x 被覆盖了。</p><p>示例 1：</p><p>输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5<br>输出：true<br>解释：2 到 5 的每个整数都被覆盖了：</p><ul><li>2 被第一个区间覆盖。</li><li>3 和 4 被第二个区间覆盖。</li><li>5 被第三个区间覆盖。<br>示例 2：</li></ul><p>输入：ranges = [[1,10],[10,20]], left = 21, right = 21<br>输出：false<br>解释：21 没有被任何一个区间覆盖。</p><p>下边是两种暴力解法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* public static boolean isCovered(int[][] ranges, int left, int right)&#123;</span><br><span class="line">     for (int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">         boolean yesOrNor = false;</span><br><span class="line">         for (int j = 0; j &lt; ranges.length; j++)&#123;</span><br><span class="line">               if (i &gt;= ranges[j][0] &amp;&amp; i &lt;= ranges[j][ranges[0].length - 1])&#123;</span><br><span class="line">                   yesOrNor = true;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         if (yesOrNor == false)&#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;*/</span><br><span class="line"> public static boolean isCovered(int[][] ranges, int left, int right)&#123;</span><br><span class="line">     boolean[] flag = new boolean[51];</span><br><span class="line">     for (int[] range : ranges)&#123;</span><br><span class="line">         for (int i = range[0]; i &lt; range[ranges[0].length]; i++)&#123;</span><br><span class="line">             flag[i] = true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     for (int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">         if (flag[i] == false)&#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="2021/07/22/%E8%B4%AA%E5%BF%83/"/>
      <url>2021/07/22/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode树</title>
      <link href="2021/07/22/leetcode%E6%A0%91/"/>
      <url>2021/07/22/leetcode%E6%A0%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试题</title>
      <link href="2021/07/22/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>2021/07/22/%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="某为"><a href="#某为" class="headerlink" title="某为"></a>某为</h1>]]></content>
      
      
      
        <tags>
            
            <tag> code the world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-22</title>
      <link href="2021/07/22/7-22/"/>
      <url>2021/07/22/7-22/</url>
      
        <content type="html"><![CDATA[<h1 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138.复制带随机指针的链表"></a>138.复制带随机指针的链表</h1><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><p>思路：先遍历原链表，遍历过程中创建的新节点和对应的老节点用map保留着对应关系。第二次遍历的时候把next和random关系给补上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static Node copyRandomList(Node head)&#123;</span><br><span class="line">      HashMap&lt;Node, Node&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">      Node temp = head;</span><br><span class="line">      while (temp != null)&#123;</span><br><span class="line">          Node newNode = new Node(temp.val);</span><br><span class="line">          hashMap.put(temp, newNode);</span><br><span class="line">          temp = temp.next;</span><br><span class="line">      &#125;</span><br><span class="line">      temp = head;</span><br><span class="line">      while (temp != null)&#123;</span><br><span class="line">          Node newNode = hashMap.get(temp);</span><br><span class="line">          if (temp.next != null)&#123;</span><br><span class="line">              newNode.next = hashMap.get(temp.next);</span><br><span class="line">          &#125;</span><br><span class="line">          if (temp.random != null)&#123;</span><br><span class="line">              newNode.random = hashMap.get(temp.random);</span><br><span class="line">          &#125;</span><br><span class="line">          temp = temp.next;</span><br><span class="line">      &#125;</span><br><span class="line">      return hashMap.get(head);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>宫水三叶大佬的原地算法：显然时间复杂度上无法优化，考虑如何降低空间（不使用「哈希表」）。</p><p>我们使用「哈希表」的目的为了实现原节点和新节点的映射关系，更进一步的是为了快速找到某个节点 random 在新链表的位置。</p><p>那么我们可以利用原链表的 next 做一个临时中转，从而实现映射。</p><p>具体的，我们可以按照如下流程进行：</p><p>对原链表的每个节点节点进行复制，并追加到原节点的后面；<br>完成 11 操作之后，链表的奇数位置代表了原链表节点，链表的偶数位置代表了新链表节点，且每个原节点的 next 指针执行了对应的新节点。这时候，我们需要构造新链表的 random 指针关系，可以利用 link[i + 1].random = link[i].random.next，ii 为奇数下标，含义为 新链表节点的 random 指针指向旧链表对应节点的 random 指针的下一个值；<br>对链表进行拆分操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Node copyRandomList(Node head) &#123;</span><br><span class="line">       if (head == null) return null;</span><br><span class="line">       Node dummy = new Node(-1);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       while (head != null) &#123;</span><br><span class="line">           Node node = new Node(head.val);</span><br><span class="line">           node.next = head.next;</span><br><span class="line">           head.next = node;</span><br><span class="line">           head = node.next;</span><br><span class="line">       &#125;</span><br><span class="line">       head = dummy.next;</span><br><span class="line">       while (head != null) &#123;</span><br><span class="line">           if (head.random != null) &#123;</span><br><span class="line">               head.next.random = head.random.next;</span><br><span class="line">           &#125;</span><br><span class="line">           head = head.next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       head = dummy.next;</span><br><span class="line">       Node ans = head.next;</span><br><span class="line">       while (head != null) &#123;</span><br><span class="line">           Node tmp = head.next;</span><br><span class="line">           if (head.next != null) head.next = head.next.next;</span><br><span class="line">           head = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS2~DDS</title>
      <link href="2021/07/21/ROS2-DDS/"/>
      <url>2021/07/21/ROS2-DDS/</url>
      
        <content type="html"><![CDATA[<h1 id="DDS"><a href="#DDS" class="headerlink" title="DDS"></a>DDS</h1><p>DDS（数据分发服务）：是由OMG发布的分布式通信规范，采用了订阅发布模型，以中间件的形式提供通信服务，并提供多种QoS策略，保障数据进行实时、高效、灵活的分发。</p><p>订阅发布：DDS是基于发布/订阅模式的以数据为中心的通信模型。发布订阅功能使应用程序（发布者）将消息按照特定的主题进行分发，应用程序（订阅者）也可以根据主题接收到所需要的信息。</p><img "" class="lazyload placeholder" data-original="/2021/07/21/ROS2-DDS/DDS.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" class=" lazyload placeholder" title="DDS"><h1 id="DCPS"><a href="#DCPS" class="headerlink" title="DCPS"></a>DCPS</h1><p>DCPS定义了应用程序的功能，以发布和订阅数据的值。</p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专题</title>
      <link href="2021/07/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
      <url>2021/07/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>这种解法是：在当前节点中存入值，在不确定后边还有没有节点情况就创建节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ListNode l3Head = null;</span><br><span class="line">ListNode l3 = null;</span><br><span class="line">l3Head = l3;</span><br><span class="line">int lingwai = 0;</span><br><span class="line">while (l1 != null || l2 != null)&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    if (l1 != null)&#123;</span><br><span class="line">        a = l1.val;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        a = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 != null)&#123;</span><br><span class="line">        b = l2.val;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        b = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int c = a + b + lingwai;</span><br><span class="line">    int temp = c;</span><br><span class="line">    c = temp % 10;</span><br><span class="line">    lingwai = temp / 10;</span><br><span class="line">    l3.val = c;</span><br><span class="line">    ListNode next = new ListNode();</span><br><span class="line">    l3.next = next;</span><br><span class="line">    l3 = l3.next;</span><br><span class="line">&#125;</span><br><span class="line">if (lingwai != 0)&#123;</span><br><span class="line">    l3.val = lingwai;</span><br><span class="line">&#125;</span><br><span class="line">return l3Head;</span><br></pre></td></tr></table></figure><p>咋办呢？就只能想方设法知道最后的位置。设置一个ListNode节点，当</p><p>if (l1 == null &amp;&amp; l2 == null){<br>           text = l3;<br>   }这个时候，保存住最后的位置。</p><p>在这也需要特殊判断。</p><p> if (lingwai != 0){<br>       l3.val = lingwai;<br>   }else {<br>       text.next = null;<br>   }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode addTwoNums(ListNode l1, ListNode l2)&#123;</span><br><span class="line">   ListNode l3Head = null;</span><br><span class="line">   ListNode l3 = null;</span><br><span class="line">   ListNode text = new ListNode();</span><br><span class="line">   l3Head = l3;</span><br><span class="line">   int lingwai = 0;</span><br><span class="line">   while (l1 != null || l2 != null)&#123;</span><br><span class="line">       int a, b;</span><br><span class="line">       if (l1 != null)&#123;</span><br><span class="line">           a = l1.val;</span><br><span class="line">           l1 = l1.next;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           a = 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (l2 != null)&#123;</span><br><span class="line">           b = l2.val;</span><br><span class="line">           l2 = l2.next;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           b = 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int c = a + b + lingwai;</span><br><span class="line">       int temp = c;</span><br><span class="line">       c = temp % 10;</span><br><span class="line">       lingwai = temp / 10;</span><br><span class="line">       l3.val = c;</span><br><span class="line">       ListNode next = new ListNode();</span><br><span class="line">       l3.next = next;</span><br><span class="line">       if (l1 == null &amp;&amp; l2 == null)&#123;</span><br><span class="line">           text = l3;</span><br><span class="line">       &#125;</span><br><span class="line">       l3 = l3.next;</span><br><span class="line">   &#125;</span><br><span class="line">   if (lingwai != 0)&#123;</span><br><span class="line">       l3.val = lingwai;</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">       text.next = null;</span><br><span class="line">   &#125;</span><br><span class="line">   return l3Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想别这么绞尽脑汁，需要的是。如果有值需要加入的时候才创建节点加入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ListNode head = new ListNode();</span><br><span class="line">ListNode current = head;</span><br><span class="line">int carry = 0;</span><br><span class="line">    while (l1 != null || l2 != null)&#123;</span><br><span class="line">    int val1 = l1 != null ? l1.val : 0;</span><br><span class="line">    int val2 = l2 != null ? l2.val : 0;</span><br><span class="line">    int sum = val1 +val2 + carry;</span><br><span class="line">    current.next = new ListNode(sum % 10);</span><br><span class="line">    current = current.next;</span><br><span class="line">    carry = sum / 10;</span><br><span class="line">    if (l1 != null)</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    if (l2 != null)</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line">    if (carry &gt; 0 )&#123;</span><br><span class="line">    current.next = new ListNode(carry);</span><br><span class="line">    current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">    return head.next;</span><br></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h1 id="链表某个题"><a href="#链表某个题" class="headerlink" title="链表某个题"></a>链表某个题</h1><p>意思：一个链表转换成：1–&gt;n–&gt;2–&gt;n-1–&gt;3…这个意思。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-21</title>
      <link href="2021/07/21/7-21/"/>
      <url>2021/07/21/7-21/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer52"><a href="#剑指offer52" class="headerlink" title="剑指offer52."></a>剑指offer52.</h1><p>输入两个链表找出他们的第一个公共节点</p><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p><p>大家注意一点，这里的公共节点是两个节点的内存地址一样，并不知道节点所存储的val相等就是公共节点。</p><p>解法一：栈解法，将两个链表分别压栈。对于两个栈的操作为，一起出栈然后判断出栈的元素是否equals。并且需要保存前一个出栈的元素。第一个弹栈元素不相等的前一个元素就是公共节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stackA = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;ListNode&gt; stackB = new Stack&lt;&gt;();</span><br><span class="line">    while (headA != null)&#123;</span><br><span class="line">        stackA.push(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (headB != null)&#123;</span><br><span class="line">        stackB.push(headB);</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode ans = null;</span><br><span class="line">    while (!stackA.isEmpty() &amp;&amp; !stackB.isEmpty())&#123;</span><br><span class="line">        ListNode a = stackA.pop();</span><br><span class="line">        ListNode b = stackB.pop();</span><br><span class="line">        if (a.equals(b))&#123;</span><br><span class="line">            ans = a;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：数学解法，两个链表的分别长度为lengthA和lengthB.将两个链表连接起来，也就是链表A后边连接上链表B，链表B后边连接上链表A。这样长度就相等了，可以从头开始按顺序遍历了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line"></span><br><span class="line">       if (headA == null || headB == null)&#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode A = headA;</span><br><span class="line">       ListNode B = headB;</span><br><span class="line">       while (A != B)&#123;</span><br><span class="line">           A = A != null ? A.next : headB;</span><br><span class="line">           B = B != null ? B.next : headA;</span><br><span class="line">       &#125;</span><br><span class="line">       return A;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>数学解法二：先对两条链表扫描一遍，取得两者长度，然后让长的链表先走「两者的长度差值」，然后再同时走，遇到第一个节点即是答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    int lengthA = 0, lengthB = 0;</span><br><span class="line">    ListNode a = headA, b = headB;</span><br><span class="line">    while (a != null)&#123;</span><br><span class="line">        a = a.next;</span><br><span class="line">        lengthA++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (b != null)&#123;</span><br><span class="line">        b = b.next;</span><br><span class="line">        lengthB++;</span><br><span class="line">    &#125;</span><br><span class="line">    int abs = Math.abs(lengthA - lengthB);</span><br><span class="line">    while (abs &gt; 0)&#123;</span><br><span class="line">        if (lengthA &gt; lengthB)&#123;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        abs--;</span><br><span class="line">    &#125;</span><br><span class="line">    while (headA != null &amp;&amp; headB != null)&#123;</span><br><span class="line">        if (headA.equals(headB))&#123;</span><br><span class="line">            return headA;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法三：哈希表。先将链表A放入哈希表中，然后遍历链表B，判断节点是否存在，不存在的话继续遍历。存在就返回此节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB)&#123;</span><br><span class="line">    HashMap&lt;ListNode, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">    while (headA != null)&#123;</span><br><span class="line">        hashMap.put(headA, hashMap.getOrDefault(headA, 0) + 1);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (headB != null)&#123;</span><br><span class="line">        if (hashMap.containsKey(headB))&#123;</span><br><span class="line">            return headB;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTP和HTTPS</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8AHTTP%E5%92%8CHTTPS/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8AHTTP%E5%92%8CHTTPS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTPS</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8AHTTPS/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8AHTTPS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTP/1.1</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8AHTTP-1-1/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8AHTTP-1-1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h1><h3 id="HTTP（全称超文本传输协议，英文全称HyperText-Transfer-Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。"><a href="#HTTP（全称超文本传输协议，英文全称HyperText-Transfer-Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。" class="headerlink" title="HTTP（全称超文本传输协议，英文全称HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。"></a>HTTP（全称超文本传输协议，英文全称HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。</p><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\http.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="http"></p><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p><p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p><h3 id="HTTP工作过程："><a href="#HTTP工作过程：" class="headerlink" title="HTTP工作过程："></a>HTTP工作过程：</h3><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\http请求响应模型.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="http请求模型"></p><ul><li>***1）***建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</li><li>***2）***客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：GET/sample/hello.jsp HTTP/1.1；</li><li>***3）***客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</li><li>***4）***服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： HTTP/1.1 200 OK<br>响应的第一部分是协议的版本号和响应状态码；</li><li>***5）***服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</li><li>***6）***服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</li><li>***7）***服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ul><h4 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h4><p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p><h4 id="HTTP协议是不保存状态的协议"><a href="#HTTP协议是不保存状态的协议" class="headerlink" title="HTTP协议是不保存状态的协议"></a>HTTP协议是不保存状态的协议</h4><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p><h4 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h4><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img "" class="lazyload placeholder" data-original="../images/cookie.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Cookie状态管理"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊网络</title>
      <link href="2021/07/20/%E7%9E%8E%E8%81%8A%E7%BD%91%E7%BB%9C/"/>
      <url>2021/07/20/%E7%9E%8E%E8%81%8A%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>以五层结构为例：</p><p><strong>1）应用层：</strong>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。”应用层”的作用，就是规定应用程序的数据格式。如http协议，它实际上是定义了如何包装和解析数据。</p><p><strong>2）运输层：</strong>我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。</p><p>运输层有TCP和UDP两种协议，分别对应可靠的运输和不可靠的运输，如TCP因为要提供可靠的传输，所以内部要解决如何建立连接、如何保证传输是可靠的不丢数据、如何调节流量控制和拥塞控制。关于这一层，我们平常一般都是和Socket打交道，Socket是一组封装的编程调用接口，通过它，我们就能操作TCP、UDP进行连接的建立等。我们平常使用Socket进行连接建立的时候，一般都要指定端口号,所以这一层指定了把数据送到对应的端口号。</p><p><strong>3）网络层：</strong>作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。——–IP协议</p><p>为什么需要网络层：以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是不合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>IP数据包：把IP数据包直接放进以太网数据包的数据部分</p><p><strong>4）数据链路层：</strong>在物理层的基础上，确定了0和1的分组方式。以太网协议规定，一组电信号构成一个数据包，叫做帧。每一帧分成两个部分：标头和数据。以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p><strong>定义地址只是第一步，后面还有更多的步骤：</strong></p><ul><li><strong>1）首先：</strong>一块网卡怎么会知道另一块网卡的MAC地址？<br>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</li><li><strong>2）其次：</strong>就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</li></ul><p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”数据链路层”就可以在多台计算机之间传送数据了。</p><p><strong>5）物理层：</strong>用光缆、电缆、双绞线、无线电波的方式将计算机组网，进行数据传输。主要规定了网络的电气特性，作用是负责传送0和1的电信号。</p><p>所以通过上面五层的各司其职，实现物理传输介质–MAC地址–IP地址–端口号–获取到数据根据应用层协议解析数据最终实现了网络通信和数据传输。</p><p><img "" class="lazyload placeholder" data-original="../images/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%8C%85.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="以太网数据包"></p><p>发送这个包需要知道两个地址：对方的MAC地址、对方的IP地址。</p><table><thead><tr><th><strong>场景</strong></th><th><strong>数据包地址</strong></th></tr></thead><tbody><tr><td>同一个子网络</td><td>对方的MAC地址，对方的IP地址</td></tr><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr></tbody></table><h1 id="用户角度从上往下（访问网页的例子）"><a href="#用户角度从上往下（访问网页的例子）" class="headerlink" title="用户角度从上往下（访问网页的例子）"></a>用户角度从上往下（访问网页的例子）</h1><h2 id="DHCP协议：应用层协议、建立在UDP协议之上。"><a href="#DHCP协议：应用层协议、建立在UDP协议之上。" class="headerlink" title="DHCP协议：应用层协议、建立在UDP协议之上。"></a>DHCP协议：应用层协议、建立在UDP协议之上。</h2><h2 id="DNS协议：域名转换成IP地址"><a href="#DNS协议：域名转换成IP地址" class="headerlink" title="DNS协议：域名转换成IP地址"></a>DNS协议：域名转换成IP地址</h2><h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><h2 id="TCP协议："><a href="#TCP协议：" class="headerlink" title="TCP协议："></a>TCP协议：</h2><h2 id="IP协议："><a href="#IP协议：" class="headerlink" title="IP协议："></a>IP协议：</h2><h2 id="以太网协议："><a href="#以太网协议：" class="headerlink" title="以太网协议："></a>以太网协议：</h2><h2 id="服务器端响应："><a href="#服务器端响应：" class="headerlink" title="服务器端响应："></a>服务器端响应：</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-20</title>
      <link href="2021/07/20/7-20/"/>
      <url>2021/07/20/7-20/</url>
      
        <content type="html"><![CDATA[<h1 id="1877：数组中最大数对和的最小值"><a href="#1877：数组中最大数对和的最小值" class="headerlink" title="1877：数组中最大数对和的最小值"></a>1877：数组中最大数对和的最小值</h1><p>一个数对 (a,b) 的 数对和 等于 a + b 。6最大数对和 是一个数对数组中最大的 数对和 。</p><p>比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。<br>给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得：</p><p>nums 中每个元素 恰好 在 一个 数对中，且<br>最大数对和 的值 最小 。<br>请你在最优数对划分的方案下，返回最小的 最大数对和 。</p><p>示例 1：</p><p>输入：nums = [3,5,2,3]<br>输出：7<br>解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。<br>最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。<br>示例 2：</p><p>输入：nums = [3,5,4,2,4,6]<br>输出：8<br>解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。<br>最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。</p><p>思路：第一反应就是最大和最小的配对。证明过程可以参考leetcode官方题解，反证法。<a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/solution/shu-zu-zhong-zui-da-shu-dui-he-de-zui-xi-cvll/">https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/solution/shu-zu-zhong-zui-da-shu-dui-he-de-zui-xi-cvll/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line">     int ans = Integer.MIN_VALUE;</span><br><span class="line">     int left = 0, right = nums.length - 1;</span><br><span class="line">     while (left &lt; right)&#123;</span><br><span class="line">         int now = nums[left] +nums[right];</span><br><span class="line">         ans = Math.max(ans, now);</span><br><span class="line">         left++;</span><br><span class="line">         right--;</span><br><span class="line">     &#125;</span><br><span class="line">     return ans;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试</title>
      <link href="2021/07/19/java%E9%9D%A2%E8%AF%95/"/>
      <url>2021/07/19/java%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="环境变量CLASSPATH的作用"><a href="#环境变量CLASSPATH的作用" class="headerlink" title="环境变量CLASSPATH的作用"></a>环境变量CLASSPATH的作用</h1><p>考点：classpath环境变量的作用、类的搜索和加载原理。</p><p>classpath环境变量是在编译java源码和运行程序时使用的，为java程序所依赖的接口、类等指定一个搜索路径。</p><p>java程序不仅在classpath中去搜索类，还会在jre/lib/rt.jar中找到jar文件。搜索顺序为先rt.jar，然后classpath指定的路径。</p><h1 id="变量及其作用范围"><a href="#变量及其作用范围" class="headerlink" title="变量及其作用范围"></a>变量及其作用范围</h1><p>​        在java中，变量根据生命周期（定义位置）的不同可以分为静态变量、成员变量和局部变量。</p><p>​        静态变量：类中使用static修饰的变量，生存周期由类决定，当类加载的时候，生成并初始化。</p><p>​        成员变量：在类中没有使用static修饰的变量，属于某个对象。随着对象的加载而生成并初始化，随着对象被垃圾回收器回收而消失。</p><p>​        局部变量：定义在方法中的变量或方法的参数，随着方法的调用（入栈）而创建，随着方法的执行结束（出栈）而消失。局部变量的定义可以和实例变量、静态变量的定义同名。</p><h1 id="哪两种数据类型"><a href="#哪两种数据类型" class="headerlink" title="哪两种数据类型"></a>哪两种数据类型</h1><p>基本数据类型和引用数据类型。区别在于引用数据类型存放的是数据所在的地址，基本数据类型则是直接存放数据的值。</p><h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><p>基本数据类型的变量转换成包装类：Interger.valueOf（）静态方法。</p><p>包装类转换成基本数据类型：调用包装类对象的intValue（）。</p><p>装箱和拆箱指的是基本数据类型和包装类型的自动相互转换，自动转换的过程在编译阶段。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="2021/07/19/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>2021/07/19/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>找关键字。比如题目中有连续，就应该条件反射想到滑动窗口和前缀和。比如题目求最大最小就想到动态规划和贪心等等。想到之后，就可以和题目信息对比快速排除错误的算法，找到可行解。这个思考的时间会随着你的题感增加而降低。</p><p>先写出暴力解，然后找暴力解的瓶颈， 根据瓶颈就很容易知道应该用什么数据结构和算法去优化。</p><h1 id="1480：一维数组的动态和"><a href="#1480：一维数组的动态和" class="headerlink" title="1480：一维数组的动态和"></a>1480：一维数组的动态和</h1><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p><p>请返回 nums 的动态和。</p><p>示例 1：</p><p>输入：nums = [1,2,3,4]<br>输出：[1,3,6,10]<br>解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。<br>示例 2：</p><p>输入：nums = [1,1,1,1,1]<br>输出：[1,2,3,4,5]<br>解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。<br>示例 3：</p><p>输入：nums = [3,1,2,10,1]<br>输出：[3,4,6,16,17]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int[] runningSum(int[] nums)&#123;</span><br><span class="line">    int[] numsSum = new int[nums.length];</span><br><span class="line">    if (nums.length &lt;= 0)&#123;</span><br><span class="line">        return numsSum;</span><br><span class="line">    &#125;</span><br><span class="line">    numsSum[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        numsSum[i] = numsSum[i - 1] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return numsSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="母题1"><a href="#母题1" class="headerlink" title="母题1"></a>母题1</h1><p>如果让你求一个数组的连续子数组总个数，你会如何求？其中连续指的是数组的索引连续。 比如 [1,3,4]，其连续子数组有：<code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，你需要返回 6。</p><p>一种思路是总的连续子数组个数等于：<strong>以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数</strong>，这无疑是完备的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int lianXuZiShuZu(int[] nums)&#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int pre = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            pre = pre + 1;</span><br><span class="line">            ans = ans + pre;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="母题2"><a href="#母题2" class="headerlink" title="母题2"></a>母题2</h1><p>求一个数组相邻差为 1 连续子数组的总个数呢？其实就是<strong>索引差 1 的同时，值也差 1。</strong>和上面思路类似，无非就是增加差值的判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int qianZhui(int[] nums)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int pre = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)&#123;</span><br><span class="line">        if (nums[i + 1] - nums[i] == 1)&#123;</span><br><span class="line">            pre = pre + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pre = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="母题3"><a href="#母题3" class="headerlink" title="母题3"></a>母题3</h1><p>求出不大于 k 的子数组的个数呢？不大于 k 指的是子数组的全部元素都不大于 k。 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，不大于 3 的子数组有 <code>[1], [3], [1,3]</code> ，那么 [1,3,4] 不大于 3 的子数组个数就是 3。 实现函数 atMostK(k, nums)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int atMostK(int[] nums, int k)&#123;</span><br><span class="line">    int ans = 0, pre = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if (nums[i] &lt;= k)&#123;</span><br><span class="line">            pre += 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pre = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += pre;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="母题4"><a href="#母题4" class="headerlink" title="母题4"></a>母题4</h1><p>求出子数组最大值刚好是 k 的子数组的个数呢？ 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，子数组最大值刚好是 3 的子数组有 <code>[3], [1,3]</code> ，那么 [1,3,4] 子数组最大值刚好是 3 的子数组个数就是 2。实现函数 exactK(k, nums)。</p><p>实际上是 exactK 可以直接利用 atMostK，即 atMostK(k) - atMostK(k - 1)，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public static int exactK(int[] nums, int k)&#123;</span><br><span class="line">        return atMostK(nums, k) - atMostK(nums, k -  1);</span><br><span class="line">    &#125;</span><br><span class="line">//</span><br><span class="line">    public static int atMostK(int[] nums, int k)&#123;</span><br><span class="line">        int ans = 0, pre = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (nums[i] &lt;= k)&#123;</span><br><span class="line">                pre += 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                pre = 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += pre;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="母题5"><a href="#母题5" class="headerlink" title="母题5"></a>母题5</h1><p>求出子数组最大值刚好是 介于 k1 和 k2 的子数组的个数呢？实现函数 betweenK(k1, k2, nums)。</p><p>实际上是 betweenK 可以直接利用 atMostK，即 atMostK(k1, nums) - atMostK(k2 - 1, nums)，其中 k1 &gt; k2。前提是值是离散的， 比如上面我出的题都是整数。 因此我可以直接 减 1，因为 <strong>1 是两个整数最小的间隔</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int betweenK(int k1, int k2, int[] nums)&#123;</span><br><span class="line">    return atMostK(nums, k1) - atMostK(nums, k2 - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int atMostK(int[] nums, int k)&#123;</span><br><span class="line">    int ans = 0, pre = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if (nums[i] &lt;= k)&#123;</span><br><span class="line">            pre += 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pre = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += pre;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724.寻找数组的中心下标"></a>724.寻找数组的中心下标</h1><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><p>示例 1：</p><p>输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>中心下标是 3 。<br>左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，<br>右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。<br>示例 2：</p><p>输入：nums = [1, 2, 3]<br>输出：-1<br>解释：<br>数组中不存在满足此条件的中心下标。</p><p>思路：前缀和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int pivotIndex(int[] nums)&#123;</span><br><span class="line">    int[] sum = new int[nums.length];</span><br><span class="line">    sum[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        sum[i] = sum[i - 1] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int leftRight = 0;</span><br><span class="line">    if (leftRight == sum[sum.length - 1] - sum[0])&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; sum.length - 1; i++)&#123;</span><br><span class="line">        if (sum[i - 1] == sum[sum.length - 1] - sum[i])&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum[sum.length - 2] == leftRight)&#123;</span><br><span class="line">        return sum.length - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="除自身以外数组的乘机"><a href="#除自身以外数组的乘机" class="headerlink" title="除自身以外数组的乘机"></a>除自身以外数组的乘机</h1><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><p>示例:</p><p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int length = nums.length;</span><br><span class="line">int[] left = new int[nums.length];</span><br><span class="line">int[] right = new int[nums.length];</span><br><span class="line">int[] outputs = new int[nums.length];</span><br><span class="line">left[0] = 1;</span><br><span class="line">right[length - 1] = 1;</span><br><span class="line">//当前索引为i的左侧乘机</span><br><span class="line">for (int i = 1; i &lt; length; i++)&#123;</span><br><span class="line">    left[i] = nums[i - 1] * left[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = length - 2; i &gt;= 0; i--)&#123;</span><br><span class="line">    right[i] = right[i + 1] * nums[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">    outputs[i] = left[i] * right[i];</span><br><span class="line">&#125;</span><br><span class="line">return outputs;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空间复杂度为o（1）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int[] productExceptSelf(int[] nums)&#123;</span><br><span class="line">    int length = nums.length;</span><br><span class="line">    int[] outputs = new int[nums.length];</span><br><span class="line">    outputs[0] = 1;</span><br><span class="line">    //当前索引为i的左侧乘机</span><br><span class="line">    for (int i = 1; i &lt; length; i++)&#123;</span><br><span class="line">        outputs[i] = nums[i - 1] * outputs[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int R = 1;</span><br><span class="line">    for (int i = length - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">        outputs[i] = outputs[i] * R;</span><br><span class="line">        R = R * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return outputs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="467-环绕字符串中唯一的字字符串"><a href="#467-环绕字符串中唯一的字字符串" class="headerlink" title="467.环绕字符串中唯一的字字符串"></a>467.环绕字符串中唯一的字字符串</h1><p>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”. </p><p>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 </p><p>注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。</p><p>示例 1:</p><p>输入: “a”<br>输出: 1<br>解释: 字符串 S 中只有一个”a”子字符。</p><p>示例 2:</p><p>输入: “cac”<br>输出: 2<br>解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.</p><p>示例 3:</p><p>输入: “zab”<br>输出: 6<br>解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter实战Day02</title>
      <link href="2021/07/19/Flutter%E5%AE%9E%E6%88%98Day02/"/>
      <url>2021/07/19/Flutter%E5%AE%9E%E6%88%98Day02/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章：基础组件"><a href="#第三章：基础组件" class="headerlink" title="第三章：基础组件"></a>第三章：基础组件</h1><h2 id="Widget："><a href="#Widget：" class="headerlink" title="Widget："></a>Widget：</h2><p>在Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 <code>GestureDetector</code> widget、用于APP主题数据传递的<code>Theme</code>等等，而原生开发中的控件通常只是指UI元素。</p><h3 id="Widget和Element"><a href="#Widget和Element" class="headerlink" title="Widget和Element"></a>Widget和Element</h3><p>在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而它只是描述显示元素的一个配置数据。</p><p>实际上，Flutter中真正代表屏幕上显示元素的类是<code>Element</code>，也就是说Widget只是描述<code>Element</code>的配置数据！有关<code>Element</code>的详细介绍我们将在本书后面的高级部分深入介绍，现在，读者只需要知道：**Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个<code>Element</code>**。这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个<code>Element</code>节点都会对应一个Widget对象。总结一下：</p><ul><li><p>Widget实际上就是<code>Element</code>的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由<code>Element</code>构成；不过，由于<code>Element</code>是通过Widget生成的，所以它们之间有对应关系，在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</p></li><li><p>一个Widget对象可以对应多个<code>Element</code>对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</p><h4 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h4></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line">  <span class="keyword">final</span> Key key;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toStringShort() &#123;</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="string">&#x27;<span class="subst">$runtimeType</span>&#x27;</span> : <span class="string">&#x27;<span class="subst">$runtimeType</span>-<span class="subst">$key</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Widget</code>类继承自<code>DiagnosticableTree</code>，<code>DiagnosticableTree</code>即“诊断树”，主要作用是提供调试信息。</li><li><code>Key</code>: 这个<code>key</code>属性类似于React/Vue中的<code>key</code>，主要的作用是决定是否在下一次<code>build</code>时复用旧的widget，决定的条件在<code>canUpdate()</code>方法中。</li><li><code>createElement()</code>：正如前文所述“一个Widget可以对应多个<code>Element</code>”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的<code>Element</code>对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。</li><li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li><li><code>canUpdate(...)</code>是一个静态方法，它主要用于在Widget树重新<code>build</code>时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的<code>Element</code>对象的配置；通过其源码我们可以看到，只要<code>newWidget</code>与<code>oldWidget</code>的<code>runtimeType</code>和<code>key</code>同时相等时就会用<code>newWidget</code>去更新<code>Element</code>对象的配置，否则就会创建新的<code>Element</code>。</li></ul><p>另外<code>Widget</code>类本身是一个抽象类，其中最核心的就是定义了<code>createElement()</code>接口，在Flutter开发中，我们一般都不用直接继承<code>Widget</code>类来实现一个新组件，相反，我们通常会通过继承<code>StatelessWidget</code>或<code>StatefulWidget</code>来间接继承<code>Widget</code>类来实现。<code>StatelessWidget</code>和<code>StatefulWidget</code>都是直接继承自<code>Widget</code>类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型，接下来我们将重点介绍一下这两个类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-19</title>
      <link href="2021/07/19/7-19/"/>
      <url>2021/07/19/7-19/</url>
      
        <content type="html"><![CDATA[<h1 id="1838：最高频元素的频数"><a href="#1838：最高频元素的频数" class="headerlink" title="1838：最高频元素的频数"></a>1838：最高频元素的频数</h1><p>元素的 频数 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。</p><p>执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。</p><p>示例 1：</p><p>输入：nums = [1,2,4], k = 5<br>输出：3<br>解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。<br>4 是数组中最高频元素，频数是 3 。<br>示例 2：</p><p>输入：nums = [1,4,8,13], k = 5<br>输出：2<br>解释：存在多种最优解决方案：</p><ul><li>对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。</li><li>对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。</li><li>对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。<br>示例 3：</li></ul><p>输入：nums = [3,9,6], k = 2<br>输出：1</p><p>思路：我写的排序+滑动窗口（但是时间超时了，测试用例都能通过）。想法是先对数组进行排序，滑动窗口内的是，每个数增加到最右侧所需要的的差值。判断该差值和k的关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int maxFrequency(int[] nums, int k)&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    int ans = 1;</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    while (right &lt;= nums.length - 1)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            sum = sum + (nums[right] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum &lt;= k)&#123;</span><br><span class="line">            ans = Math.max(ans, right - left + 1);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对如何求取差值做了优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int maxFrequency(int[] nums, int k)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int ans = 1;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int left = 0, right = 1;</span><br><span class="line">        while (right &lt; nums.length)&#123;</span><br><span class="line">            sum = sum + (nums[right] - nums[right - 1]) * (right - left);</span><br><span class="line">            if (sum &lt;= k)&#123;</span><br><span class="line">                ans = Math.max(ans, right - left + 1);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                sum = sum - (nums[right] - nums[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-18</title>
      <link href="2021/07/18/7-18/"/>
      <url>2021/07/18/7-18/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题10-02-变位词组"><a href="#面试题10-02-变位词组" class="headerlink" title="面试题10.02.变位词组"></a>面试题10.02.变位词组</h1><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p><p>注意：本题相对原题稍作修改</p><p>示例:</p><p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p><p>思路：变位词是指字母相同，排列不同的字符串。我们可以对同一类的变位词排序，将排序之后的（同一类的当然key相同）key作为map的key，用同一个list保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;String&gt;&gt; group(String[] strs)&#123;</span><br><span class="line">     HashMap&lt;String, List&lt;String&gt;&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">     for (String ss : strs)&#123;</span><br><span class="line">         char[] c = ss.toCharArray();</span><br><span class="line">         Arrays.sort(c);</span><br><span class="line">         String key = new String(c);</span><br><span class="line">         System.out.println(key);</span><br><span class="line">         System.out.println(&quot;===&quot;);</span><br><span class="line">         List&lt;String&gt; list = hashMap.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class="line">         list.add(ss);</span><br><span class="line">         hashMap.put(key, list);</span><br><span class="line">     &#125;</span><br><span class="line">     return new ArrayList&lt;&gt;(hashMap.values());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路2：一样的原理，同一类变位词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">     List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">     Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">     for (String s : strs) &#123;</span><br><span class="line">         int[] cnts = new int[26];</span><br><span class="line">         for (char c : s.toCharArray()) cnts[c - &#x27;a&#x27;]++;</span><br><span class="line">         StringBuilder sb = new StringBuilder();</span><br><span class="line">         for (int i : cnts) sb.append(i + &quot;_&quot;);</span><br><span class="line">         String key = sb.toString();</span><br><span class="line">         List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;&gt;());</span><br><span class="line">         list.add(s);</span><br><span class="line">         map.put(key, list);</span><br><span class="line">     &#125;</span><br><span class="line">     for (String key : map.keySet()) ans.add(map.get(key));</span><br><span class="line">     return ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-17</title>
      <link href="2021/07/17/7-17/"/>
      <url>2021/07/17/7-17/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer42：连续子数组的最大和"><a href="#剑指offer42：连续子数组的最大和" class="headerlink" title="剑指offer42：连续子数组的最大和"></a>剑指offer42：连续子数组的最大和</h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>暴力递归：遍历数组，以i为子数组开始的所有子数组。并且比较大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">    int ans = Integer.MIN_VALUE;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        for (int j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum = sum + nums[j];</span><br><span class="line">            if (sum &gt; ans)&#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>如果当前子数组加上下一位变小了，说明需要重新选择子数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">        int currSum = 0;</span><br><span class="line">        int maxSum = Integer.MIN_VALUE;       //全负情况，返回最大数</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            currSum = (nums[j] &gt; currSum + nums[j]) ? nums[j] : currSum + nums[j];</span><br><span class="line">            maxSum = (maxSum &gt; currSum) ? maxSum : currSum;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转换成动态规划的过程：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        for(int j = 1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(dp[j-1]&gt;0)&#123;</span><br><span class="line">                dp[j] = dp[j-1]+nums[j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[j] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            if(dp[i]&gt;max)</span><br><span class="line">                max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-16</title>
      <link href="2021/07/17/7-16/"/>
      <url>2021/07/17/7-16/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer53：在排序数组中查找数字1"><a href="#剑指offer53：在排序数组中查找数字1" class="headerlink" title="剑指offer53：在排序数组中查找数字1"></a>剑指offer53：在排序数组中查找数字1</h1><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6</p><p>第一种可以放在一个map中，第二种可以遍历。这两种的时间复杂度都是o（n）的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target)&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            hashMap.put(nums[i], hashMap.getOrDefault(nums[i], 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return hashMap.get(target) != null ? hashMap.get(target) : 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>利用数组已经排序的特点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记day01</title>
      <link href="2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/"/>
      <url>2021/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0day01/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记01"><a href="#操作系统笔记01" class="headerlink" title="操作系统笔记01"></a>操作系统笔记01</h1><h2 id="Hello-OS："><a href="#Hello-OS：" class="headerlink" title="Hello OS："></a>Hello OS：</h2><p>引导程序：机器加电启动后，整个计算机第一个启动的程序就是固化在PC主板上的BIOS固件，它启动之后检测系统参数，如内存的大小、日期和时间、磁盘设备以及这些磁盘设备用来引导的顺序。BIOS寻找用于装载操作系统的指令。装载操作系统的这个程序就是boot loader。Linux系统默认的boot loader就是GRUB（GRand Unified Bootloader），于是PC上电以后系统启动流程如下。<br><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\操作引导图.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="lable"></p><p>接下来我们要做的就是写一个由GRUB引导的“操作系统”——它会在屏幕上显示“Hello OS“。**注：**其实操作系统归根结底也是一个程序，只不过它在开机之后已经运行，并且权限和功能高的吓人，你可以将它看成是整个计算机应用的**管家角色**。</p><p>1.下载源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/lmos/cosmos/tree/master/</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\helloOs代码结构.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="lable"></p><p>entry.asm:汇编代码，用作GRUB引导调用，关掉中断，设定CPU工作模式，初始化寄存器及c语言运行环境。</p><p>hello.lds:进行链接调用。</p><p>install.md:需要将这个文件里的内容复制到GRUB的cfg配置文件中，才能使电脑开机时找到我们的HelloOS</p><p>main.c:HelloOS的主函数，注意printf不是c语言函数库，而是自己实现的printf也就是vgastr.h。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//彭东 @ 2021.01.09</span><br><span class="line">#include &quot;vgastr.h&quot;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello OS!&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vgastr.h:控制计算机屏幕VGABIOS固件程序显示特定的字符</p><p>Makefile：利用make工具来实现编译源代码主要是将entry.asm、main.c、vgastr.h编译并链接。</p><h2 id="编译操作系统：Makefile文件中已经写了如何编译-操作系统，只是自己目前看不懂。"><a href="#编译操作系统：Makefile文件中已经写了如何编译-操作系统，只是自己目前看不懂。" class="headerlink" title="编译操作系统：Makefile文件中已经写了如何编译 操作系统，只是自己目前看不懂。"></a>编译操作系统：Makefile文件中已经写了如何编译 操作系统，只是自己目前看不懂。</h2><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source\images\编译过程.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-15</title>
      <link href="2021/07/15/7-15/"/>
      <url>2021/07/15/7-15/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2021/07/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2021/07/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="从有序序列中找某个数，第一反应应该是二分。"><a href="#从有序序列中找某个数，第一反应应该是二分。" class="headerlink" title="从有序序列中找某个数，第一反应应该是二分。"></a>从有序序列中找某个数，第一反应应该是二分。</h2><p>二分模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">「二分」模板其实有两套，主要是根据 check(mid) 函数为 true 时，需要调整的是 l 指针还是 r 指针来判断。</span><br><span class="line"></span><br><span class="line">当 check(mid) == true 调整的是 l 时：计算 mid 的方式应该为 mid = l + r + 1 &gt;&gt; 1：</span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line">long l = 0, r = 1000009;</span><br><span class="line">while (l &lt; r) &#123;</span><br><span class="line">    long mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">    if (check(mid)) &#123;</span><br><span class="line">        l = mid;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当 check(mid) == true 调整的是 r 时：计算 mid 的方式应该为 mid = l + r &gt;&gt; 1：</span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line">long l = 0, r = 1000009;</span><br><span class="line">while (l &lt; r) &#123;</span><br><span class="line">    long mid = l + r &gt;&gt; 1;</span><br><span class="line">    if (check(mid)) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode33：搜索旋转排序数组"><a href="#leetcode33：搜索旋转排序数组" class="headerlink" title="leetcode33：搜索旋转排序数组"></a>leetcode33：搜索旋转排序数组</h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br>示例 2：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br>示例 3：</p><p>输入：nums = [1], target = 0<br>输出：-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static int search(int[] nums, int target)&#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    int left = 0, right = nums.length;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)&#123;</span><br><span class="line">        if (nums[i] &gt; nums[i + 1])&#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = binarySearch(0, index, target, nums);</span><br><span class="line">    if (ans != -1)&#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    if (index + 1 &lt; nums.length)&#123;</span><br><span class="line">        ans = binarySearch(index + 1, nums.length - 1, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//区间为[]</span><br><span class="line">private static int binarySearch(int left, int right, int target, int[] nums) &#123;</span><br><span class="line">    while (left &lt;= right)&#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分不是单纯的指从有序数组中快速找到某个数，这只是二分的一份应用。</p><p>二分的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质就可以用二分。</p><h1 id="leetcode29：两数相除"><a href="#leetcode29：两数相除" class="headerlink" title="leetcode29：两数相除"></a>leetcode29：两数相除</h1><p>题目：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><p>示例 1:</p><p>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3<br>示例 2:</p><p>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter实战</title>
      <link href="2021/07/14/Flutter%E5%AE%9E%E6%88%98/"/>
      <url>2021/07/14/Flutter%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.flutterchina.club/">https://book.flutterchina.club/</a></p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h5 id="原生开发："><a href="#原生开发：" class="headerlink" title="原生开发："></a>原生开发：</h5><p>原生应用程序是指某一个移动平台（比如iOS或安卓）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。原生开发有以下主要优势：</p><ul><li>可访问平台全部功能（GPS、摄像头）；</li><li>速度快、性能高、可以实现复杂动画及绘制，整体用户体验好；</li></ul><p>主要缺点：</p><ul><li>平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大；</li><li>内容固定，动态化弱，大多数情况下，有新功能更新时只能发版；</li></ul><p>在移动互联网发展初期，业务场景并不复杂，原生开发还可以应对产品需求迭代。 但近几年，随着物联网时代到来、移动互联网高歌猛进，日新月异，在很多业务场景中，传统的纯原生开发已经不能满足日益增长的业务需求。主要表现在：</p><ul><li>动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，所以，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。</li><li>业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。</li></ul><p>总结一下，纯原生开发主要面临动态化和开发成本两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。</p><h5 id="跨平台技术"><a href="#跨平台技术" class="headerlink" title="跨平台技术"></a>跨平台技术</h5><p>针对原生开发面临问题，人们一直都在努力寻找好的解决方案，而时至今日，已经有很多跨平台框架(注意，本书中所指的“跨平台”若无特殊说明，即特指Android和iOS两个平台)，根据其原理，主要分为三类：</p><ul><li>H5+原生（Cordova、Ionic、微信小程序）</li><li>JavaScript开发+原生渲染 （React Native、Weex、快应用）</li><li>自绘UI+原生(QT for mobile、Flutter)</li></ul><p>Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。那么，我们会担心，QT mobile面对的问题Flutter是否也一样，Flutter会不会步入QT mobile后尘，成为另一个烈士？要回到这个问题，我们先来看看Flutter诞生过程：</p><ul><li>2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架——Flutter。</li><li>2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。</li><li>2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。</li></ul><p>观其发展，在2018年5月份，Flutter 进入了 GitHub stars 排行榜前 100 名，已有 27k star。而今天(2019年5月29日)，已经有65K的Star。经历了短短2年多的时间，Flutter 生态系统得以快速增长，由此可见，Flutter在开发者中受到了热烈的欢迎，其未来发展值得期待！</p><p>现在，我们来和QT mobile做一个对比：</p><ol><li>生态：从Github上来看，目前Flutter活跃用户正在高速增长。从Stackoverflow上提问来看，Flutter社区现在已经很庞大。Flutter的文档、资源也越来越丰富，开发过程中遇到的很多问题都可以在Stackoverflow或其github issue中找到答案。</li><li>技术支持：现在Google正在大力推广Flutter，Flutter的作者中很多人都是来自Chromium团队，并且github上活跃度很高。另一个角度，从今年上半年Flutter频繁的版本发布也可以看出Google对Flutter的投入的资源不小，所以在官方技术支持这方面，大可不必担心。</li><li>开发效率：Flutter的热重载可帮助开发者快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以实现毫秒级热重载，并且不会丢失状态。这真的很棒，相信我，如果你是一名原生开发者，体验了Flutter开发流后，很可能就不想重新回去做原生了，毕竟很少有人不吐槽原生开发的编译速度。</li></ol><h5 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h5><p>Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。</p><h6 id="跨平台自绘引擎"><a href="#跨平台自绘引擎" class="headerlink" title="#跨平台自绘引擎"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%87%AA%E7%BB%98%E5%BC%95%E6%93%8E">#</a>跨平台自绘引擎</h6><p>Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。</p><p>Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。</p><p>目前Flutter默认支持iOS、Android、Fuchsia（Google新的自研操作系统）三个移动平台。但Flutter亦可支持Web开发（Flutter for web）和PC开发，本书的示例和介绍主要是基于iOS和Android平台的，其它平台读者可以自行了解。</p><h6 id="高性能"><a href="#高性能" class="headerlink" title="#高性能"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E9%AB%98%E6%80%A7%E8%83%BD">#</a>高性能</h6><p>Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。</p><h6 id="采用Dart语言开发"><a href="#采用Dart语言开发" class="headerlink" title="#采用Dart语言开发"></a><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#%E9%87%87%E7%94%A8dart%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91">#</a>采用Dart语言开发</h6><p>这是一个很有意思，但也很有争议的问题，在了解Flutter为什么选择了 Dart而不是 JavaScript之前我们先来介绍两个概念：JIT和AOT。</p><p>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。</p><p>现在我们看看Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）：</p><ol><li><p><strong>开发效率高</strong></p><p>Dart运行时和编译器支持Flutter的两个关键特性的组合：</p><p><strong>基于JIT的快速开发周期</strong>：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</p><p><strong>基于AOT的发布包</strong>: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。</p></li><li><p><strong>高性能</strong></p><p>Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。</p></li><li><p><strong>快速内存分配</strong></p><p>Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。</p></li><li><p><strong>类型安全</strong></p><p>由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。</p></li></ol><h6 id="Flutter框架结构"><a href="#Flutter框架结构" class="headerlink" title="Flutter框架结构"></a>Flutter框架结构</h6><p><img "" class="lazyload placeholder" data-original="D:\MyBolgWindows\blog\source_posts\flutter.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="flutter"></p><h6 id="Flutter-Framework：这是一个纯-Dart实现的-SDK，它实现了一套基础库，自底向上，我们来简单介绍一下："><a href="#Flutter-Framework：这是一个纯-Dart实现的-SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：" class="headerlink" title="Flutter Framework：这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下："></a>Flutter Framework：这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：</h6><ul><li>底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的<code>dart:ui</code>包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。</li><li>Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。</li><li>Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而<strong>我们Flutter开发的大多数场景，只是和这两层打交道</strong>。</li></ul><h6 id="Flutter-Engine"><a href="#Flutter-Engine" class="headerlink" title="Flutter Engine"></a>Flutter Engine</h6><p>这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 <code>dart:ui</code>库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。</p><h1 id="计数器应用示例"><a href="#计数器应用示例" class="headerlink" title="计数器应用示例"></a>计数器应用示例</h1><p>计数器示例中，每点击一次右下角+号，屏幕中央的数字就会加一。Dart的代码主要在lib/main.dart文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//导入Material UI组件库，Material是一种</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">//flutter应用中main函数作为应用程序的入口。main函数调用了runApp方法，</span><br><span class="line">//功能是启动Flutter应用，接收一个Widget参数。</span><br><span class="line">//=&gt;是Dart中单行函数或方法的简写</span><br><span class="line">//MyApp（）是flutter应用的根组件</span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &#x27;Flutter Demo&#x27;,</span><br><span class="line">      theme: new ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: new MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//首页</span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  MyHomePage(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line">  final String title;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; new _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//_MyHomePageState是MyHomePage类对应的状态类</span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  //维护了一个点击次数计数器</span><br><span class="line">  int _counter = 0;</span><br><span class="line">  //设置状态的自增函数，函数会先自增_counter，然后调用setState方法</span><br><span class="line">  //setState方法的作用是通知Flutter框架，有状态发生了改变，Flutter框架收到通知后，会执行build方法来根据新的状态重新构建界面， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget。</span><br><span class="line">  void _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">//构建UI界面的逻辑在build方法中，当MyHomePage第一次创建时，_MyHomePageState类会被创建，当初始化完成后，Flutter框架会调用Widget的build方法来构建widget树，最终将widget树渲染到设备屏幕上</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Scaffold(</span><br><span class="line">      appBar: new AppBar(</span><br><span class="line">        title: new Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: new Center(</span><br><span class="line">        child: new Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            new Text(</span><br><span class="line">              &#x27;You have pushed the button this many times:&#x27;,</span><br><span class="line">            ),</span><br><span class="line">            new Text(</span><br><span class="line">              &#x27;$_counter&#x27;,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: new FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: &#x27;Increment&#x27;,</span><br><span class="line">        child: new Icon(Icons.add),</span><br><span class="line">      ), // This trailing comma makes auto-formatting nicer for build methods.</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    MyApp类代表Flutter应用，它继承了 StatelessWidget类，这也就意味着应用本身也是一个widget。<br>​    在Flutter中，大多数东西都是widget（后同“组件”或“部件”），包括对齐(alignment)、填充(padding)和布局(layout)等，它们都是以widget的形式提供。<br>​    Flutter在构建页面时，会调用组件的build方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。<br>​    MaterialApp 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。MaterialApp也是一个widget。<br>​    home 为Flutter应用的首页，它也是一个widget。</p><p>​    <code>MyHomePage</code> 是Flutter应用的首页，它继承自<code>StatefulWidget</code>类，表示它是一个有状态的组件（Stateful widget）。关于Stateful widget我们将在第三章“Widget简介”一节仔细介绍，现在我们只需简单认为有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同：</p><ol><li><p>Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。</p></li><li><p>Stateful widget至少由两个类组成：</p><ul><li>一个<code>StatefulWidget</code>类。</li><li>一个 <code>State</code>类； <code>StatefulWidget</code>类本身是不变的，但是<code>State</code>类中持有的状态在widget生命周期中可能会发生变化。</li></ul><p><code>_MyHomePageState</code>类是<code>MyHomePage</code>类对应的状态类。看到这里，读者可能已经发现：和<code>MyApp</code> 类不同， <code>MyHomePage</code>类中并没有<code>build</code>方法，取而代之的是，<code>build</code>方法被挪到了<code>_MyHomePageState</code>方法中，</p></li></ol><p><code>Scaffold</code> 是 Material 库中提供的页面脚手架，它提供了默认的导航栏、标题和包含主屏幕widget树（后同“组件树”或“部件树”）的<code>body</code>属性，组件树可以很复杂。本书后面示例中，路由默认都是通过<code>Scaffold</code>创建。</p><p><code>body</code>的组件树中包含了一个<code>Center</code> 组件，<code>Center</code> 可以将其子组件树对齐到屏幕中心。此例中， <code>Center</code> 子组件是一个<code>Column</code> 组件，<code>Column</code>的作用是将其所有子组件沿屏幕垂直方向依次排列； 此例中<code>Column</code>子组件是两个 <code>Text</code>，第一个<code>Text</code> 显示固定文本 “You have pushed the button this many times:”，第二个<code>Text</code> 显示<code>_counter</code>状态的数值。</p><p><code>floatingActionButton</code>是页面右下角的带“+”的悬浮按钮，它的<code>onPressed</code>属性接受一个回调函数，代表它被点击后的处理器，本例中直接将<code>_incrementCounter</code>方法作为其处理函数。</p><p>整个计数器执行流程串起来：当右下角的<code>floatingActionButton</code>按钮被点击之后，会调用<code>_incrementCounter</code>方法。在<code>_incrementCounter</code>方法中，首先会自增<code>_counter</code>计数器（状态），然后<code>setState</code>会通知Flutter框架状态发生变化，接着，Flutter框架会调用<code>build</code>方法以新的状态重新构建UI，最终显示在设备屏幕上</p><h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><p>​        路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。Flutter中的路由管理和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p><h2 id="MaterialPageRoute"><a href="#MaterialPageRoute" class="headerlink" title="MaterialPageRoute"></a>MaterialPageRoute</h2><p><code>MaterialPageRoute</code>继承自<code>PageRoute</code>类，<code>PageRoute</code>类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。<code>MaterialPageRoute</code> 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画：</p><ul><li>对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。</li><li>对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  MaterialPageRoute(&#123;</span><br><span class="line">    WidgetBuilder builder,</span><br><span class="line">    RouteSettings settings,</span><br><span class="line">    bool maintainState = true,</span><br><span class="line">    bool fullscreenDialog = false,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">//builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。</span><br><span class="line">//settings 包含路由的配置信息，如路由名称、是否初始路由（首页）。</span><br><span class="line">//maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。</span><br><span class="line">//fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。</span><br></pre></td></tr></table></figure><h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator:"></a>Navigator:</h2><p><code>Navigator</code>是一个路由管理的组件，它提供了打开和退出路由页方法。<code>Navigator</code>通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。<code>Navigator</code>提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：</p><h3 id="Future-push-BuildContext-context-Route-route"><a href="#Future-push-BuildContext-context-Route-route" class="headerlink" title="Future push(BuildContext context, Route route)"></a>Future push(BuildContext context, Route route)</h3><p>将给定的路由入栈（即打开新的页面），返回值是一个<code>Future</code>对象，用以接收新路由出栈（即关闭）时的返回数据。</p><h3 id="bool-pop-BuildContext-context-result"><a href="#bool-pop-BuildContext-context-result" class="headerlink" title="#bool pop(BuildContext context, [ result ])"></a><a href="https://book.flutterchina.club/chapter2/flutter_router.html#bool-pop-buildcontext-context-result">#</a>bool pop(BuildContext context, [ result ])</h3><p>将栈顶路由出栈，<code>result</code>为页面关闭时返回给上一个页面的数据。</p><p><code>Navigator</code> 还有很多其它方法，如<code>Navigator.replace</code>、<code>Navigator.popUntil</code>等，详情请参考API文档或SDK源码注释，在此不再赘述。</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>Navigator类中第一个参数为context的<strong>静态方法</strong>都对应一个Navigator的<strong>实例方法</strong>， 比如<code>Navigator.push(BuildContext context, Route route)</code>等价于<code>Navigator.of(context).push(Route route)</code></p><h2 id="路由传值："><a href="#路由传值：" class="headerlink" title="路由传值："></a>路由传值：</h2><h3 id="命名路由传值：命名路由”（Named-Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。"><a href="#命名路由传值：命名路由”（Named-Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。" class="headerlink" title="命名路由传值：命名路由”（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。"></a>命名路由传值：命名路由”（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。</h3><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。其实注册路由表就是给路由起名字，路由表的定义如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, WidgetBuilder&gt; routes;</span><br></pre></td></tr></table></figure><p>它是一个<code>Map</code>，key为路由的名字，是个字符串；value是个<code>builder</code>回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的<code>WidgetBuilder</code>回调函数，然后调用该回调函数生成路由widget并返回</p><h3 id="注册路由表："><a href="#注册路由表：" class="headerlink" title="注册路由表："></a>注册路由表：</h3><p><code>MyApp</code>类的<code>build</code>方法中找到<code>MaterialApp</code>，添加<code>routes</code>属性，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: &#x27;Flutter Demo&#x27;,</span><br><span class="line">  theme: ThemeData(</span><br><span class="line">    primarySwatch: Colors.blue,</span><br><span class="line">  ),</span><br><span class="line">  //注册路由表</span><br><span class="line">  routes:&#123;</span><br><span class="line">   &quot;new_page&quot;:(context) =&gt; NewRoute(),</span><br><span class="line">    ... // 省略其它路由注册信息</span><br><span class="line">  &#125; ,</span><br><span class="line">  home: MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>将home注册为命名路由：只需在路由表中注册一下<code>MyHomePage</code>路由，然后将其名字作为<code>MaterialApp</code>的<code>initialRoute</code>属性值即可，该属性决定应用的初始路由页是哪一个命名路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: &#x27;Flutter Demo&#x27;,</span><br><span class="line">  initialRoute:&quot;/&quot;, //名为&quot;/&quot;的路由作为应用的home(首页)</span><br><span class="line">  theme: ThemeData(</span><br><span class="line">    primarySwatch: Colors.blue,</span><br><span class="line">  ),</span><br><span class="line">  //注册路由表</span><br><span class="line">  routes:&#123;</span><br><span class="line">   &quot;new_page&quot;:(context) =&gt; NewRoute(),</span><br><span class="line">   &quot;/&quot;:(context) =&gt; MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;), //注册首页路由</span><br><span class="line">  &#125; </span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-14</title>
      <link href="2021/07/14/7-14/"/>
      <url>2021/07/14/7-14/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode1818：绝对差值和"><a href="#leetcode1818：绝对差值和" class="headerlink" title="leetcode1818：绝对差值和"></a>leetcode1818：绝对差值和</h1><p>给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。</p><p>数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。</p><p>你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。</p><p>|x| 定义为：</p><p>如果 x &gt;= 0 ，值为 x ，或者<br>如果 x &lt;= 0 ，值为 -x</p><p>示例 1：</p><p>输入：nums1 = [1,7,5], nums2 = [2,3,5]<br>输出：3<br>解释：有两种可能的最优方案：</p><ul><li>将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者</li><li>将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]<br>两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3<br>示例 2：</li></ul><p>输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]<br>输出：0<br>解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0<br>示例 3：</p><p>输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]<br>输出：20<br>解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] =&gt; [10,10,4,4,2,7]<br>绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20</p><p>解析：这竟然是一道二分查找的题，难道因为刚睡醒一点思路也没有。<img "" class="lazyload placeholder" data-original="file:///C:\Users\ydhc\AppData\Local\Temp\SGPicFaceTpBq\13032\0F7E7DE0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-13</title>
      <link href="2021/07/13/7-13/"/>
      <url>2021/07/13/7-13/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode218天际线问题"><a href="#leetcode218天际线问题" class="headerlink" title="leetcode218天际线问题"></a>leetcode218天际线问题</h1><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p><p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br>righti 是第 i 座建筑物右边缘的 x 坐标。<br>heighti 是第 i 座建筑物的高度。<br>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p><p>具体题目请看<a href="https://leetcode-cn.com/problems/the-skyline-problem/">https://leetcode-cn.com/problems/the-skyline-problem/</a></p><h6 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h6>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter</title>
      <link href="2021/07/13/Flutter/"/>
      <url>2021/07/13/Flutter/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter完整开发实战详解系列"><a href="#Flutter完整开发实战详解系列" class="headerlink" title="Flutter完整开发实战详解系列"></a>Flutter完整开发实战详解系列</h1><p>flutter中所有的组件都是类。</p><h5 id="Flutter-Widget："><a href="#Flutter-Widget：" class="headerlink" title="Flutter Widget："></a>Flutter Widget：</h5><p>在flutter中一切的显示都是widget，widget是一切的基础，利用响应式模式进行渲染。可以修改数据，再用setState设置数据，Flutter会自动通过绑定的数据更新Widget，所以开发者需要做的就是实现Widget，并且和数据绑定。</p><p>Widget分为有状态和无状态两种，在Flutter中每个页面都是一帧，无状态就是保持在那一帧，有状态的Widget当数据更新时，其实是创建了新的Widget，只是State实现了跨帧的数据同步保存。</p><h6 id="无状态的StatelessWidget"><a href="#无状态的StatelessWidget" class="headerlink" title="无状态的StatelessWidget"></a>无状态的StatelessWidget</h6><p>自定义的Widget（类），继承StatelessWidget（抽象类）。通过build方法返回一个布局好的控件。Widget和Widget之间通过child进行嵌套，有的Widget只能有一个child（比如container），有的可以有多个child（比如Column布局）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class DemoWidget extends StatelessWidget&#123;</span><br><span class="line">  //数据可以通过构造方法传递进来</span><br><span class="line">  final String? text;</span><br><span class="line">  DemoWidget(this.text);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    //throw UnimplementedError();</span><br><span class="line">    //这里返回需要的控件</span><br><span class="line">    return Container(</span><br><span class="line">      //蓝色背景</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">      //在Dart语法中，？？表示如果text为空，返回尾号后的内容</span><br><span class="line">      child: Text(text ?? &quot;这就是无状态的Demo&quot;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="有状态的StatefulWidget"><a href="#有状态的StatefulWidget" class="headerlink" title="有状态的StatefulWidget"></a>有状态的StatefulWidget</h6><p>需要创建管理的主要是State，通过State的build方法构建控件。在State中可以动态改变数据，在setState之后，改变的数据会触发Widget重新构建刷新</p><p>State中的声明周期有：initState：初始化，理论上只有一次，有特殊情况。</p><p>didChangeDependencies：在initState之后调用，此时可以获取其他State</p><p>dispose：销毁，只会调用一次</p><p>综上：flutter中的关注点：创建StatelessWidget或者StatefulWidget，需要的就是在build中堆积你的布局，然后把数据添加到Widget中，最后通过setState改变数据，实现画面变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:async&#x27;;</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class DemoStateWidget extends StatefulWidget&#123;</span><br><span class="line">  //通过构造方法传值</span><br><span class="line">  final String text;</span><br><span class="line">  DemoStateWidget(this.text);</span><br><span class="line"></span><br><span class="line">  //主要是负责创建state</span><br><span class="line">  @override</span><br><span class="line">  _DemoStateWidgetState createState() &#123;</span><br><span class="line">    // TODO: implement createState</span><br><span class="line">    throw UnimplementedError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _DemoStateWidgetState extends State&lt;DemoStateWidget&gt;&#123;</span><br><span class="line">  //同样通过构造方法传值</span><br><span class="line">  String text;</span><br><span class="line">  _DemoStateWidgetState(this.text);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    //初始化，这个函数在声明周期中只调用一次</span><br><span class="line">    // TODO: implement initState</span><br><span class="line">    super.initState();</span><br><span class="line">    //定时一秒</span><br><span class="line">    new Future.delayed(const Duration(seconds: 1),())&#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        text = &quot;这就遍历数值&quot;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    //销毁</span><br><span class="line">    // TODO: implement dispose</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void didChangeDependencies() &#123;</span><br><span class="line">    //在initState之后</span><br><span class="line">    // TODO: implement didChangeDependencies</span><br><span class="line">    super.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    //throw UnimplementedError();</span><br><span class="line">    return Container(</span><br><span class="line">      child: Text(text ?? &quot;这就是有状态的Demo&quot;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Flutter布局"><a href="#Flutter布局" class="headerlink" title="Flutter布局"></a>Flutter布局</h5><p>Flutter 中拥有需要将近 30 种内置的 布局 Widget ，其中常⽤有Container 、<br>Padding 、 Center 、 Flex 、 Stack 、 Row 、 Column 、 ListView 等，</p><h6 id="Container：只有⼀个⼦Widget-。默认充满，包含了-padding-、"><a href="#Container：只有⼀个⼦Widget-。默认充满，包含了-padding-、" class="headerlink" title="Container：只有⼀个⼦Widget 。默认充满，包含了 padding 、"></a>Container：只有⼀个⼦Widget 。默认充满，包含了 padding 、</h6><p>margin 、 color 、宽⾼、 decoration 等配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">最常⽤的默认控件，但是实际上它是由多个内置控件组</span><br><span class="line">成的模版，只能包含⼀个child ，⽀持padding,margin,color, 宽</span><br><span class="line">⾼ ,decoration （⼀般配置边框和阴影）等配置，在Flutter 中，不是</span><br><span class="line">所有的控件都有宽⾼、 padding 、 margin 、 color 等属性，所以才会</span><br><span class="line">有Padding 、 Center 等Widget 的存在。</span><br><span class="line"></span><br><span class="line">new Container(</span><br><span class="line">/// 四周 10 ⼤⼩的 maring</span><br><span class="line">margin: EdgeInsets.all(10.0),</span><br><span class="line">height: 120.0,</span><br><span class="line">width: 500.0,</span><br><span class="line">/// 透明⿊⾊遮罩</span><br><span class="line">decoration: new BoxDecoration(</span><br><span class="line">/// 弧度为 4.0</span><br><span class="line">borderRadius: BorderRadius.all(Radius.circula</span><br><span class="line">/// 设置了 decoration 的 color ，就不能设置 Container 的</span><br><span class="line">color: Colors.black,</span><br><span class="line">/// 边框</span><br><span class="line">border: new Border.all(color: Color(GSYColors</span><br><span class="line">child:new Text(&quot;666666&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Padding：只有⼀个⼦Widget-。只⽤于设置-Padding-，常⽤于嵌"><a href="#Padding：只有⼀个⼦Widget-。只⽤于设置-Padding-，常⽤于嵌" class="headerlink" title="Padding：只有⼀个⼦Widget 。只⽤于设置 Padding ，常⽤于嵌"></a>Padding：只有⼀个⼦Widget 。只⽤于设置 Padding ，常⽤于嵌</h6><p>套 child ，给 child 设置 padding </p><h6 id="Center：只有⼀个⼦Widget-。只⽤于居中显示，常⽤于嵌套"><a href="#Center：只有⼀个⼦Widget-。只⽤于居中显示，常⽤于嵌套" class="headerlink" title="Center：只有⼀个⼦Widget 。只⽤于居中显示，常⽤于嵌套"></a>Center：只有⼀个⼦Widget 。只⽤于居中显示，常⽤于嵌套</h6><p>child ，给 child 设置居中</p><h6 id="Stack：可以有多个⼦Widget-。⼦-Widget-堆叠在⼀起。"><a href="#Stack：可以有多个⼦Widget-。⼦-Widget-堆叠在⼀起。" class="headerlink" title="Stack：可以有多个⼦Widget 。⼦ Widget 堆叠在⼀起。"></a>Stack：可以有多个⼦Widget 。⼦ Widget 堆叠在⼀起。</h6><h6 id="Column：可以有多个⼦Widget-。垂直布局"><a href="#Column：可以有多个⼦Widget-。垂直布局" class="headerlink" title="Column：可以有多个⼦Widget 。垂直布局"></a>Column：可以有多个⼦Widget 。垂直布局</h6><h6 id="Row：可以有多个⼦Widget-。⽔平布局"><a href="#Row：可以有多个⼦Widget-。⽔平布局" class="headerlink" title="Row：可以有多个⼦Widget 。⽔平布局"></a>Row：可以有多个⼦Widget 。⽔平布局</h6><p>Column 、 Row 绝对是必备布局， 横竖布局也是⽇常中最常⻅的场<br>景。如下⽅所示，它们常⽤的有这些属性配置：主轴⽅向是 start 或<br>center 等；副轴⽅向⽅向是start 或center 等； mainAxisSize 是充满<br>最⼤尺⼨，或者只根据⼦Widget 显示最⼩尺⼨</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 主轴⽅向， Column 的竖向、 Row 我的横向</span><br><span class="line">mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">// 默认是最⼤充满、还是根据 child 显示最⼩⼤⼩</span><br><span class="line">mainAxisSize: MainAxisSize.max,</span><br><span class="line">// 副轴⽅向， Column 的横向、 Row 我的竖向</span><br><span class="line">crossAxisAlignment :CrossAxisAlignment.center,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Expanded：只有⼀个⼦Widget-。在Column-和Row-中充满。"><a href="#Expanded：只有⼀个⼦Widget-。在Column-和Row-中充满。" class="headerlink" title="Expanded：只有⼀个⼦Widget 。在Column 和Row 中充满。"></a>Expanded：只有⼀个⼦Widget 。在Column 和Row 中充满。</h6><p>Expanded 在Column 和Row 中代表着平均充满的作⽤，当有两个存在的时候默认均分充满。同时⻚可以设置flex 属性决定⽐例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Column(</span><br><span class="line">/// 主轴居中 , 即是竖直向居中</span><br><span class="line">mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">/// ⼤⼩按照最⼩显示</span><br><span class="line">mainAxisSize : MainAxisSize.min,</span><br><span class="line">/// 横向也居中</span><br><span class="line">crossAxisAlignment : CrossAxisAlignment.center,</span><br><span class="line">children: &lt;Widget&gt;[</span><br><span class="line">///flex 默认为 1</span><br><span class="line">new Expanded(child: new Text(&quot;1111&quot;), flex: 2,),</span><br><span class="line">new Expanded(child: new Text(&quot;2222&quot;)),</span><br><span class="line">],</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="ListView：可以有多个子Widget"><a href="#ListView：可以有多个子Widget" class="headerlink" title="ListView：可以有多个子Widget"></a>ListView：可以有多个子Widget</h6><h5 id="Flutter页面"><a href="#Flutter页面" class="headerlink" title="Flutter页面"></a>Flutter页面</h5><p>Flutter 中除了布局的Widget ，还有交互显示的Widget 和完整⻚⾯呈现的<br>Widget ，其中常⻅的有MaterialApp 、 Scaffold 、 Appbar 、 Text 、 Image 、FlatButton 等</p><h6 id="MaterialApp：⼀般作为-APP-顶层的主⻚⼊⼝，可配置主题，多语"><a href="#MaterialApp：⼀般作为-APP-顶层的主⻚⼊⼝，可配置主题，多语" class="headerlink" title="MaterialApp：⼀般作为 APP 顶层的主⻚⼊⼝，可配置主题，多语"></a>MaterialApp：⼀般作为 APP 顶层的主⻚⼊⼝，可配置主题，多语</h6><p>⾔，路由等</p><h6 id="Scaffold：⼀般⽤户⻚⾯的承载-Widget-，包含-appbar-、snackbar-、-drawer-等-material-design-的设定"><a href="#Scaffold：⼀般⽤户⻚⾯的承载-Widget-，包含-appbar-、snackbar-、-drawer-等-material-design-的设定" class="headerlink" title="Scaffold：⼀般⽤户⻚⾯的承载 Widget ，包含 appbar 、snackbar 、 drawer 等 material design 的设定"></a>Scaffold：⼀般⽤户⻚⾯的承载 Widget ，包含 appbar 、snackbar 、 drawer 等 material design 的设定</h6><h6 id="Appbar：⼀般⽤于-Scaffold-的-appbar-，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些，-tabbar-等也会需要它"><a href="#Appbar：⼀般⽤于-Scaffold-的-appbar-，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些，-tabbar-等也会需要它" class="headerlink" title="Appbar：⼀般⽤于 Scaffold 的 appbar ，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些， tabbar 等也会需要它"></a>Appbar：⼀般⽤于 Scaffold 的 appbar ，内有标题，⼆级⻚⾯返回按键等，当然不⽌这些， tabbar 等也会需要它</h6><h6 id="Text：显示⽂本，⼏乎都会⽤到，主要是通过-style-设置TextStyle-来设置字体样式等"><a href="#Text：显示⽂本，⼏乎都会⽤到，主要是通过-style-设置TextStyle-来设置字体样式等" class="headerlink" title="Text：显示⽂本，⼏乎都会⽤到，主要是通过 style 设置TextStyle 来设置字体样式等"></a>Text：显示⽂本，⼏乎都会⽤到，主要是通过 style 设置TextStyle 来设置字体样式等</h6><h6 id="RichText：富⽂本，通过设置TextSpan-，可以拼接出富⽂本场景。"><a href="#RichText：富⽂本，通过设置TextSpan-，可以拼接出富⽂本场景。" class="headerlink" title="RichText：富⽂本，通过设置TextSpan ，可以拼接出富⽂本场景。"></a>RichText：富⽂本，通过设置TextSpan ，可以拼接出富⽂本场景。</h6><h6 id="TextField：⽂本输⼊框-：new-TextField-controller-⽂本控制器-obscureText-“hint-⽂本-“"><a href="#TextField：⽂本输⼊框-：new-TextField-controller-⽂本控制器-obscureText-“hint-⽂本-“" class="headerlink" title="TextField：⽂本输⼊框 ：new TextField(controller: // ⽂本控制器 , obscureText: “hint ⽂本 “);"></a>TextField：⽂本输⼊框 ：new TextField(controller: // ⽂本控制器 , obscureText: “hint ⽂本 “);</h6><h6 id="Image：图⽚加载-new-FadeInImage-assetNetwork"><a href="#Image：图⽚加载-new-FadeInImage-assetNetwork" class="headerlink" title="Image：图⽚加载 : new FadeInImage.assetNetwork("></a>Image：图⽚加载 : new FadeInImage.assetNetwork(</h6><p>placeholder: “ 预览图 “, </p><p>fit:BoxFit.fitWidth, </p><p>image: “url”);</p><h6 id="FlatButton：按键点击-new-FlatButton-onPressed-child-new-Container"><a href="#FlatButton：按键点击-new-FlatButton-onPressed-child-new-Container" class="headerlink" title="FlatButton：按键点击 : new FlatButton(onPressed: (){},child: new Container());"></a>FlatButton：按键点击 : new FlatButton(onPressed: (){},child: new Container());</h6>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DartDay2</title>
      <link href="2021/07/12/DartDay2/"/>
      <url>2021/07/12/DartDay2/</url>
      
        <content type="html"><![CDATA[<h1 id="DartDay2"><a href="#DartDay2" class="headerlink" title="DartDay2"></a>DartDay2</h1><h6 id="静态属性和静态方法，可以通过类来访问不用通过实例"><a href="#静态属性和静态方法，可以通过类来访问不用通过实例" class="headerlink" title="静态属性和静态方法，可以通过类来访问不用通过实例"></a>静态属性和静态方法，可以通过类来访问不用通过实例</h6><p>Dart中的静态成员:</p><p>  1、使用static 关键字来实现类级别的变量和函数</p><p>  2、静态方法不能访问非静态成员，非静态方法可以访问静态成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// class Person &#123;</span><br><span class="line">//   static String name = &#x27;张三&#x27;;</span><br><span class="line">//   static void show() &#123;</span><br><span class="line">//     print(name);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// main()&#123;</span><br><span class="line">//   print(Person.name);</span><br><span class="line">//   Person.show();  </span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  static String name = &#x27;张三&#x27;;</span><br><span class="line">  int age=20;  </span><br><span class="line">  static void show() &#123;</span><br><span class="line">    print(name);</span><br><span class="line">  &#125;</span><br><span class="line">  void printInfo()&#123;  /*非静态方法可以访问静态成员以及非静态成员*/</span><br><span class="line">      // print(name);  //访问静态属性</span><br><span class="line">      // print(this.age);  //访问非静态属性</span><br><span class="line">      show();   //调用静态方法</span><br><span class="line">  &#125;</span><br><span class="line">  static void printUserInfo()&#123;//静态方法</span><br><span class="line">        print(name);   //静态属性</span><br><span class="line">        show();        //静态方法</span><br><span class="line"></span><br><span class="line">        //print(this.age);     //静态方法没法访问非静态的属性</span><br><span class="line">        // this.printInfo();   //静态方法没法访问非静态的方法</span><br><span class="line">        // printInfo();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对象操作符："><a href="#对象操作符：" class="headerlink" title="对象操作符："></a>对象操作符：</h6><p>/*<br>Dart中的对象操作符:</p><pre><code>?     条件运算符 （了解）   https://dart.dev/tools/diagnostic-messages#invalid_null_aware_operator        as    类型转换is    类型判断..    级联操作 （连缀）  (记住)</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age;</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">？用法</span><br><span class="line">main() &#123;</span><br><span class="line">  // Person p;</span><br><span class="line">  // p?.printInfo();   //已被最新的dart废弃 了解</span><br><span class="line"></span><br><span class="line">  //  Person p=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  //  p?.printInfo();   //已被最新的dart废弃 了解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">is用法</span><br><span class="line">  // Person p=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  // if(p is Person)&#123;</span><br><span class="line">  //     p.name=&quot;李四&quot;;</span><br><span class="line">  // &#125;</span><br><span class="line">  // p.printInfo();</span><br><span class="line">  // print(p is Object);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">as用法</span><br><span class="line">  // var p1;</span><br><span class="line"></span><br><span class="line">  // p1=&#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">  // p1=new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  // // p1.printInfo();</span><br><span class="line">  // (p1 as Person).printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">级联操作</span><br><span class="line">  //  Person p1=new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  //  p1.printInfo();</span><br><span class="line"></span><br><span class="line">  //  p1.name=&#x27;张三222&#x27;;</span><br><span class="line">  //  p1.age=40;</span><br><span class="line">  //  p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Person p1 = new Person(&#x27;张三1&#x27;, 20);</span><br><span class="line">  p1.printInfo();</span><br><span class="line">  p1</span><br><span class="line">    ..name = &quot;李四&quot;</span><br><span class="line">    ..age = 30</span><br><span class="line">    ..printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">面向对象的三大特性：封装 、继承、多态</span><br><span class="line"></span><br><span class="line">Dart中的类的继承：  </span><br><span class="line">    1、子类使用extends关键词来继承父类</span><br><span class="line">    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数</span><br><span class="line">    3、子类能复写父类的方法 getter和setter</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为父类构造函数无法继承</span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  // Person p=new Person(&#x27;李四&#x27;,20);</span><br><span class="line">  // p.printInfo();</span><br><span class="line"></span><br><span class="line">  // Person p1=new Person(&#x27;张三&#x27;,20);</span><br><span class="line">  // p1.printInfo();</span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;张三&#x27;, 12);</span><br><span class="line">  w.printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">面向对象的三大特性：封装 、继承、多态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dart中的类的继承：  </span><br><span class="line">    1、子类使用extends关键词来继承父类</span><br><span class="line">    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数</span><br><span class="line">    3、子类能复写父类的方法 getter和setter</span><br><span class="line"></span><br><span class="line">   注意:最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">在子类中扩展属性和方法</span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  late String sex;</span><br><span class="line">  Web(String name, num age,String sex) : super(name, age)&#123;</span><br><span class="line">    this.sex=sex;</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">   print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;--$&#123;this.sex&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  // Person p=new Person(&#x27;李四&#x27;,20);</span><br><span class="line">  // p.printInfo();</span><br><span class="line"></span><br><span class="line">  // Person p1=new Person(&#x27;张三&#x27;,20);</span><br><span class="line">  // p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;张三&#x27;, 12,&quot;男&quot;);</span><br><span class="line"></span><br><span class="line">  w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给匿名的构造函数传参</span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age;</span><br><span class="line">  //给匿名的构造函数传参</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  Person.xxx(this.name, this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person &#123;</span><br><span class="line">  late String sex;</span><br><span class="line">  Web(String name, num age, String sex) : super.xxx(name, age) &#123;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;--$&#123;this.sex&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中重写父类的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">  work()&#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;在工作...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age);</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">    super.work();  //自类调用父类的方法</span><br><span class="line">  &#125;</span><br><span class="line">  //覆写父类的方法</span><br><span class="line">  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override </span><br><span class="line">  void printInfo()&#123;</span><br><span class="line">     print(&quot;姓名：$&#123;this.name&#125;---年龄：$&#123;this.age&#125;&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()&#123; </span><br><span class="line"></span><br><span class="line">  Web w=new Web(&#x27;李四&#x27;,20);</span><br><span class="line"></span><br><span class="line">  // w.printInfo();</span><br><span class="line"></span><br><span class="line">  w.run();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类中调用父类的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  num age; </span><br><span class="line">  Person(this.name,this.age);</span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;);  </span><br><span class="line">  &#125;</span><br><span class="line">  work()&#123;</span><br><span class="line">    print(&quot;$&#123;this.name&#125;在工作...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Web extends Person&#123;</span><br><span class="line">  Web(String name, num age) : super(name, age);</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">    super.work();  //自类调用父类的方法</span><br><span class="line">  &#125;</span><br><span class="line">  //覆写父类的方法</span><br><span class="line">  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override </span><br><span class="line">  void printInfo()&#123;</span><br><span class="line">     print(&quot;姓名：$&#123;this.name&#125;---年龄：$&#123;this.age&#125;&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h6><p>/*<br>Dart中抽象类: Dart抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。</p><p>  1、抽象类通过abstract 关键字来定义</p><p>  2、Dart中的抽象方法不能用abstract声明，Dart中没有方法体的方法我们称为抽象方法。</p><p>  3、如果子类继承抽象类必须得实现里面的抽象方法</p><p>  4、如果把抽象类当做接口实现的话必须得实现抽象类里面定义的所有属性和方法。</p><p>  5、抽象类不能被实例化，只有继承它的子类可以</p><p>extends抽象类 和 implements的区别：</p><p>  1、如果要复用抽象类里面的方法，并且要用抽象方法约束自类的话我们就用extends继承抽象类</p><p>  2、如果只是把抽象类当做标准的话我们就用implements实现抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">案例：定义一个Animal 类要求它的子类必须包含eat方法</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">  eat();   //抽象方法</span><br><span class="line">  run();  //抽象方法  </span><br><span class="line">  printInfo()&#123;  //非抽象方法</span><br><span class="line">    print(&#x27;我是一个抽象类里面的普通方法&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">     print(&#x27;小狗在吃骨头&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    // TODO: implement run</span><br><span class="line">    print(&#x27;小狗在跑&#x27;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">    // TODO: implement eat</span><br><span class="line">    print(&#x27;小猫在吃老鼠&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    // TODO: implement run</span><br><span class="line">    print(&#x27;小猫在跑&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">  Dog d=new Dog();</span><br><span class="line">  d.eat();</span><br><span class="line">  d.printInfo();</span><br><span class="line"></span><br><span class="line">   Cat c=new Cat();</span><br><span class="line">  c.eat();</span><br><span class="line">  c.printInfo();</span><br><span class="line"></span><br><span class="line">  // Animal a=new Animal();   //抽象类没法直接被实例化</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Datr中的多态：</span><br><span class="line">    允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。</span><br><span class="line"></span><br><span class="line">    子类的实例赋值给父类的引用。</span><br><span class="line">    </span><br><span class="line">    多态就是父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">  eat();   //抽象方法 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;</span><br><span class="line">     print(&#x27;小狗在吃骨头&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">  @override</span><br><span class="line">  eat() &#123;   </span><br><span class="line">    print(&#x27;小猫在吃老鼠&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    print(&#x27;run&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">  // Dog d=new Dog();</span><br><span class="line">  // d.eat();</span><br><span class="line">  // d.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Cat c=new Cat();</span><br><span class="line">  // c.eat();</span><br><span class="line"></span><br><span class="line">  Animal d=new Dog();</span><br><span class="line"></span><br><span class="line">  d.eat();</span><br><span class="line">  Animal c=new Cat();</span><br><span class="line"></span><br><span class="line">  c.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="接口：进行文件分离"><a href="#接口：进行文件分离" class="headerlink" title="接口：进行文件分离"></a>接口：进行文件分离</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">和Java一样，dart也有接口，但是和Java还是有区别的。</span><br><span class="line"></span><br><span class="line">  首先，dart的接口没有interface关键字定义接口，而是普通类或抽象类都可以作为接口被实现。</span><br><span class="line"></span><br><span class="line">  同样使用implements关键字进行实现。</span><br><span class="line"></span><br><span class="line">  但是dart的接口有点奇怪，如果实现的类是普通类，会将普通类和抽象中的属性的方法全部需要覆写一遍。</span><br><span class="line">  </span><br><span class="line">  而因为抽象类可以定义抽象方法，普通类不可以，所以一般如果要实现像Java接口那样的方式，一般会使用抽象类。</span><br><span class="line"></span><br><span class="line">  建议使用抽象类定义接口。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">定义一个DB库 支持 mysql  mssql  mongodb</span><br><span class="line"></span><br><span class="line">mysql  mssql  mongodb三个类里面都有同样的方法</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Db&#123;   //当做接口   接口：就是约定 、规范</span><br><span class="line">    late String uri;      //数据库的链接地址</span><br><span class="line">    add(String data);</span><br><span class="line">    save();</span><br><span class="line">    delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mysql implements Db&#123;</span><br><span class="line">  </span><br><span class="line">  @override</span><br><span class="line">  String uri;</span><br><span class="line"></span><br><span class="line">  Mysql(this.uri);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  add(data) &#123;</span><br><span class="line">    // TODO: implement add</span><br><span class="line">    print(&#x27;这是mysql的add方法&#x27;+data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  delete() &#123;</span><br><span class="line">    // TODO: implement delete</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  save() &#123;</span><br><span class="line">    // TODO: implement save</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove()&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MsSql implements Db&#123;</span><br><span class="line">  @override</span><br><span class="line">  late String uri;</span><br><span class="line">  @override</span><br><span class="line">  add(String data) &#123;</span><br><span class="line">    print(&#x27;这是mssql的add方法&#x27;+data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  delete() &#123;</span><br><span class="line">    // TODO: implement delete</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  save() &#123;</span><br><span class="line">    // TODO: implement save</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">  Mysql mysql=new Mysql(&#x27;xxxxxx&#x27;);</span><br><span class="line"></span><br><span class="line">  mysql.add(&#x27;1243214&#x27;);</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="Dart中一个类实现多个接口"><a href="#Dart中一个类实现多个接口" class="headerlink" title="Dart中一个类实现多个接口"></a>Dart中一个类实现多个接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Dart中一个类实现多个接口：</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">abstract class A&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  printA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class B&#123;</span><br><span class="line">  printB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implements A,B&#123;  </span><br><span class="line">  @override</span><br><span class="line">  late String name;  </span><br><span class="line">  @override</span><br><span class="line">  printA() &#123;</span><br><span class="line">    print(&#x27;printA&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  printB() &#123;</span><br><span class="line">    // TODO: implement printB</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  C c=new C();</span><br><span class="line">  c.printA();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mixins："><a href="#mixins：" class="headerlink" title="mixins："></a>mixins：</h6><p>/*<br>mixins的中文意思是混入，就是在类中混入其他功能。</p><p>在Dart中可以使用mixins实现类似多继承的功能</p><p>因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.x中使用mixins的条件：</p><p>  1、作为mixins的类只能继承自Object，不能继承其他类<br>  2、作为mixins的类不能有构造函数<br>  3、一个类可以mixins多个mixins类<br>  4、mixins绝不是继承，也不是接口，而是一种全新的特性<br>*/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  String info=&quot;this is A&quot;;</span><br><span class="line">  void printA()&#123;</span><br><span class="line">    print(&quot;A&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  void printB()&#123;</span><br><span class="line">    print(&quot;B&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C with A,B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  var c=new C();  </span><br><span class="line">  c.printA();</span><br><span class="line">  c.printB();</span><br><span class="line">  print(c.info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">mixins的实例类型是什么？</span><br><span class="line"></span><br><span class="line">很简单，mixins的类型就是其超类的子类型。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  String info=&quot;this is A&quot;;</span><br><span class="line">  void printA()&#123;</span><br><span class="line">    print(&quot;A&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  void printB()&#123;</span><br><span class="line">    print(&quot;B&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C with A,B&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;  </span><br><span class="line">   var c=new C();  </span><br><span class="line">   </span><br><span class="line">  print(c is C);    //true</span><br><span class="line">  print(c is A);    //true</span><br><span class="line">  print(c is B);   //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // var a=new A();</span><br><span class="line"></span><br><span class="line">  // print(a is Object);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h6><p>通俗理解：泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持(类型校验)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//只能返回string类型的数据</span><br><span class="line"></span><br><span class="line">  // String getData(String value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//同时支持返回 string类型 和int类型  （代码冗余）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String getData1(String value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // int getData2(int value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//同时返回 string类型 和number类型       不指定类型可以解决这个问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // getData(value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//不指定类型放弃了类型检查。我们现在想实现的是传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型</span><br><span class="line"> 对传入参数和返回参数校验</span><br><span class="line">  // T getData&lt;T&gt;(T value)&#123;</span><br><span class="line">  //     return value;</span><br><span class="line">  // &#125;</span><br><span class="line">只对传入参数校验</span><br><span class="line">  getData&lt;T&gt;(T value)&#123;</span><br><span class="line">      return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">    // print(getData(21));</span><br><span class="line"></span><br><span class="line">    // print(getData(&#x27;xxx&#x27;));</span><br><span class="line"></span><br><span class="line">    // getData&lt;String&gt;(&#x27;你好&#x27;);</span><br><span class="line"></span><br><span class="line">    print(getData&lt;int&gt;(12));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//集合List 泛型类的用法</span><br><span class="line"></span><br><span class="line">//案例：把下面类转换成泛型类，要求MyList里面可以增加int类型的数据，也可以增加String类型的数据。但是每次调用增加的类型要统一</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">class MyList &#123;</span><br><span class="line">  List list = &lt;int&gt;[];</span><br><span class="line">  void add(int value) &#123;</span><br><span class="line">    this.list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">  List getList() &#123;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyList l = new MyList();</span><br><span class="line">l.add(1);</span><br><span class="line">l.add(12);</span><br><span class="line">l.add(5);</span><br><span class="line">print(l.getList());</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class MyList&lt;T&gt; &#123;</span><br><span class="line">  List list = &lt;T&gt;[];</span><br><span class="line">  void add(T value) &#123;</span><br><span class="line">    this.list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List getList() &#123;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  // MyList l1=new MyList();</span><br><span class="line">  // l1.add(&quot;张三&quot;);</span><br><span class="line">  // l1.add(12);</span><br><span class="line">  // l1.add(true);</span><br><span class="line">  // print(l1.getList());</span><br><span class="line"></span><br><span class="line">  // MyList l2 = new MyList&lt;String&gt;();</span><br><span class="line">  // l2.add(&quot;张三1&quot;);</span><br><span class="line">  // // l2.add(11);  //错误的写法</span><br><span class="line">  // print(l2.getList());</span><br><span class="line"></span><br><span class="line">  MyList l3 = new MyList&lt;int&gt;();</span><br><span class="line">  l3.add(11);</span><br><span class="line">  l3.add(12);</span><br><span class="line">  l3.add(&quot;aaaa&quot;);</span><br><span class="line">  print(l3.getList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  // List list = List.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  // List list = new List.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三1&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  // List list = new List&lt;String&gt;.filled(2, &quot;&quot;);</span><br><span class="line">  // list[0] = &quot;张三1&quot;;</span><br><span class="line">  // list[1] = &quot;李四&quot;;</span><br><span class="line">  // print(list);</span><br><span class="line"></span><br><span class="line">  //  List list2 = new List&lt;int&gt;.filled(2, 0);</span><br><span class="line">  //   list2[0] = 12;</span><br><span class="line">  //   list2[1] = 13;</span><br><span class="line">  //   print(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="泛型接口："><a href="#泛型接口：" class="headerlink" title="泛型接口："></a>泛型接口：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Dart中的泛型接口:</span><br><span class="line"></span><br><span class="line">    实现数据缓存的功能：有文件缓存、和内存缓存。内存缓存和文件缓存按照接口约束实现。</span><br><span class="line"></span><br><span class="line">    1、定义一个泛型接口 约束实现它的子类必须有getByKey(key) 和 setByKey(key,value)</span><br><span class="line"></span><br><span class="line">    2、要求setByKey的时候的value的类型和实例化子类的时候指定的类型一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // abstract class ObjectCache &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, Object value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // abstract class StringCache &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, String value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // abstract class Cache&lt;T&gt; &#123;</span><br><span class="line">  //   getByKey(String key);</span><br><span class="line">  //   void setByKey(String key, T value);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class Cache&lt;T&gt;&#123;</span><br><span class="line">  getByKey(String key);</span><br><span class="line">  void setByKey(String key, T value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlieCache&lt;T&gt; implements Cache&lt;T&gt;&#123;</span><br><span class="line">  @override</span><br><span class="line">  getByKey(String key) &#123;    </span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void setByKey(String key, T value) &#123;</span><br><span class="line">   print(&quot;我是文件缓存 把key=$&#123;key&#125;  value=$&#123;value&#125;的数据写入到了文件中&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MemoryCache&lt;T&gt; implements Cache&lt;T&gt;&#123;</span><br><span class="line">  @override</span><br><span class="line">  getByKey(String key) &#123;   </span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void setByKey(String key, T value) &#123;</span><br><span class="line">       print(&quot;我是内存缓存 把key=$&#123;key&#125;  value=$&#123;value&#125; -写入到了内存中&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // MemoryCache m=new MemoryCache&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    //  m.setByKey(&#x27;index&#x27;, &#x27;首页数据&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     MemoryCache m=new MemoryCache&lt;Map&gt;();</span><br><span class="line"></span><br><span class="line">     m.setByKey(&#x27;index&#x27;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:20&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Dart中的库"><a href="#Dart中的库" class="headerlink" title="Dart中的库"></a>Dart中的库</h6><p>/*</p><p>前面介绍Dart基础知识的时候基本上都是在一个文件里面编写Dart代码的，但实际开发中不可能这么写，模块化很重要，所以这就需要使用到库的概念。</p><p>在Dart中，库的使用时通过import关键字引入的。</p><p>library指令可以创建一个库，每个Dart文件都是一个库，即使没有使用library指令来指定。</p><p>Dart中的库主要有三种：</p><pre><code>1、我们自定义的库           import &#39;lib/xxx.dart&#39;;2、系统内置库             import &#39;dart:math&#39;;          import &#39;dart:io&#39;;       import &#39;dart:convert&#39;;3、Pub包管理系统中的库      https://pub.dev/packages    https://pub.flutter-io.cn/packages    https://pub.dartlang.org/flutter/    1、需要在自己想项目根目录新建一个pubspec.yaml    2、在pubspec.yaml文件 然后配置名称 、描述、依赖等信息    3、然后运行 pub get 获取包下载到本地      4、项目中引入库 import &#39;package:http/http.dart&#39; as http; 看文档使用</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导入自己的本地库：</span><br><span class="line">import &#x27;lib/Animal.dart&#x27;;</span><br><span class="line">main()&#123;</span><br><span class="line">  var a=new Animal(&#x27;小黑狗&#x27;, 20);</span><br><span class="line">  print(a.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">导入系统库 </span><br><span class="line">// import &#x27;dart:io&#x27;;</span><br><span class="line">import &quot;dart:math&quot;;</span><br><span class="line">main()&#123;</span><br><span class="line"> </span><br><span class="line">    print(min(12,23));</span><br><span class="line"></span><br><span class="line">    print(max(12,25));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &#x27;dart:io&#x27;;</span><br><span class="line">import &#x27;dart:convert&#x27;;</span><br><span class="line">void main() async&#123;</span><br><span class="line">  var result = await getDataFromZhihuAPI();</span><br><span class="line">  print(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//api接口： http://news-at.zhihu.com/api/3/stories/latest</span><br><span class="line">getDataFromZhihuAPI() async&#123;  //async异步方法</span><br><span class="line">  //1、创建HttpClient对象</span><br><span class="line">  var httpClient = new HttpClient();  </span><br><span class="line">  //2、创建Uri对象</span><br><span class="line">  var uri = new Uri.http(&#x27;news-at.zhihu.com&#x27;,&#x27;/api/3/stories/latest&#x27;);</span><br><span class="line">  //3、发起请求，等待请求</span><br><span class="line">  var request = await httpClient.getUrl(uri);</span><br><span class="line">  //4、关闭请求，等待响应</span><br><span class="line">  var response = await request.close();</span><br><span class="line">  //5、解码响应的内容</span><br><span class="line">  return await response.transform(utf8.decoder).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">async和await</span><br><span class="line">  这两个关键字的使用只需要记住两点：</span><br><span class="line">    只有async方法才能使用await关键字调用方法</span><br><span class="line">    如果调用别的async方法必须使用await关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async是让方法变成异步。</span><br><span class="line">await是等待异步方法执行完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void main() async&#123;</span><br><span class="line">  var result = await testAsync();</span><br><span class="line">  print(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步方法</span><br><span class="line">testAsync() async&#123;</span><br><span class="line">  return &#x27;Hello async&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">导入pub包管理系统中的库</span><br><span class="line">/*</span><br><span class="line">pub包管理系统:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、从下面网址找到要用的库</span><br><span class="line">        https://pub.dev/packages</span><br><span class="line">        https://pub.flutter-io.cn/packages</span><br><span class="line">        https://pub.dartlang.org/flutter/</span><br><span class="line"></span><br><span class="line">2、创建一个pubspec.yaml文件，内容如下</span><br><span class="line"></span><br><span class="line">    name: xxx</span><br><span class="line">    description: A new flutter module project.</span><br><span class="line">    dependencies:  </span><br><span class="line">        http: ^0.12.0+2</span><br><span class="line">        date_format: ^1.0.6</span><br><span class="line"></span><br><span class="line">3、配置dependencies</span><br><span class="line"></span><br><span class="line">4、运行pub get 获取远程库</span><br><span class="line"></span><br><span class="line">5、看文档引入库使用</span><br><span class="line">*/</span><br><span class="line">import &#x27;dart:convert&#x27; as convert;</span><br><span class="line">import &#x27;package:http/http.dart&#x27; as http;</span><br><span class="line">import &#x27;package:date_format/date_format.dart&#x27;;</span><br><span class="line"></span><br><span class="line">main() async &#123;</span><br><span class="line">  // var url = &quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&quot;;</span><br><span class="line"></span><br><span class="line">  //   // Await the http get response, then decode the json-formatted responce.</span><br><span class="line">  //   var response = await http.get(url);</span><br><span class="line">  //   if (response.statusCode == 200) &#123;</span><br><span class="line">  //     var jsonResponse = convert.jsonDecode(response.body);</span><br><span class="line">     </span><br><span class="line">  //     print(jsonResponse);</span><br><span class="line">  //   &#125; else &#123;</span><br><span class="line">  //     print(&quot;Request failed with status: $&#123;response.statusCode&#125;.&quot;);</span><br><span class="line">  //   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    print(formatDate(DateTime(1989, 2, 21), [yyyy, &#x27;*&#x27;, mm, &#x27;*&#x27;, dd]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1、冲突解决</span><br><span class="line">当引入两个库中有相同名称标识符的时候，如果是java通常我们通过写上完整的包名路径来指定使用的具体标识符，甚至不用import都可以，但是Dart里面是必须import的。当冲突的时候，可以使用as关键字来指定库的前缀。如下例子所示：</span><br><span class="line"></span><br><span class="line">    import &#x27;package:lib1/lib1.dart&#x27;;</span><br><span class="line">    import &#x27;package:lib2/lib2.dart&#x27; as lib2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Element element1 = new Element();           // Uses Element from lib1.</span><br><span class="line">    lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;lib/Person1.dart&#x27;;</span><br><span class="line">import &#x27;lib/Person2.dart&#x27; as lib;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  Person p1=new Person(&#x27;张三&#x27;, 20);</span><br><span class="line">  p1.printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  lib.Person p2=new lib.Person(&#x27;李四&#x27;, 20);</span><br><span class="line"></span><br><span class="line">  p2.printInfo();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">部分导入</span><br><span class="line">  如果只需要导入库的一部分，有两种模式：</span><br><span class="line"></span><br><span class="line">     模式一：只导入需要的部分，使用show关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">      import &#x27;package:lib1/lib1.dart&#x27; show foo;</span><br><span class="line"></span><br><span class="line">     模式二：隐藏不需要的部分，使用hide关键字，如下例子所示：</span><br><span class="line"></span><br><span class="line">      import &#x27;package:lib2/lib2.dart&#x27; hide foo;      </span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// import &#x27;lib/myMath.dart&#x27; show getAge;</span><br><span class="line"></span><br><span class="line"> import &#x27;lib/myMath.dart&#x27; hide getName;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">//  getName();</span><br><span class="line">  getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">延迟加载</span><br><span class="line"></span><br><span class="line">    也称为懒加载，可以在需要的时候再进行加载。</span><br><span class="line">    懒加载的最大好处是可以减少APP的启动时间。</span><br><span class="line"></span><br><span class="line">    懒加载使用deferred as关键字来指定，如下例子所示：</span><br><span class="line"></span><br><span class="line">    import &#x27;package:deferred/hello.dart&#x27; deferred as hello;</span><br><span class="line"></span><br><span class="line">    当需要使用的时候，需要使用loadLibrary()方法来加载：</span><br><span class="line"></span><br><span class="line">    greet() async &#123;</span><br><span class="line">      await hello.loadLibrary();</span><br><span class="line">      hello.printGreeting();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Null安全"><a href="#Null安全" class="headerlink" title="Null安全"></a>Null安全</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">  null safety 可以帮助开发者避免一些日常开发中很难被发现的错误，并且额外的好处是可以改善性能。</span><br><span class="line"></span><br><span class="line">  Flutter2.2.0（2021年5月19日发布） 之后的版本都要求使用null safety。</span><br><span class="line"></span><br><span class="line">  ? 可空类型</span><br><span class="line"></span><br><span class="line">  ! 类型断言</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">String? getData(apiUrl)&#123;</span><br><span class="line">  if(apiUrl!=null)&#123;</span><br><span class="line">    return &quot;this is server data&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// void printLength(String? str)&#123;</span><br><span class="line">//   // print(str!.length);</span><br><span class="line">//   if (str!=null)&#123;</span><br><span class="line">//     print(str.length);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">void printLength(String? str)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    print(str!.length); </span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">     print(&quot;str is null&quot;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line"></span><br><span class="line">//1、 ? 可空类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int a=123;</span><br><span class="line">  // print(a);</span><br><span class="line">  </span><br><span class="line">  // String username=&quot;张三&quot;;</span><br><span class="line">  // print(username);</span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt; l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // print(l1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int a=123;  //非空的int类型</span><br><span class="line">  // a=null;  //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;int&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String username=&quot;张三&quot;;  //非空的String类型</span><br><span class="line">  // username=null;   //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;String&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // String? username=&quot;张三&quot;;   // String?  表示username是一个可空类型</span><br><span class="line">  // username=null;</span><br><span class="line">  // print(username);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // int? a=123;  //  int? 表示a是一个可空类型</span><br><span class="line">  // a=null; </span><br><span class="line">  // print(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt; l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // l1=null;  //A value of type &#x27;Null&#x27; can&#x27;t be assigned to a variable of type &#x27;List&lt;String&gt;&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // List&lt;String&gt;? l1=[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</span><br><span class="line">  // l1=null;  </span><br><span class="line">  // print(l1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //调用方法</span><br><span class="line">  // print(getData(&quot;http://www.itying.com&quot;));</span><br><span class="line"></span><br><span class="line">  // print(getData(null));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ! 类型断言</span><br><span class="line"></span><br><span class="line">  // String? str=&quot;this is str&quot;;</span><br><span class="line"></span><br><span class="line">  // str=null;</span><br><span class="line"></span><br><span class="line">  // print(str!.length);  </span><br><span class="line">  </span><br><span class="line">   //类型断言: 如果str不等于null 会打印str的长度，如果等于null会抛出异常</span><br><span class="line"></span><br><span class="line">  //  printLength(&quot;str&quot;);</span><br><span class="line">  </span><br><span class="line">   printLength(null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">late 关键字主要用于延迟初始化。</span><br><span class="line">Dart2.13之后</span><br><span class="line">*/</span><br><span class="line">class Person &#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  void setName(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">  Person p = new Person();</span><br><span class="line">  p.setName(&quot;张三&quot;, 20);</span><br><span class="line">  print(p.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">String printUserInfo(String username, &#123;int age=10, String sex=&quot;男&quot;&#125;) &#123;//行参    </span><br><span class="line">  return &quot;姓名:$username---性别:$sex--年龄:$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line">不指定默认值的时候需要加个required，必须要传入的参数</span><br><span class="line">String printInfo(String username, &#123;required int age, required String sex&#125;) &#123;//行参    </span><br><span class="line">  return &quot;姓名:$username---性别:$sex--年龄:$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">    print(printUserInfo(&#x27;张三&#x27;));</span><br><span class="line"></span><br><span class="line">    print(printUserInfo(&#x27;张三&#x27;,age: 20,sex: &quot;女&quot;));</span><br><span class="line">    </span><br><span class="line">    //age 和 sex必须传入</span><br><span class="line">    print(printInfo(&#x27;张三&#x27;,age: 22,sex: &quot;女&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//表示 name 和age 是必须传入的命名参数</span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  Person(&#123;required this.name,required this.age&#125;);  //表示 name 和age 必须传入</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">   Person p=new Person(</span><br><span class="line">     name: &quot;张三&quot;,</span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Null safety翻译成中文的意思是空安全。</span><br><span class="line"></span><br><span class="line">required翻译成中文的意思是需要、依赖</span><br><span class="line"></span><br><span class="line">required关键词:</span><br><span class="line"></span><br><span class="line">    最开始 @required 是注解</span><br><span class="line">    </span><br><span class="line">    现在它已经作为内置修饰符。</span><br><span class="line">    </span><br><span class="line">    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// name 可以传入也可以不传入   age必须传入</span><br><span class="line">class Person &#123;</span><br><span class="line">  String? name;   //可空属性</span><br><span class="line">  int age;</span><br><span class="line">  Person(&#123;this.name,required this.age&#125;);  //表示 name 和age 必须传入</span><br><span class="line"></span><br><span class="line">  String getName() &#123;</span><br><span class="line">    return &quot;$&#123;this.name&#125;---$&#123;this.age&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(args) &#123;</span><br><span class="line">   Person p=new Person(</span><br><span class="line">     name: &quot;张三&quot;,</span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p.getName());  //张三---20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Person p1=new Person(    </span><br><span class="line">     age: 20</span><br><span class="line">   );</span><br><span class="line">   print(p1.getName());  //null---20</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊HTTP发展</title>
      <link href="2021/07/12/%E7%9E%8E%E8%81%8AHTTP%E5%8F%91%E5%B1%95/"/>
      <url>2021/07/12/%E7%9E%8E%E8%81%8AHTTP%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-0-9到HTTP-2"><a href="#HTTP-0-9到HTTP-2" class="headerlink" title="HTTP/0.9到HTTP/2"></a>HTTP/0.9到HTTP/2</h1><p><strong>HTTP（</strong>HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。自 Tim Berners-Lee 博士和他的团队在1989-1991年间创造出它以来，HTTP已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和3D效果的现代复杂互联网协议。</p><h2 id="万维网的出现："><a href="#万维网的出现：" class="headerlink" title="万维网的出现："></a>万维网的出现：</h2><p>1989年， 当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 <em>Mesh</em>，在随后的1990年项目实施期间被更名为万维网（<em>World Wide Web）。</em>它在现有的TCP和IP协议基础之上建立，由四个部分组成：</p><ul><li>一个用来表示超文本文档的文本格式，*<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">超文本标记语言</a>*（HTML）。</li><li>一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。</li><li>一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 <em>WorldWideWeb。</em></li><li>一个服务器用于提供可访问的文档，即 <em>httpd</em> 的前身。</li></ul><p>这四个部分完成于1990年底，且第一批服务器已经在1991年初在CERN以外的地方运行了。 1991年8月16日，Tim Berners-Lee 在公开的超文本新闻组上发表的文章被视为是万维网公共项目的开始。</p><p>HTTP在应用的早期阶段非常简单，后来被称为HTTP/0.9，有时也叫做单行（one-line）协议。</p><h1 id="HTTP-0-9-单行协议"><a href="#HTTP-0-9-单行协议" class="headerlink" title="HTTP/0.9-单行协议"></a>HTTP/0.9-单行协议</h1><p>HTTP是基于TCP/IP的应用层协议，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p><strong>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET：</strong></p><p>GET /index.html</p><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p><p><strong>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式：</strong></p><html> <body>Hello World</body></html><p>服务器发送完毕，就关闭TCP连接</p><h1 id="HTTP协议-1-0"><a href="#HTTP协议-1-0" class="headerlink" title="HTTP协议/1.0"></a>HTTP协议/1.0</h1><p>1996年5月，HTTP/1.0 版本发布，内容大大增加（详见 <a href="https://tools.ietf.org/html/rfc1945">RFC1945</a>）。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p><strong>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段：</strong></p><p>Connection: keep-alive<br>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。</p><p><strong>服务器同样回应这个字段：</strong></p><p>Connection: keep-alive一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h1 id="HTTP协议-1-1版本"><a href="#HTTP协议-1-1版本" class="headerlink" title="HTTP协议/1.1版本"></a>HTTP协议/1.1版本</h1><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。</p><p><strong>持久连接：</strong>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。</p><p>不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接：</p><p>Connection: close</p><p><strong>管到机制</strong>：1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><p><strong>Content-Length</strong>：一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度：</p><p>Content-Length: 3495<br>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><p><strong>分块传输编码</strong>：使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用Content-Length字段，而使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">“分块传输编码”</a>（chunked transfer encoding）。</p><p>只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成：</p><p>Transfer-Encoding: chunked</p><p><strong>其他功能</strong>：1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名：</p><p>Host: example.com<br>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><p><strong>缺点</strong>：虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">“队头堵塞”</a>（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h1 id="SPDY协议"><a href="#SPDY协议" class="headerlink" title="SPDY协议"></a>SPDY协议</h1><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><p>2015年，<a href="https://http2.github.io/http2-spec/">HTTP/2</a> 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3</p><p><strong>二进制协议</strong>：HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧</p><p><strong>多工</strong>：HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><p><strong>数据流</strong>：因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><p><strong>头信息压缩</strong>：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><p><strong>服务器推送</strong>：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瞎聊TCP/UDP</title>
      <link href="2021/07/12/%E7%9E%8E%E8%81%8ATCP-UDP/"/>
      <url>2021/07/12/%E7%9E%8E%E8%81%8ATCP-UDP/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-12</title>
      <link href="2021/07/12/7-12/"/>
      <url>2021/07/12/7-12/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer链表</title>
      <link href="2021/07/11/%E5%89%91%E6%8C%87offer%E9%93%BE%E8%A1%A8/"/>
      <url>2021/07/11/%E5%89%91%E6%8C%87offer%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer链表题目一"><a href="#剑指offer链表题目一" class="headerlink" title="剑指offer链表题目一"></a>剑指offer链表题目一</h1><h6 id="题目：offer06：-从尾到头打印链表"><a href="#题目：offer06：-从尾到头打印链表" class="headerlink" title="题目：offer06： 从尾到头打印链表"></a>题目：offer06： 从尾到头打印链表</h6><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p><p>解析：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-11</title>
      <link href="2021/07/11/7-11/"/>
      <url>2021/07/11/7-11/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-10</title>
      <link href="2021/07/11/7-10/"/>
      <url>2021/07/11/7-10/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-9</title>
      <link href="2021/07/11/7-9/"/>
      <url>2021/07/11/7-9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="2021/07/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>2021/07/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>滑动窗口是一种解决问题的思路和方法，通常用来解决一些连续问题。比如：求解“连续子串XXX”，连续子数组“XXXX”。</p><p>从类型上说：</p><p>​        1.固定窗口大小</p><p>​        2.窗口大小不固定，求解最大的满足条件的窗口</p><p>​        3.窗口大小不固定，求解最小的满足条件的窗口</p><p>对于固定窗口大小，只需要固定初始化左右指针l和r，分别表示窗口的左右顶点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、l 初始化为 0</span><br><span class="line">二、初始化 r，使得 r - l + 1 等于窗口大小</span><br><span class="line">三、同时移动 l 和 r</span><br><span class="line">四、判断窗口内的连续元素是否满足题目限定的条件</span><br><span class="line">4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解</span><br><span class="line">4.2 如果不满足，则继续。</span><br></pre></td></tr></table></figure><p>可变窗口大小，同样固定初始化左右指针l和r，分别表示窗口的左右顶点，需要保证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、l 和 r 都初始化为 0</span><br><span class="line">二、r 指针移动一步</span><br><span class="line">三、判断窗口内的连续元素是否满足题目限定的条件</span><br><span class="line">3.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 l 指针缩小窗口大小。循环执行 3.1</span><br><span class="line">3.2 如果不满足，则继续。</span><br><span class="line">形象地来看的话，就是 r 指针不停向右移动，l 指针仅仅在窗口满足条件之后才会移动，起到窗口收缩的效果。</span><br></pre></td></tr></table></figure><h1 id="练习题目1：leetcode209，长度最小的子数组"><a href="#练习题目1：leetcode209，长度最小的子数组" class="headerlink" title="练习题目1：leetcode209，长度最小的子数组"></a>练习题目1：leetcode209，长度最小的子数组</h1><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p><p>输入：target = 4, nums = [1,4,4]<br>输出：1<br>示例 3：</p><p>输入：target = 11, nums = [1,1,1,1,1,1,1,1]<br>输出：0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int minSubArrayLen(int[] nums, int target)&#123;</span><br><span class="line">       int l = 0, r = 0;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       int ans = Integer.MAX_VALUE;</span><br><span class="line">       //窗口结束条件</span><br><span class="line">       while (r &lt; nums.length)&#123;</span><br><span class="line">           //更新右边界并更新窗口状态</span><br><span class="line">           sum =sum +nums[r];</span><br><span class="line">           //窗口达到什么状态需要收缩</span><br><span class="line">           while (sum &gt;= target)&#123;</span><br><span class="line">               //缩小左边界并更新窗口状态</span><br><span class="line">               ans = Math.min(ans, r - l +1);</span><br><span class="line">               sum = sum - nums[l];</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           r++;</span><br><span class="line">       &#125;</span><br><span class="line">      return ans == Integer.MAX_VALUE ? 0 : ans;</span><br></pre></td></tr></table></figure><h1 id="题目2：leetcode-76，最小覆盖子串"><a href="#题目2：leetcode-76，最小覆盖子串" class="headerlink" title="题目2：leetcode 76，最小覆盖子串"></a>题目2：leetcode 76，最小覆盖子串</h1><p>题目：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：</p><p>输入：s = “a”, t = “a”<br>输出：”a”</p><h1 id="题目3：无重复字符的最长子串"><a href="#题目3：无重复字符的最长子串" class="headerlink" title="题目3：无重复字符的最长子串"></a>题目3：无重复字符的最长子串</h1><p>题目：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s = “”<br>输出: 0</p><p>思路：不固定窗口大小。用map存储字符和个数，当有字符个数大于1的情况说明含有重复字符，此时应该移动左边的字符直至出现的相同字符个数小于等于1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int  lengthOfLongestSubstring(String s)&#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">       for (int left = 0, right = 0; right &lt; s.length(); right++)&#123;</span><br><span class="line">           char rightChar = s.charAt(right);</span><br><span class="line">           hashMap.put(rightChar, hashMap.getOrDefault(rightChar, 0) + 1);</span><br><span class="line">           while (hashMap.get(rightChar) &gt; 1)&#123;</span><br><span class="line">               char leftChar = s.charAt(left);</span><br><span class="line">               hashMap.put(leftChar, hashMap.get(leftChar) - 1);</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ans = Math.max(ans, right - left + 1);</span><br><span class="line">       &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="题目四：找到字符串中所有字母异位词"><a href="#题目四：找到字符串中所有字母异位词" class="headerlink" title="题目四：找到字符串中所有字母异位词"></a>题目四：找到字符串中所有字母异位词</h1><p>题目：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:</p><p>输入:<br>s: “cbaebabacd” p: “abc”</p><p>输出:<br>[0, 6]</p><p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。<br> 示例 2:</p><p>输入:<br>s: “abab” p: “ab”</p><p>输出:<br>[0, 1, 2]</p><p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">比较两个map里面的内容是否相等：</span><br><span class="line">Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map2 = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">比较方法一：map1.equals(map2))</span><br><span class="line">比较方法二：</span><br><span class="line">Iterator&lt;Entry&lt;String, Integer&gt;&gt; it1 = map1.entrySet().iterator();</span><br><span class="line">while(it1.hasNext())&#123;</span><br><span class="line">Entry&lt;String, Integer&gt; entry1 = it1.next();</span><br><span class="line">Integer integer2 = tempMap.get(entry1.getKey());</span><br><span class="line">if(integer2 == null||(!integer2.equals(entry1.getValue())))&#123;</span><br><span class="line">b = false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个超出时间限制：我的想法是固定滑动窗口，先把p字符串放到map中，有什么字符和对应的个数。然后长的字符串s，用一个固定窗口在s上滑动。每个窗口中字符放到map中，比较两个map 是否相等。相等的话，每次窗口的left放到list中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findAnagrams(String s, String p)&#123;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap_P = new HashMap&lt;&gt;();</span><br><span class="line">       HashMap&lt;Character, Integer&gt; hashMap_S = new HashMap&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">       int revIndex = 0;</span><br><span class="line">       for (int i = 0; i &lt; p.length(); i++)&#123;</span><br><span class="line">           char charOfP = p.charAt(i);</span><br><span class="line">           hashMap_P.put(charOfP, hashMap_P.getOrDefault(charOfP, 0) + 1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for (int j = 0; j &lt;= s.length() - p.length(); j++)&#123;</span><br><span class="line">           int left = j;</span><br><span class="line">           int right = j + p.length() - 1;</span><br><span class="line">           for (int k = left; k &lt;= right; k++)&#123;</span><br><span class="line">               char charOfS = s.charAt(k);</span><br><span class="line">               hashMap_S.put(charOfS, hashMap_S.getOrDefault(charOfS, 0) + 1);</span><br><span class="line">           &#125;</span><br><span class="line">          if (hashMap_S.equals(hashMap_P))&#123;</span><br><span class="line">              list.add(left);</span><br><span class="line">          &#125;</span><br><span class="line">          hashMap_S.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>考虑怎么样优化：我上边的时间复杂度o(s.length*p.length)，要优化到怎么一次遍历就可以完成。把时间复杂度降到0（s.length）。通过常量flag来判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findAnagrams(String s, String p)&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMapOfS = new HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMapOfP = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char c:p.toCharArray()) hashMapOfP.put(c, hashMapOfP.getOrDefault(c, 0) + 1);</span><br><span class="line">        int left = 0, right = 0, flag = 0;</span><br><span class="line">        while (right &lt; s.length())&#123;</span><br><span class="line">            char c = s.charAt(right);</span><br><span class="line">            if (hashMapOfP.containsKey(c))&#123;</span><br><span class="line">                hashMapOfS.put(c, hashMapOfS.getOrDefault(c, 0) + 1);</span><br><span class="line">                if (hashMapOfS.get(c).equals(hashMapOfP.get(c)))&#123;</span><br><span class="line">                    flag++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (p.length() == right - left + 1)&#123;</span><br><span class="line">                if (flag == p.length())&#123;</span><br><span class="line">                    list.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                char c1 = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                if (hashMapOfP.containsKey(c1))&#123;</span><br><span class="line">                    if (hashMapOfS.get(c1).equals(hashMapOfP.get(c1)))&#123;</span><br><span class="line">                        flag--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hashMapOfS.put(c1, hashMapOfS.getOrDefault(c1, 0) - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为只有26个小写字母，所以可以利用26位长度的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">         List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(s.length() == 0 || p.length() == 0)</span><br><span class="line">            return ans;</span><br><span class="line">        int[] dict = new int[26];</span><br><span class="line">        for(int i = 0;i&lt;p.length();i++)&#123;</span><br><span class="line">            dict[p.charAt(i)-&#x27;a&#x27;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        int[] window = new int[26];</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = 0;</span><br><span class="line">        while(right&lt;s.length())&#123;</span><br><span class="line">            int curR = s.charAt(right)-&#x27;a&#x27;;</span><br><span class="line">            right++;</span><br><span class="line">            window[curR] += 1;</span><br><span class="line">            while(window[curR] &gt; dict[curR])&#123;</span><br><span class="line">                int curL = s.charAt(left)-&#x27;a&#x27;;</span><br><span class="line">                window[curL] -= 1;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(right - left == p.length())&#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="leetcode水果成篮904"><a href="#leetcode水果成篮904" class="headerlink" title="leetcode水果成篮904"></a>leetcode水果成篮904</h1><p>在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>你可以从你选择的任何树开始，然后重复执行以下步骤：</p><p>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。<br>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。<br>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p><p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p><p>用这个程序你能收集的水果树的最大总量是多少？ </p><p>示例 1：</p><p>输入：[1,2,1]<br>输出：3<br>解释：我们可以收集 [1,2,1]。<br>示例 2：</p><p>输入：[0,1,2,2]<br>输出：3<br>解释：我们可以收集 [1,2,2]<br>如果我们从第一棵树开始，我们将只能收集到 [0, 1]。<br>示例 3：</p><p>输入：[1,2,3,2,2]<br>输出：4<br>解释：我们可以收集 [2,3,2,2]<br>如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</p><p>解析：理解题目也就是两种类型的水果，求最多的数量。我们可以用一个map来存储类型和数量。何时left移动？当map的size大于2，也就是此时map中存在不止两种类型水果时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int totalFruit(int[] fruits)&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">       int left = 0, right = 0;</span><br><span class="line">       int ans = 0;</span><br><span class="line">       while (right &lt; fruits.length)&#123;</span><br><span class="line">           int fruit = fruits[right];</span><br><span class="line">           hashMap.put(fruit, hashMap.getOrDefault(fruit, 0) + 1);</span><br><span class="line">           while (hashMap.size() &gt; 2)&#123;</span><br><span class="line">               int leftFruit = fruits[left];</span><br><span class="line">               hashMap.put(leftFruit, hashMap.get(leftFruit) - 1);</span><br><span class="line">               if (hashMap.get(leftFruit) == 0)&#123;</span><br><span class="line">                   hashMap.remove(leftFruit);</span><br><span class="line">               &#125;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           ans = Math.max(ans, right - left + 1);</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode930-：和相同的二元子数组"><a href="#leetcode930-：和相同的二元子数组" class="headerlink" title="leetcode930,：和相同的二元子数组"></a>leetcode930,：和相同的二元子数组</h1><p>给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。</p><p>子数组 是数组的一段连续部分。</p><p>示例 1：</p><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]<br>示例 2：</p><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-8</title>
      <link href="2021/07/08/7-8/"/>
      <url>2021/07/08/7-8/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode930：和相同的二元子数组"><a href="#leetcode930：和相同的二元子数组" class="headerlink" title="leetcode930：和相同的二元子数组"></a>leetcode930：和相同的二元子数组</h1><p>题目描述：给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。</p><p>子数组 是数组的一段连续部分。</p><p>示例 1：</p><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>示例 2：</p><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p><p>解析：有点滑动窗口的味道。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart</title>
      <link href="2021/07/08/Dart/"/>
      <url>2021/07/08/Dart/</url>
      
        <content type="html"><![CDATA[<h1 id="Dart介绍"><a href="#Dart介绍" class="headerlink" title="Dart介绍"></a>Dart介绍</h1><p>Dart是由谷歌开发的计算机编程语言,它可以被用于web、服务器、移动应用 和物联网等领域的开发。Dart诞生于2011年，号称要取代JavaScript。但是过去的几年中一直不温不火。直到Flutter的出现现在被人们重新重视。要学Flutter的话我们必须首先得会Dart。</p><h1 id="Dart入口方法、变量、常量、命名规则"><a href="#Dart入口方法、变量、常量、命名规则" class="headerlink" title="Dart入口方法、变量、常量、命名规则"></a>Dart入口方法、变量、常量、命名规则</h1><h6 id="Dart变量："><a href="#Dart变量：" class="headerlink" title="Dart变量："></a>Dart变量：</h6><p>dart是一个强大的脚本类语言，可以不预先定义变量类型 ，自动会类型推倒。  dart中定义变量可以通过var关键字可以通过类型来申明变量，也可以直接通过变量类型进行定义。</p><p>Dart有类型校验：就是定义的字符串不能赋其他类型的值。</p><p>注意： var 后就不要写类型 ，  写了类型 不要var   两者都写   var  a int  = 5;  报错</p><h6 id="Dart常量：-final-和-const修饰符"><a href="#Dart常量：-final-和-const修饰符" class="headerlink" title="Dart常量： final 和 const修饰符"></a>Dart常量： final 和 const修饰符</h6><p>const值不变 一开始就得赋值， </p><p>final 可以开始不赋值 只能赋一次 ;</p><p>而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final a=new DateTime.now();</span><br><span class="line">print(a);   //2019-05-10 15:59:02.966122</span><br><span class="line"></span><br><span class="line">//const a=new DateTime.now();   //报错了</span><br></pre></td></tr></table></figure><p>永远不改量的量，请使用final或const修饰它，而不是使用var或其他变量类型。</p><h6 id="入口方法："><a href="#入口方法：" class="headerlink" title="入口方法："></a>入口方法：</h6><p>第一种定义方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main（）&#123;</span><br><span class="line">print（&#x27;hello Dart&#x27;）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种定义方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">print(&#x27;你好 Dart&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="命名规则："><a href="#命名规则：" class="headerlink" title="命名规则："></a>命名规则：</h6><p>Dart的命名规则：</p><pre><code>      1、变量名称必须由数字、字母、下划线和美元符($)组成。      2.注意：标识符开头不能是数字      3.标识符不能是保留字和关键字。         4.变量的名字是区分大小写的如: age和Age是不同的变量。在实际的运用中,也建议,不要用一个单词大小写区分两个变量。          5、标识符(变量名称)一定要见名思意 ：变量名称建议用名词，方法名称建议用动词  </code></pre><h1 id="Dart数据类型"><a href="#Dart数据类型" class="headerlink" title="Dart数据类型"></a>Dart数据类型</h1><h6 id="常用数据类型："><a href="#常用数据类型：" class="headerlink" title="常用数据类型："></a>常用数据类型：</h6><p> Numbers（数值）:<br>          int<br>          double<br>      Strings（字符串）<br>          String<br>      Booleans(布尔)<br>          bool<br>      List（数组）<br>          在Dart中，数组是列表对象，所以大多数人只是称它们为列表<br>      Maps（字典）<br>          通常来说，Map 是一个键值对相关的对象。 键和值可以是任何类型的对象。每个 键 只出现一次， 而一个值则可以出现多次</p><p>  项目中用不到的数据类型 （用不到）：<br>      Runes<br>        Rune是UTF-32编码的字符串。它可以通过文字转换成符号表情或者代表特定的文字。</p><p>Symbols<br>        Symbol对象表示在Dart程序中声明的运算符或标识符。您可能永远不需要使用符号，但它们对于按名称引用标识符的API非常有用，因为缩小会更改标识符名称而不会更改标识符符号。要获取标识符的符号，请使用符号文字，它只是＃后跟标识符：在Dart中符号用#开头表示。</p><h6 id="字符串类型："><a href="#字符串类型：" class="headerlink" title="字符串类型："></a>字符串类型：</h6><p>定义的几种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &#x27;str1&#x27;;</span><br><span class="line">var str2 = &quot;str2&quot;;</span><br><span class="line">在Dart中字符串用单引号和双引号都可以</span><br><span class="line">String str1 = &#x27;str1&#x27;;</span><br><span class="line">String str2 = &quot;str2&quot;;</span><br><span class="line"></span><br><span class="line">String str3 = &#x27;&#x27;&#x27;str1</span><br><span class="line">str2</span><br><span class="line">str3&#x27;&#x27;&#x27;</span><br><span class="line">三个单引号会保留之间的所有内容，原样输出。类似于kotlin中</span><br></pre></td></tr></table></figure><p>字符串的拼接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1=&#x27;你好&#x27;;</span><br><span class="line"></span><br><span class="line">  String str2=&#x27;Dart&#x27;;</span><br><span class="line">  </span><br><span class="line">//kotlin中的字符串模板，双引号中的变量之前加上$，会输出对应的变量</span><br><span class="line">  print(&quot;$str1 $str2&quot;);</span><br><span class="line"></span><br><span class="line">//java中的“+”，实现的字符串拼接</span><br><span class="line">  print(str1 + str2);</span><br><span class="line">//同上</span><br><span class="line">  print(str1 +&quot; &quot;+ str2);</span><br></pre></td></tr></table></figure><h6 id="数值类型：int、"><a href="#数值类型：int、" class="headerlink" title="数值类型：int、"></a>数值类型：int、</h6><p>int：必须是整形</p><p>double：可以是整形，也可以是浮点型</p><h6 id="布尔类型：bool"><a href="#布尔类型：bool" class="headerlink" title="布尔类型：bool"></a>布尔类型：bool</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag = true;</span><br><span class="line">var flag = false;</span><br></pre></td></tr></table></figure><h6 id="List-数组-集合-："><a href="#List-数组-集合-：" class="headerlink" title="List(数组/集合)："></a>List(数组/集合)：</h6><p>定义list的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">var list1 = [&quot;张三&quot;, 20, true];</span><br><span class="line">第二种：指定类型</span><br><span class="line">var list2 = &lt;String&gt;[&quot;张三&quot;, &quot;李四&quot;];</span><br><span class="line">var list2 = &lt;int&gt;[12, 30];</span><br><span class="line">第三种：通过[]创建的集合，容量可以变化。上述的两种方式容量就可以变化</span><br><span class="line">var list3 = [];</span><br><span class="line">list3.add(&quot;张三&quot;);</span><br><span class="line">第四种：</span><br><span class="line">var list4 = new List();//在新版本的dart中无法使用这个方法</span><br><span class="line">var list5 = List.filled(5, &quot;&quot;);//创建一个固定长度的集合</span><br><span class="line">创建了固定长度的集合之后，只能修改，不能添加了，也不能修改集合的长度。</span><br></pre></td></tr></table></figure><h6 id="Map：字典"><a href="#Map：字典" class="headerlink" title="Map：字典"></a>Map：字典</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//第一种定义 Maps的方式</span><br><span class="line"></span><br><span class="line">    // var person=&#123;</span><br><span class="line">    //   &quot;name&quot;:&quot;张三&quot;,</span><br><span class="line">    //   &quot;age&quot;:20,</span><br><span class="line">    //   &quot;work&quot;:[&quot;程序员&quot;,&quot;送外卖&quot;]</span><br><span class="line">    // &#125;;</span><br><span class="line"></span><br><span class="line">    // print(person);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;age&quot;]);</span><br><span class="line"></span><br><span class="line">    // print(person[&quot;work&quot;]);</span><br><span class="line"></span><br><span class="line">   //第二种定义 Maps的方式</span><br><span class="line"></span><br><span class="line">    var p=new Map();</span><br><span class="line"></span><br><span class="line">    p[&quot;name&quot;]=&quot;李四&quot;;</span><br><span class="line">    p[&quot;age&quot;]=22;</span><br><span class="line">    p[&quot;work&quot;]=[&quot;程序员&quot;,&quot;送外卖&quot;];</span><br><span class="line">    print(p);</span><br><span class="line"></span><br><span class="line">    print(p[&quot;age&quot;]);</span><br></pre></td></tr></table></figure><p>类型判断：is关键词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// var str=&#x27;1234&#x27;;</span><br><span class="line"></span><br><span class="line">  // if(str is String)&#123;</span><br><span class="line">  //   print(&#x27;是string类型&#x27;);</span><br><span class="line">  // &#125;else if(str is int)&#123;</span><br><span class="line"></span><br><span class="line">  //    print(&#x27;int&#x27;);</span><br><span class="line">  // &#125;else&#123;</span><br><span class="line">  //    print(&#x27;其他类型&#x27;);</span><br><span class="line">  // &#125;</span><br></pre></td></tr></table></figure><h1 id="运算符-类型转换"><a href="#运算符-类型转换" class="headerlink" title="运算符+类型转换"></a>运算符+类型转换</h1><h6 id="运算符和类型转换："><a href="#运算符和类型转换：" class="headerlink" title="运算符和类型转换："></a>运算符和类型转换：</h6><p>算术运算符</p><pre><code>  +    -    *    /     ~/ (取整)     %（取余）  关系运算符  ==    ！=   &gt;    &lt;    &gt;=    &lt;=逻辑运算符    !（取反）  &amp;&amp;（且，全真才真）   ||（或，全假才为假）赋值运算符 基础赋值运算符   =   ??=（b??=23，表示b为空的话，把23赋值给它） 复合赋值运算符   +=  -=  *=   /=   %=  ~/= 自增自减运算符：++，--++  --   表示自增 自减 1    在赋值运算里面 如果++ -- 写在前面 这时候先运算 再赋值，如果++ --写在后面 先赋值后运行运算条件表达式     if  else   switch case     三目运算符    ??运算符：如果为空              // var a;              // var b= a ?? 10;              // print(b);   10</code></pre><p>​<br>                  var a=22;<br>                  var b= a ?? 10;</p><pre><code>              print(b); //22</code></pre><p>2、类型转换</p><pre><code>1、Number与String类型之间的转换2、其他类型转换成Booleans类型</code></pre><p>  1、Number与String类型之间的转换</p><pre><code>  // Number类型转换成String类型 toString()  // String类型转成Number类型  int.parse()，double.parse()</code></pre><p>2、其他类型转换成Booleans类型</p><pre><code>    // isEmpty:判断字符串是否为空</code></pre><h6 id="break和continue："><a href="#break和continue：" class="headerlink" title="break和continue："></a>break和continue：</h6><p>break语句功能:<br>          1、在switch语句中使流程跳出switch结构。<br>          2、在循环语句中使流程跳出当前循环,遇到break 循环终止，后面代码也不会执行</p><pre><code>      强调:      1、如果在循环中已经执行了break语句,就不会执行循环体中位于break后的语句。      2、在多层循环中,一个break语句只能向外跳出一层    break可以用在switch case中 也可以用在 for 循环和 while循环中  continue语句的功能:              【注】只能在循环语句中使用,使本次循环结束，即跳过循环体重下面尚未执行的语句，接着进行下次的是否执行循环的判断。    continue可以用在for循环以及 while循环中，但是不建议用在while循环中，不小心容易死循环</code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h6 id="for基本语法"><a href="#for基本语法" class="headerlink" title="for基本语法"></a>for基本语法</h6><p>​          for (int i = 1; i&lt;=100; i++) {<br>​            print(i);<br>​          }</p><pre><code>        //第一步，声明变量int i = 1;        //第二步，判断i &lt;=100        //第三步，print(i);        //第四步，i++        //第五步 从第二步再来，直到判断为false</code></pre><h6 id="while语法格式"><a href="#while语法格式" class="headerlink" title="while语法格式:"></a>while语法格式:</h6><pre><code>    while(表达式/循环条件)&#123;                        &#125;        do&#123;        语句/循环体            &#125;while(表达式/循环条件);        注意： 1、最后的分号不要忘记            2、循环条件中使用的变量需要经过初始化          3、循环体中，应有结束循环的条件，否则会造成死循环。</code></pre><p> while 和 do while的区别   第一次循环条件不成立的情况下</p><p>​    // int i=10;<br>​      // while(i&lt;2){<br>​      //     print(‘执行代码’);<br>​      // }</p><pre><code>  var j=10;        do&#123;      print(&#39;执行代码&#39;);  &#125;while(j&lt;2);</code></pre><h1 id="Dart集合类型以及循环语句"><a href="#Dart集合类型以及循环语句" class="headerlink" title="Dart集合类型以及循环语句"></a>Dart集合类型以及循环语句</h1><h6 id="List集合："><a href="#List集合：" class="headerlink" title="List集合："></a>List集合：</h6><p>List里面常用的属性和方法：</p><pre><code>常用属性：    length          长度    reversed        翻转    isEmpty         是否为空    isNotEmpty      是否不为空常用方法：      add         增加    addAll      拼接数组    indexOf     查找  传入具体值    remove      删除  传入具体值    removeAt    删除  传入索引值    fillRange   修改       insert(index,value);            指定位置插入        insertAll(index,list)           指定位置插入List    toList()    其他类型转换成List      join()      List转换成字符串    split()     字符串转化成List    forEach       map    where    any    every</code></pre><h6 id="Set集合："><a href="#Set集合：" class="headerlink" title="Set集合："></a>Set集合：</h6><p>用它最主要的功能就是去除数组重复内容</p><p>Set是没有顺序且不能重复的集合，所以不能通过索引去获取值</p><h6 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h6><p>映射(Maps)是无序的键值对：</p><pre><code>常用属性：    keys            获取所有的key值    values          获取所有的value值    isEmpty         是否为空    isNotEmpty      是否不为空常用方法:    remove(key)     删除指定key的数据    addAll(&#123;...&#125;)   合并映射  给映射内增加属性    containsValue   查看映射内的值  返回true/false    forEach       map    where    any    every</code></pre><h6 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// for(var i=0;i&lt;myList.length;i++)&#123;</span><br><span class="line">     //   print(myList[i]);</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // for(var item in myList)&#123;</span><br><span class="line">     //   print(item);</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // myList.forEach((value)&#123;</span><br><span class="line">     //     print(&quot;$value&quot;);</span><br><span class="line">     // &#125;);</span><br></pre></td></tr></table></figure><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4];      </span><br><span class="line">     // var newList=myList.map((value)&#123;</span><br><span class="line">     //     return value*2;</span><br><span class="line">     // &#125;);</span><br><span class="line">     //  print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="where："><a href="#where：" class="headerlink" title="where："></a>where：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">    // var newList=myList.where((value)&#123;</span><br><span class="line">    //     return value&gt;5;</span><br><span class="line">    // &#125;);</span><br><span class="line">    // print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="any："><a href="#any：" class="headerlink" title="any："></a>any：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">    // var f=myList.any((value)&#123;   //只要集合里面有满足条件的就返回true</span><br><span class="line"></span><br><span class="line">    //     return value&gt;5;</span><br><span class="line">    // &#125;);</span><br><span class="line">    // print(f);</span><br></pre></td></tr></table></figure><h6 id="every："><a href="#every：" class="headerlink" title="every："></a>every：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// List myList=[1,3,4,5,7,8,9];</span><br><span class="line"></span><br><span class="line">      // var f=myList.every((value)&#123;   //每一个都满足条件返回true  否则返回false</span><br><span class="line"></span><br><span class="line">      //     return value&gt;5;</span><br><span class="line">      // &#125;);</span><br><span class="line">      // print(f);</span><br></pre></td></tr></table></figure><h6 id="set："><a href="#set：" class="headerlink" title="set："></a>set：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// set</span><br><span class="line"></span><br><span class="line">// var s=new Set();</span><br><span class="line"></span><br><span class="line">// s.addAll([1,222,333]);</span><br><span class="line"></span><br><span class="line">// s.forEach((value)=&gt;print(value));</span><br></pre></td></tr></table></figure><h6 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map person=&#123;</span><br><span class="line">      &quot;name&quot;:&quot;张三&quot;,</span><br><span class="line">      &quot;age&quot;:20</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    person.forEach((key,value)&#123;            </span><br><span class="line">        print(&quot;$key---$value&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>  内置方法/函数：</p><pre><code>  print();</code></pre><p>  自定义方法：<br>      自定义方法的基本格式：</p><pre><code>  返回类型  方法名称（参数1，参数2,...）&#123;    方法体    return 返回值;    //可以在这里在定义一个函数，也就是允许函数嵌套  &#125;</code></pre><p>dart中的方法可以嵌套：演示方法作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//演示方法的作用域</span><br><span class="line">//全局作用域</span><br><span class="line">List getList()&#123;</span><br><span class="line"></span><br><span class="line">  return [&#x27;111&#x27;,&#x27;2222&#x27;,&#x27;333&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">  void xxx()&#123;</span><br><span class="line">//局部作用域</span><br><span class="line">      aaa()&#123;</span><br><span class="line"></span><br><span class="line">          print(getList());</span><br><span class="line">          print(&#x27;aaa&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      aaa();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // aaa();  错误写法 </span><br></pre></td></tr></table></figure><p>例一：int sunNum(int n){</p><p>}</p><p>例二：// String printUserInfo(String username, int age) {<br>  //   //行参<br>  //   return “姓名:$username—年龄:$age”;<br>  // }</p><p>  // print(printUserInfo(‘张三’, 20)); //实参</p><p>例三：定义一个带可选参数的方法，最新的dart定义可选参数需要指定类型默认值</p><p>String printUserInfo(String username,[int age， String sex]){  //可选参数age、sex<br>     if(age!=null){<br>       return “姓名:$username—年龄:$age”;<br>     }<br>     return “姓名:$username—年龄保密”;<br>   }<br>   print(printUserInfo(‘张三’,21)); //实参<br>   print(printUserInfo(‘张三’));</p><p>例四：带默认参数，</p><p>String printUserInfo(String username,[String sex=’男’,int age]){  //默认参数sex、可选参数age。注意顺序<br>  //   if(age!=0){<br>  //     return “姓名:$username—性别:$sex–年龄:$age”;<br>  //   }<br>  //   return “姓名:$username—性别:$sex–年龄保密”;<br>  // }<br>  // print(printUserInfo(‘张三’));<br>  // print(printUserInfo(‘小李’,’女’));<br>  // print(printUserInfo(‘小李’,’女’,30));</p><p>例五：定义一个命名参数的方法，最新的dart定义命名参数需要指定类型默认值</p><p>  // String printUserInfo(String username, {int age = 0, String sex = ‘男’}) {//行参<br>  //   if (age != 0) {<br>  //     return “姓名:$username—性别:$sex–年龄:$age”;<br>  //   }<br>  //   return “姓名:$username—性别:$sex–年龄保密”;<br>  // }<br>  // print(printUserInfo(‘张三’, age: 20, sex: ‘未知’));</p><p>例六：方法作为另一个方法的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// var fn=()&#123;</span><br><span class="line"></span><br><span class="line">  //   print(&#x27;我是一个匿名方法&#x27;);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // fn();</span><br><span class="line"></span><br><span class="line">  //方法</span><br><span class="line">  fn1() &#123;</span><br><span class="line">    print(&#x27;fn1&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //方法</span><br><span class="line">  fn2(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //调用fn2这个方法 把fn1这个方法当做参数传入</span><br><span class="line">  fn2(fn1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="箭头函数："><a href="#箭头函数：" class="headerlink" title="箭头函数："></a>箭头函数：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">/*需求：使用forEach打印下面List里面的数据*/</span><br><span class="line"></span><br><span class="line">  // List list=[&#x27;苹果&#x27;,&#x27;香蕉&#x27;,&#x27;西瓜&#x27;];</span><br><span class="line">  // list.forEach((value)&#123;</span><br><span class="line">  //   print(value);</span><br><span class="line">  // &#125;);</span><br><span class="line"></span><br><span class="line">  // list.forEach((value)=&gt;print(value));</span><br><span class="line"></span><br><span class="line">  //注意和方法的区别: 箭头函数内只能写一条语句，并且语句后面没有分号(;)</span><br><span class="line">  // list.forEach((value)=&gt;&#123;</span><br><span class="line">  //   print(value)</span><br><span class="line">  // &#125;);</span><br><span class="line"></span><br><span class="line">/*需求：修改下面List里面的数据，让数组中大于2的值乘以2*/</span><br><span class="line"></span><br><span class="line">  // List list=[4,1,2,3,4];</span><br><span class="line">  // var newList=list.map((value)&#123;</span><br><span class="line">  //     if(value&gt;2)&#123;</span><br><span class="line">  //       return value*2;</span><br><span class="line">  //     &#125;</span><br><span class="line">  //     return value;</span><br><span class="line"></span><br><span class="line">  // &#125;);</span><br><span class="line">  // print(newList.toList());</span><br><span class="line"></span><br><span class="line">  //  var newList=list.map((value)=&gt;value&gt;2?value*2:value);</span><br><span class="line">  //  print(newList.toList());</span><br></pre></td></tr></table></figure><h6 id="函数的相互调用："><a href="#函数的相互调用：" class="headerlink" title="函数的相互调用："></a>函数的相互调用：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">需求：    1、定义一个方法isEvenNumber来判断一个数是否是偶数  </span><br><span class="line">         2、定义一个方法打印1-n以内的所有偶数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 1、定义一个方法isEvenNumber来判断一个数是否是偶数  </span><br><span class="line">  bool isEvenNumber(int n) &#123;</span><br><span class="line">    if (n % 2 == 0) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">//  2、定义一个方法打印1-n以内的所有偶数</span><br><span class="line">  printNum(int n) &#123;</span><br><span class="line">    for (var i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">      if (isEvenNumber(i)) &#123;</span><br><span class="line">        print(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printNum(10);//打印1-10以内的所有函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="匿名方法："><a href="#匿名方法：" class="headerlink" title="匿名方法："></a>匿名方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int getNum(int n) &#123;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // print(getNum(12));</span><br><span class="line"></span><br><span class="line">  //匿名方法</span><br><span class="line"></span><br><span class="line">  // var printNum=()&#123;</span><br><span class="line">  //   print(123);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // printNum();</span><br><span class="line"></span><br><span class="line">  // var printNum=(int n)&#123;</span><br><span class="line">  //   print(n+2);</span><br><span class="line">  // &#125;;</span><br><span class="line">  // printNum(12);</span><br></pre></td></tr></table></figure><h6 id="自执行方法："><a href="#自执行方法：" class="headerlink" title="自执行方法："></a>自执行方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((int n)&#123;</span><br><span class="line">  //   print(n);</span><br><span class="line">  //   print(&#x27;我是自执行方法&#x27;);</span><br><span class="line">  // &#125;)(12);</span><br></pre></td></tr></table></figure><h6 id="方法递归："><a href="#方法递归：" class="headerlink" title="方法递归："></a>方法递归：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// var sum = 1;</span><br><span class="line"> // fn(int n) &#123;</span><br><span class="line"> //   sum *= n;</span><br><span class="line"> //   if (n == 1) &#123;</span><br><span class="line"> //     return;</span><br><span class="line"> //   &#125;</span><br><span class="line"> //   fn(n - 1);</span><br><span class="line"> // &#125;</span><br><span class="line"></span><br><span class="line"> // fn(5);</span><br><span class="line"> // print(sum);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> var sum=0;</span><br><span class="line"> fn(int n)&#123;</span><br><span class="line">     sum+=n;</span><br><span class="line">     if(n==0)&#123;</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">     fn(n-1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(100);</span><br><span class="line"> print(sum);</span><br></pre></td></tr></table></figure><h6 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h6><p>  1、全局变量特点:    全局变量常驻内存、全局变量污染全局<br>  2、局部变量的特点：  不常驻内存会被垃圾机制回收、不会污染全局  </p><p>  /*  想实现的功能：</p><p>​    1.常驻内存<br>​    2.不污染全局   </p><p>​      产生了闭包,闭包可以解决这个问题…..  </p><p>​      闭包: 函数嵌套函数, 内部函数会调用外部函数的变量或参数, 变量或参数不会被系统回收(不会释放内存)</p><p>​      闭包的写法： 函数嵌套函数，并return 里面的函数，这样就形成了闭包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*全局变量*/</span><br><span class="line">var a = 123;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // print(a);</span><br><span class="line"></span><br><span class="line">  // fn()&#123;</span><br><span class="line">  //   a++;</span><br><span class="line">  //   print(a);</span><br><span class="line">  // &#125;</span><br><span class="line">  // fn();</span><br><span class="line">  // fn();</span><br><span class="line">  // fn();</span><br><span class="line"></span><br><span class="line">//局部变量</span><br><span class="line">  // printInfo() &#123;</span><br><span class="line">  //   var myNum = 123;</span><br><span class="line">  //   myNum++;</span><br><span class="line">  //   print(myNum);</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // printInfo();</span><br><span class="line">  // printInfo();</span><br><span class="line">  // printInfo();</span><br><span class="line"></span><br><span class="line">//闭包</span><br><span class="line"></span><br><span class="line">  fn() &#123;</span><br><span class="line">    var a = 123; /*不会污染全局   常驻内存*/</span><br><span class="line">    return () &#123;</span><br><span class="line">      a++;</span><br><span class="line">      print(a);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var b = fn();</span><br><span class="line">  b();</span><br><span class="line">  b();</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象编程(OOP)的三个基本特征是：封装、继承、多态      </p><p>  封装：封装是对象和类概念的主要特性。封装，把客观事物封装成抽象的类，并且把自己的部分属性和方法提供给其他对象调用, 而一部分属性和方法则隐藏。</p><p>  继承：面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>  多态：允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。</p><p>Dart所有的东西都是对象，所有的对象都继承自Object类。</p><p>Dart是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是Object的子类</p><p>一个类通常由属性和方法组成。</p><h6 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h6><p>Dart是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是Object的子类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  String name=&quot;张三&quot;;</span><br><span class="line">  int age=23;</span><br><span class="line">  void getInfo()&#123;</span><br><span class="line">      // print(&quot;$name----$age&quot;);</span><br><span class="line">      print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void setInfo(int age)&#123;</span><br><span class="line">    this.age=age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">  //实例化</span><br><span class="line"></span><br><span class="line">  // var p1=new Person();</span><br><span class="line">  // print(p1.name);</span><br><span class="line">  // p1.getInfo();</span><br><span class="line"></span><br><span class="line">  Person p1=new Person();</span><br><span class="line">  // print(p1.name);</span><br><span class="line"></span><br><span class="line">  p1.setInfo(28);</span><br><span class="line">  p1.getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// class Person&#123;</span><br><span class="line">//   String name=&#x27;张三&#x27;;</span><br><span class="line">//   int age=20; </span><br><span class="line">//   //默认构造函数</span><br><span class="line">   Person()&#123;</span><br><span class="line">     print(&#x27;这是构造函数里面的内容  这个方法在实例化的时候触发&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line">Person(String name, int age)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//上边构造函数的简写</span><br><span class="line">Person(this.name, this.age);</span><br><span class="line">//   void printInfo()&#123;   </span><br><span class="line">//     print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命名构造函数：</span><br><span class="line">class Person&#123;</span><br><span class="line">String name;</span><br><span class="line">int age ;</span><br><span class="line">//默认构造函数</span><br><span class="line">Person(String name, int age)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//命名构造函数</span><br><span class="line">Person.now()&#123;</span><br><span class="line">print(&#x27;我是命名构造函数&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">Person.setInfo(String name, int age)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">void printInfo()&#123;   </span><br><span class="line">     print(&quot;$&#123;this.name&#125;----$&#123;this.age&#125;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main&#123;</span><br><span class="line">Person p1 = new Person(&#x27;张三&#x27;, 20);//调用的默认构函数</span><br><span class="line">Person p2 = new Person.now();//调用的命名构造函数</span><br><span class="line">&#125;</span><br><span class="line">默认构造函数只能有一个，命名构造函数可以有多个</span><br></pre></td></tr></table></figure><p>import ‘lib/Person.dart’;//导入类</p><h6 id="私有方法、私有属性"><a href="#私有方法、私有属性" class="headerlink" title="私有方法、私有属性"></a>私有方法、私有属性</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Dart和其他面向对象语言不一样，Data中没有 public  private protected这些访问修饰符合</span><br><span class="line"></span><br><span class="line">但是我们可以使用_把一个属性或者方法定义成私有。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;lib/Animal.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"> </span><br><span class="line"> Animal a=new Animal(&#x27;小狗&#x27;, 3);</span><br><span class="line"></span><br><span class="line"> print(a.getName());</span><br><span class="line"></span><br><span class="line"> a.execRun();   //间接的调用私有方法</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">加了下划线，如果在同一个文件中也是能够访问到的。也可以在私有属性的类中定义方法，在另一个文件中通过方法访问</span><br><span class="line">私有方法只能在当前类中访问，也可以通过公共方法（公共方法中调用了私有方法），然后调用公共方法来访问</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="getter和setter方法："><a href="#getter和setter方法：" class="headerlink" title="getter和setter方法："></a>getter和setter方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rect&#123;</span><br><span class="line">  late num height;</span><br><span class="line">  late num width;   </span><br><span class="line">  Rect(this.height,this.width);</span><br><span class="line">  get area&#123;</span><br><span class="line">    return this.height*this.width;</span><br><span class="line">  &#125;</span><br><span class="line">  set areaHeight(value)&#123;</span><br><span class="line">    this.height=value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  Rect r=new Rect(10,4);</span><br><span class="line">  // print(&quot;面积:$&#123;r.area()&#125;&quot;);   </span><br><span class="line">  r.areaHeight=6;</span><br><span class="line"></span><br><span class="line">  print(r.area);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">get和set相当于一个计算属性，只是没有方法后边的括号。</span><br></pre></td></tr></table></figure><h6 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Dart中我们也可以在构造函数体运行之前初始化实例变量</span><br><span class="line"></span><br><span class="line">class Rect&#123;</span><br><span class="line">  int height;</span><br><span class="line">  int width;</span><br><span class="line">  Rect():height=2,width=10&#123;</span><br><span class="line">    </span><br><span class="line">    print(&quot;$&#123;this.height&#125;---$&#123;this.width&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  getArea()&#123;</span><br><span class="line">    return this.height*this.width;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  Rect r=new Rect();</span><br><span class="line">  print(r.getArea());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-7</title>
      <link href="2021/07/07/7-7/"/>
      <url>2021/07/07/7-7/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode大餐计数1711"><a href="#leetcode大餐计数1711" class="headerlink" title="leetcode大餐计数1711"></a>leetcode大餐计数1711</h1><p>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 任意 两道餐品做一顿大餐。</p><p>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><p>示例 1：</p><p>输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。<br>示例 2：</p><p>输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</p><h6 id="思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness-i-相加成为2的幂。"><a href="#思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness-i-相加成为2的幂。" class="headerlink" title="思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness[i]相加成为2的幂。"></a>思路：1、第一个for循环遍历数组，在遍历到当前i下标的时候，检查后边的每一个数是否可以和当前deliciousness[i]相加成为2的幂。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int countPairs(int[] deliciousness)&#123;</span><br><span class="line">    List&lt;Double&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; deliciousness.length; i++)&#123;</span><br><span class="line">        for (int j = i + 1; j &lt; deliciousness.length; j++)&#123;</span><br><span class="line">            int k = deliciousness[i] +deliciousness[j];</span><br><span class="line">            //判断某一个数是否为2的次幂</span><br><span class="line">            //(number &amp; number - 1) == 0</span><br><span class="line">            if ((k &amp; (k - 1)) == 0 &amp;&amp; k != 0)&#123;</span><br><span class="line">                list.add(k % ((Math.pow(10, 9)) + 7));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为o（n^2）,</p><h6 id="判断某一个数是否为2的次幂："><a href="#判断某一个数是否为2的次幂：" class="headerlink" title="判断某一个数是否为2的次幂："></a>判断某一个数是否为2的次幂：</h6><p> 1、将2的幂次方写成二进制形式后，很容易就会发现有一个特点：二进制中只有一个1，并且1后面跟了n个0； 因此问题可以转化为判断1后面是否跟了n个0就可以了。</p><pre><code>    如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零。   最快速的方法：  (number &amp; number - 1) == 0</code></pre><p>2、看的宫水三叶<a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/</a></p><p>插入一小段话，我是偶然发现了宝藏姐姐的公众号，然后无法自拔，然后每天都有关注公众号和三叶的leetcode。每当看到大佬的解法总是无比的崇拜，感叹自己怎么这么菜，但是每个人的成长总是披荆斩棘的，所以coding吧兄弟们。</p><p>判断某个数是否为2的次幂。</p><p>朴素做法对x应用试除法，因为精度问题，需要使用乘法实现试除。</p><p>另外一个优秀的做法是利用位运算找到符合【大于等于x】的最近的2的幂，然后判断是否与x相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean check(long x) &#123;</span><br><span class="line">        // 方法一</span><br><span class="line">        // long cur = 1;</span><br><span class="line">        // while (cur &lt; x) &#123;</span><br><span class="line">        //     cur = cur * 2;</span><br><span class="line">        // &#125;</span><br><span class="line">        // return cur == x;</span><br><span class="line">        </span><br><span class="line">        // 方法二</span><br><span class="line">        return getVal(x) == x;</span><br><span class="line">    &#125;</span><br><span class="line">    long getVal(long x) &#123;</span><br><span class="line">        long n = x - 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 2;</span><br><span class="line">        n |= n &gt;&gt;&gt; 4;</span><br><span class="line">        n |= n &gt;&gt;&gt; 8;</span><br><span class="line">        n |= n &gt;&gt;&gt; 16;</span><br><span class="line">        return n &lt; 0 ? 1 : n + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述的两个for循环解法存在重复计算。可以用哈希表记录某个数出现的次数，但是这种算法的时间复杂度还是o（n^2）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int countPairs(int[] deliciousness)&#123;</span><br><span class="line">        long ans = 0;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; deliciousness.length; i++)&#123;</span><br><span class="line">            int k = deliciousness[i];</span><br><span class="line">            for (int other : hashMap.keySet())&#123;</span><br><span class="line">                int z = k + other;</span><br><span class="line">                if ((z &amp; (z - 1)) == 0 &amp;&amp; z != 0)&#123;</span><br><span class="line">                    ans += hashMap.get(other);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(k, hashMap.getOrDefault(k, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) (ans % 10000007);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我的疑问：我一开始不明白为什么哈希表为什么是一边遍历一边统计的。</p><p>上边的第一种思路理解：枚举后边的数。对于一开始的两个for循环，我们对于第一个for循环，然后找当前位置后边的数，看两个数相加是否为2的幂。</p><p>另外一种思路：枚举前一个数。其实我们也可以理解为对于第一个for循环，我们找当前位置前边的数，看两个数相加是否为2的次幂。</p><h6 id="思路2：枚举2的幂（容斥原理）"><a href="#思路2：枚举2的幂（容斥原理）" class="headerlink" title="思路2：枚举2的幂（容斥原理）"></a>思路2：枚举2的幂（容斥原理）</h6><p>宫水三叶<a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-6</title>
      <link href="2021/07/06/7-6/"/>
      <url>2021/07/06/7-6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-5</title>
      <link href="2021/07/06/7-5/"/>
      <url>2021/07/06/7-5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-4</title>
      <link href="2021/07/06/7-4/"/>
      <url>2021/07/06/7-4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-1</title>
      <link href="2021/07/06/7-1/"/>
      <url>2021/07/06/7-1/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode07传递信息"><a href="#leetcode07传递信息" class="headerlink" title="leetcode07传递信息"></a>leetcode07传递信息</h1><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： </p><p> 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 </p><p>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</p><p>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 </p><p>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。  </p><p>示例 1：  输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3  输出：3  解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。  </p><p>示例 2：  输入：n = 3, relation = [[0,2],[2,1]], k = 2  输出：0  解释：信息不能从小 A 处经过 2 轮传递到编号 2</p><h6 id="解析：BFS、DFS、动态规划"><a href="#解析：BFS、DFS、动态规划" class="headerlink" title="解析：BFS、DFS、动态规划"></a>解析：BFS、DFS、动态规划</h6><p>BFS方法：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3</title>
      <link href="2021/07/03/7-3/"/>
      <url>2021/07/03/7-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 每日几题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2</title>
      <link href="2021/07/02/7-2/"/>
      <url>2021/07/02/7-2/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer：单链表、链表"><a href="#剑指offer：单链表、链表" class="headerlink" title="剑指offer：单链表、链表"></a>剑指offer：单链表、链表</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>androidSomething</title>
      <link href="2021/07/02/androidSomething/"/>
      <url>2021/07/02/androidSomething/</url>
      
        <content type="html"><![CDATA[<h1 id="something"><a href="#something" class="headerlink" title="something"></a>something</h1><p>要理解设计者意图，就需要抽象。我们需要在哲学意义空间中去考虑系统的描述，即系统在本质上要表达什么。在逻辑空间上去考虑系统基本构成和动态结构。从现实到虚拟对象的映射去理解系统对象的组成，在从数据流的角度分析数据的产生者和消费者之间作用关系，从控制流的角度去分析对象之间的交互关系，从函数调用去分析具体的层次关系。</p><p>在系统设计上，原型是最能表达哲学空间和逻辑空间中系统本质的东西，原型是事物本质的第一层体现。我以为任何复杂的系统都一个简洁的系统原型，都有它简洁的意义。系统原型是设计者意图的第一体现，所以我们需要从几个方向上去提炼系统原型：</p><p>（1）从系统本质和基本原理出发</p><p>（2）从分析系统数据流和控制流分析出发。</p><p>从设计者意图出发，得出系统原型，提取到大的逻辑结构和系统构成是第一步。之后我们可以从设计者的角度考虑系统猜想系统设计，为什么要这样设计，为什么要有这些构成。这样的基本原型是什么？系统的限制是什么，应用场景有哪些，有些设计的引进还是系统收敛性而为之呢。我们还可以从代码痕迹上去分析，这些概念是如何的得来的？从一定的抽象和高度去理解这些问题，遵循系统原型出发之原则，在深入分析代码的时候，就不容易陷入细节中。我们就可以随时跳出来想，这些代码在整体上载表达一个什么概念，在描绘一个什么逻辑，他要构成一个虚拟层吗？他是在管理这个硬件吗？他在虚拟这个对象吗？他在构建管理机构？还是在构建一个对象管理？空间管理，为了快速引入了什么样的复杂算法，实际上的原型算法应该是什么样的？</p><p>只有深入到这个抽象层次，我们才能很好的把握住系统的每一条线，每一个对象的意义。只用从原型出发，我们才能把握住这个系统的实质所在，在干什么？他要表达什么？设计者为什么要这样想？最终极的想法是什么？这样，代码分析就变得简单明了，读代码就变成了是在印证猜想，修正方向。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode图</title>
      <link href="2021/07/01/leetcode%E5%9B%BE/"/>
      <url>2021/07/01/leetcode%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeBFS</title>
      <link href="2021/06/30/leetcodeBFS/"/>
      <url>2021/06/30/leetcodeBFS/</url>
      
        <content type="html"><![CDATA[<h1 id="100-相同的树（简单）"><a href="#100-相同的树（简单）" class="headerlink" title="100.相同的树（简单）"></a>100.相同的树（简单）</h1><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>思路：BFS的非递归，需要用到队列数据结构。</p><p>​            <code>bfs</code> 一般我们不会去涉及，而且比较绕，之前我们唯一 <code>A</code> 过的用 <code>bfs</code> 递归的方式是层序遍历二叉树的时候可以用递归的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isSameTree(TreeNode p, TreeNode q)&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queueP = new LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queueQ = new LinkedList&lt;&gt;();</span><br><span class="line">    queueP.add(p);</span><br><span class="line">    queueQ.add(q);</span><br><span class="line">    while (queueP.size() == queueQ.size() &amp;&amp; !queueP.isEmpty() &amp;&amp; !queueQ.isEmpty())&#123;</span><br><span class="line">        int size = queueP.size();</span><br><span class="line">        while (size-- &gt; 0)&#123;</span><br><span class="line">            TreeNode nodeP = queueP.remove();</span><br><span class="line">            TreeNode nodeQ = queueQ.remove();</span><br><span class="line">            if (nodeP == null &amp;&amp; nodeQ != null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (nodeP != null &amp;&amp; nodeQ == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (nodeP != null &amp;&amp; nodeQ != null &amp;&amp; nodeP.val != nodeQ.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (nodeP == null &amp;&amp; nodeQ == null)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nodeP.left != null || nodeP.right != null)&#123;</span><br><span class="line">                queueP.add(nodeP.left);</span><br><span class="line">                queueP.add(nodeP.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (nodeQ.left != null || nodeQ.right != null)&#123;</span><br><span class="line">                queueQ.add(nodeQ.left);</span><br><span class="line">                queueQ.add(nodeQ.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (queueP.size() != queueQ.size())&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130.被围绕的区域"></a>130.被围绕的区域</h1><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p>输入：board = [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]<br>输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]<br>解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br>示例 2：</p><p>输入：board = [[“X”]]<br>输出：[[“X”]]</p><h1 id="LCP07-传递信息"><a href="#LCP07-传递信息" class="headerlink" title="LCP07.传递信息"></a>LCP07.传递信息</h1><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><p>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0<br>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。<br>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人<br>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p><p>示例 1：</p><p>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3</p><p>输出：3</p><p>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p><p>示例 2：</p><p>输入：n = 3, relation = [[0,2],[2,1]], k = 2</p><p>输出：0</p><p>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p><p>思路：n 和 k 的数据范围都很小，并且根据题目对 relation 的定义可以知道这是一个边权相等的图。</p><p>对于边权相等的图，统计有限步数的到达某个节点的方案数，最常见的方式是使用 BFS 或 DFS。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeDFS</title>
      <link href="2021/06/30/leetcodeDFS/"/>
      <url>2021/06/30/leetcodeDFS/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS和BFS："><a href="#DFS和BFS：" class="headerlink" title="DFS和BFS："></a>DFS和BFS：</h2><p><strong>1.数据结构上的运用</strong></p><p>DFS用递归的形式，用到了栈结构，先进后出。</p><p>BFS选取状态用队列的形式，先进先出。</p><p><strong>2.复杂度</strong></p><p>DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。</p><p><strong>3.思想</strong></p><p>思想上来说这两种方法都是穷竭列举所有的情况。</p><h1 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403.青蛙过河"></a>403.青蛙过河</h1><p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p><p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p><p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p><p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p>示例 1：</p><p>输入：stones = [0,1,3,5,6,8,12,17]<br>输出：true<br>解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。<br>示例 2：</p><p>输入：stones = [0,1,2,3,4,8,9,11]<br>输出：false<br>解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood动态规划相关题目</title>
      <link href="2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode22：括号生成"><a href="#leetcode22：括号生成" class="headerlink" title="leetcode22：括号生成"></a>leetcode22：括号生成</h1>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood链表相关题目</title>
      <link href="2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcood二叉树相关题目</title>
      <link href="2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcood%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode栈和队列相关题目</title>
      <link href="2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/30/leetcode%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode20：有效括号（栈可以解决）"><a href="#leetcode20：有效括号（栈可以解决）" class="headerlink" title="leetcode20：有效括号（栈可以解决）"></a>leetcode20：有效括号（栈可以解决）</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员代码面试指南第一章题目</title>
      <link href="2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/"/>
      <url>2021/06/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h1><h2 id="1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"><a href="#1-设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。" class="headerlink" title="1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。"></a>1.设计一个有getMin功能的栈，在栈的基本功能上，实现返回栈中最小元素的操作。</h2><p>思路：因为要返回栈中最小的元素，所以需要找个地方把最小的元素给存起来。这个存起来的过程涉及到判断最小的元素。</p><p>方法1：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​            压入规则：1、判断stackData是否为空。</p><p>​                                    1.1：为空，两个栈压入</p><p>​                                    1.2：不为空，stackData压入，然后判断压入数据和stackMin栈顶元素的大小，如果压入数据小或等于，也压入stackMin中。压入数据大于stackMin栈顶的元素，则不用压入。</p><p>​            弹出规则：压入规则的对应。</p><p>​            查询当前栈最小值的操作：stackMin保存着最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackNormal = new Stack();</span><br><span class="line">    Stack&lt;Integer&gt; stackSpecial = new Stack();</span><br><span class="line">//构造函数</span><br><span class="line">    public GetMin() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GetMin(Stack&lt;Integer&gt; stackNormal, Stack&lt;Integer&gt; stackSpecial) &#123;</span><br><span class="line">        this.stackNormal = stackNormal;</span><br><span class="line">        this.stackSpecial = stackSpecial;</span><br><span class="line">    &#125;</span><br><span class="line">//压入规则</span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">       stackNormal.push(input);</span><br><span class="line">       if (stackSpecial.size() == 0)&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stackSpecial.size() != 0 &amp;&amp; input &lt;= stackSpecial.peek())&#123;</span><br><span class="line">           stackSpecial.push(input);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//弹出规则</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stackNormal.pop();</span><br><span class="line">        if (value == stackSpecial.peek())&#123;</span><br><span class="line">            stackSpecial.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">//查询规则</span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackSpecial.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackSpecial.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：用两个栈、一个栈stackData实现正常的功能，另一个栈stackMin用来保存最小的元素。</p><p>​        压入规则：先判断stackData栈是否为空，为空的话两个栈同时压入。</p><p>​                            不为空：stackData压入数据，然后判断压入的数据和stackMin栈顶的元素的大小。如果大于stackMin栈顶的元素，stackMin再次压入当前栈顶的元素，如果小于stackMin栈顶的元素，则也直接压入stackMin。</p><p>​        弹出规则：压入规则的对应</p><p>​        查询规则：stackMin栈的栈顶元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class GetMin2 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackData = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackMin = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public GetMin2(Stack&lt;Integer&gt; stackData, Stack&lt;Integer&gt; stackMin) &#123;</span><br><span class="line">        this.stackData = stackData;</span><br><span class="line">        this.stackMin = stackMin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int input)&#123;</span><br><span class="line">        stackData.push(input);</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            stackMin.push(input);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (input &lt;= stackMin.peek())&#123;</span><br><span class="line">                stackMin.push(input);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stackMin.push(stackMin.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if (stackData.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stackMin.pop();</span><br><span class="line">        return stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMin()&#123;</span><br><span class="line">        if (stackMin.size() == 0)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;stack is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stackMin.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="两个栈组成的队列"><a href="#两个栈组成的队列" class="headerlink" title="两个栈组成的队列"></a>两个栈组成的队列</h1><h5 id="2、编写一个类，用两个栈实现队列，支持队列的基本操作"><a href="#2、编写一个类，用两个栈实现队列，支持队列的基本操作" class="headerlink" title="2、编写一个类，用两个栈实现队列，支持队列的基本操作"></a>2、编写一个类，用两个栈实现队列，支持队列的基本操作</h5><p>思路：栈的特点是先进后出，队列的特点是先进先出。所以我们需要从stackIn中数据倒入stackOut中，在出栈就会满足队列的特点。注意点1：就是从stackIn转移数据到stackOut中的时候，需要把stackIn中的数据全部出栈，再stackOut中进栈。注意点2：如果stackOut不空的时候stackIn不能向stackOut中压入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TwoStackToQueue &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackOut = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(int input)&#123;</span><br><span class="line">        stackIn.push(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int poll()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek()&#123;</span><br><span class="line">        if (stackOut.isEmpty())&#123;</span><br><span class="line">            if (stackIn.isEmpty())&#123;</span><br><span class="line">                throw new RuntimeException(&quot;queue is empty&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="如何仅用递归函数和栈操作逆序一个栈"><a href="#如何仅用递归函数和栈操作逆序一个栈" class="headerlink" title="如何仅用递归函数和栈操作逆序一个栈"></a>如何仅用递归函数和栈操作逆序一个栈</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//翻转栈</span><br><span class="line">public static void reverseStack(Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">    if (stack.isEmpty())&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = getAndRemoveLastElement(stack);</span><br><span class="line">    reverseStack(stack);</span><br><span class="line">    stack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在递归函数中用一个变量来保存中间的值</span><br><span class="line">public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">    int result = stack.pop();</span><br><span class="line">    if (stack.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        int last = getAndRemoveLastElement(stack);</span><br><span class="line">        stack.push(result);</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode168Excel表列名称</title>
      <link href="2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
      <url>2021/06/29/leetcode168Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode168：Excel表列名称"><a href="#leetcode168：Excel表列名称" class="headerlink" title="leetcode168：Excel表列名称"></a>leetcode168：Excel表列名称</h1><p>题目：给你一个整数，返回它在Excel表中相应的列名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">例如：</span><br><span class="line">输入：columnNumber = 1</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">输入：columnNumber = 28</span><br><span class="line">输出：&quot;AB&quot;</span><br><span class="line">输入：columnNumber = 2147483647</span><br><span class="line">输出：&quot;FXSHRXW&quot;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>这道题属于简单题。首先要能够意识这道题考察了进制之间的转换。另外本题中的范围为【1-26】，要变化为【0-25】。</p><h5 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h5><p>1、m进制转化为10进制。</p><p>​        方法：从低位到高位按权展开</p><p>2、10进制转换为n进制</p><p>​        方法：除留取余，逆序排序</p><p>3、本题中的范围是【1-26】，需要对每个进行求余和整除的数减一，在对26进行求余运算，把范围变成【0-25】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String convertToTitle(int columnNumber)&#123;</span><br><span class="line">    //用的stringBuilder进行储存</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    while (columnNumber &gt; 0)&#123;</span><br><span class="line">        columnNumber--;</span><br><span class="line">        //减一,为什么减一。因为26在本题中对应的Z，但是和26除余之后为0.</span><br><span class="line">        //举个例子，比如1--&gt;A.减一除余之后为0，在加A（是加的ASCII码）就变成了A。</span><br><span class="line">        stringBuilder.append((char)((columnNumber % 26) + &#x27;A&#x27;));</span><br><span class="line">        columnNumber = columnNumber / 26;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.reverse();</span><br><span class="line">    return stringBuilder.toString();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin基础</title>
      <link href="2021/06/28/kotlin%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/28/kotlin%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin从入门到进阶实战"><a href="#Kotlin从入门到进阶实战" class="headerlink" title="Kotlin从入门到进阶实战"></a>Kotlin从入门到进阶实战</h1><h2 id="变量和标识符"><a href="#变量和标识符" class="headerlink" title="变量和标识符"></a>变量和标识符</h2><p>变量标识一个对象的地址，称之为标识符。具体存放的数据占用的内存的大小和存放的形式由其类型来决定。</p><p>kotlin中所有的变量类型都是引用类型。kotlin变量分为</p><p>​        val（不可变的）：只读的，仅能赋值一次</p><p>​        var（可写的）：可以被多次赋值</p><h2 id="关键字和修饰符"><a href="#关键字和修饰符" class="headerlink" title="关键字和修饰符"></a>关键字和修饰符</h2><p>关键字：类修饰符、成员修饰符、访问权限修饰符、协变逆变修饰符、函数修饰符、属性修饰符、参数修饰符等</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>分支语句（if、when）</p><p>​        在Kotlin中，if是一个表达式，会返回一个值</p><p>​        if的分支可以是代码块，最后的表达式作为该块的值</p><p>​        when表达式类似于switch..case表达式</p><p>循环语句（for、while）</p><p>​        for循环可以对任何提供迭代器（iterator）的对象进行遍历</p><p>​        while循环类似于java</p><p>跳转语句（return、break、continue、throw）</p><p>​        break：用于完全结束一个循环，直接跳出循环体，然后执行循环后面的语句。<br>​        continue：只终止本轮循环，但是还会继续下一轮循环。</p><p>​        return：kotlin中除了表达式的值，有返回值的函数都要求显示使用return语句返回其值。kotlin中可以直接使用“=”符号返回一个函数的值，这样的函数称为函数字面量。</p><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>kotlin中任何表达式都可以用标签来标记。标签的格式为标识符后跟@符号，可以用标签来控制return、break、continue等语句的跳转行为。</p><h5 id="基本类型："><a href="#基本类型：" class="headerlink" title="基本类型："></a>基本类型：</h5><p>​        在kotlin中，所有东西都是对象，我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示–数字、字符、布尔值在运行时表示为原生类型值，但对于用户来说，看起来就像是普通的类。kotlin中的基本类型：数字、字符、布尔值、数组与字符串。</p><p>整型：Byte、Short、Int、Long。</p><p>​        所有未超出Int最大值的整形值且未显示指定类型，都会被推断为Int类型。如果初始值超过了其最大值且未显示指定类型会被推断为Long类型。</p><p>浮点型：Float、Double。</p><p>​        对于以小数初始化的变量，编译器会推断为Double类型。可以添加f或F将值显示指定为Float类型。</p><p>​        三个特殊的浮点型数值：正无穷大、负无穷大和非数。所有的正无穷大数值都相等，所有的负无穷大数值都相等，非数不与任何数值相等且非数之间也不相等（因为非数之间比较没有意义）</p><p>​        kotlin没有隐式拓宽转换，具有Double参数的函数只能对Double值调用，而不能对Float、Int其他数字值调用 。</p><p>字符型：kotlin语言使用16位的unicode字符集作为编码方式。kotlin中的Char型变量不能当成整数值使用，Char型变量不能赋值给整型变量，整型变量也不能赋值给Char型变量。</p><p>字面值常量：</p><p>​        十进制：123.  Long类型用大写L标记：123L</p><p>​        十六进制：0x0F</p><p>​        二进制：0b00001011</p><p>​        不支持八进制</p><p>支持浮点数的常规表示方法：</p><p>​        默认double:123.5</p><p>​        Float用f或者F标记：123.5f</p><p> kotlin中，较小类型不是较大类型的子类型，所以较小类型不能隐式转换为较大类型。必须通过显示转换。toByte（）、toShort（）、toInt（）、toLong（）等。</p><p>kotlin在表达式中可以自动转换，这种转换是基于上下文推断出来的，算术运算符会有重载做适当转换。</p><p>布尔：布尔用Boolean类型表示，有两个值true和false</p><p>121000004352307294</p><h1 id="疯狂kotlin讲义"><a href="#疯狂kotlin讲义" class="headerlink" title="疯狂kotlin讲义"></a>疯狂kotlin讲义</h1><h2 id="kotlin的基础类型："><a href="#kotlin的基础类型：" class="headerlink" title="kotlin的基础类型："></a>kotlin的基础类型：</h2><p>声明变量：var | val  变量名 【：类型】【= 初始值】</p><p>var声明的变量可被多次赋值，val声明的变量不可被重新赋值</p><p>kotlin是强类型的语言，要求所有的变量必须先声明、后使用，声明变量时必须显示或隐式指定变量的类型。</p><p>程序要么通过“：类型”的形式显示指定该变量的类型，要么为该变量指定初始值-kotlin编译器会根据初始值确定变量的类型。不能声明变量时既不指定变量类型、也不指定变量的初始值。</p><p>常量：</p><p>​        局部范围的常量：允许在声明时不指定初始值，只要在第一次使用之前指定初始值就可以。</p><p>​        类的常量属性：这种常量属性既可以在声明时指定初始值，也可以在类或结构体的构造器中指定初始值。</p><p>kotlin程序编译的字节码必须遵守JVM规范，直接在kotlin程序中定义变量、函数，kotlinc将会自动生成一个名为“文件名首字母大写+Kt”的类，并将变量转换为该类的静态getter、setter方法（val声明的只有getter方法），函数转换为该类的静态方法。</p><p>null安全：只有可空类型的变量或常量才能接受null，非空类型的变量或常量不能接受null。</p><p>kotlin对可空类型进行了限制，可空类型不允许直接调用方法、访问属性。需要先判断该变量不为null，然后再调用该变量的方法和属性。kotlin：“！！”强制调用可空变量的方法和属性，可能引发NPE</p><h5 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h5><p>​        kotlin中的字符串有两种字面值：</p><p>​            转义字符串：可以有转义字符，转移字符串很像普通的java字符串。</p><p>​            原始字符串：可以包含换行和任意文本，原始字符串需要3个引号引起来。</p><p>​        字符串模板：允许在字符串中嵌入变量或表达式，只要将变量或表达式放入${}中，kotlin会把该变量或表达式的值嵌入该字符串中。</p><h5 id="类型别名："><a href="#类型别名：" class="headerlink" title="类型别名："></a>类型别名：</h5><p>​        kotlin提供typealias来定义类型别名。</p><p>​        typealias 类型别名 = 已有类型</p><h2 id="第三章：运算符和表达式"><a href="#第三章：运算符和表达式" class="headerlink" title="第三章：运算符和表达式"></a>第三章：运算符和表达式</h2><p>java支持的运算符包括算数运算符、赋值运算符、扩展后的赋值运算符、比较运算符、逻辑运算符。kotlin也完全支持。</p><p>kotlin不支持三目运算符，kotlin使用if表达式代替了三目运算符。kotlin的运算符都是以方法形式实现的。</p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划总结</title>
      <link href="2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/06/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer42：连续子数组的最大和"><a href="#剑指offer42：连续子数组的最大和" class="headerlink" title="剑指offer42：连续子数组的最大和"></a>剑指offer42：连续子数组的最大和</h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>暴力递归：遍历数组，以i为子数组开始的所有子数组。并且比较大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">    int ans = Integer.MIN_VALUE;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        for (int j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum = sum + nums[j];</span><br><span class="line">            if (sum &gt; ans)&#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>如果当前子数组加上下一位变小了，说明需要重新选择子数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static int maxSubArray(int[] nums)&#123;</span><br><span class="line">        int currSum = 0;</span><br><span class="line">        int maxSum = Integer.MIN_VALUE;       //全负情况，返回最大数</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            currSum = (nums[j] &gt; currSum + nums[j]) ? nums[j] : currSum + nums[j];</span><br><span class="line">            maxSum = (maxSum &gt; currSum) ? maxSum : currSum;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转换成动态规划的过程：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        for(int j = 1;j&lt;nums.length;j++)&#123;</span><br><span class="line">            if(dp[j-1]&gt;0)&#123;</span><br><span class="line">                dp[j] = dp[j-1]+nums[j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[j] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            if(dp[i]&gt;max)</span><br><span class="line">                max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br>示例 2：</p><p>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。<br>示例 3：</p><p>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p><h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p>给定数组arr，返回arr的最长递增子序列。</p><p>arr=[2,1,5,3,6,4,8,9,7],返回的最长递增子序列为【1,3,4,8,9】。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法之动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin</title>
      <link href="2021/06/24/kotlin/"/>
      <url>2021/06/24/kotlin/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-docs（基本语法）"><a href="#Kotlin-docs（基本语法）" class="headerlink" title="Kotlin-docs（基本语法）"></a>Kotlin-docs（基本语法）</h1><p>包的定义和导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包的声明应处于源文件的顶部：</span><br><span class="line">package my.demo</span><br><span class="line">import kotlin.txt</span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kotlin的入口点是main函数</span><br><span class="line">带有两个Int参数、返回Int的函数</span><br><span class="line">fun sum(a: Int, b: Int): Int&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">将表达式作为函数体、返回值类型自动推断的函数</span><br><span class="line">fun sum(a: Int, b: Int) = a + b</span><br><span class="line">函数返回无意义的值：</span><br><span class="line">fun printSum(a: Int, b: Int): Unit&#123;</span><br><span class="line">println(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">Unit返回类型可以省略</span><br><span class="line">fun printSum(a: Int, b: Int)&#123;</span><br><span class="line">printLn(&quot;sum of $a and $b is $&#123;a+b&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var maximun:Int = 5</span><br><span class="line">变量定义关键字 变量名 类型定义 赋值运算符 赋值</span><br><span class="line">简写：var maximun = 5</span><br><span class="line">变量名关键字 变量名 赋值运算符 赋值（相比少了一个类型定义，因为kotlin可以进行类型推断）</span><br><span class="line"></span><br><span class="line">var关键字修饰的是可修改变量</span><br><span class="line">val关键字修饰的是只读变量</span><br><span class="line"></span><br><span class="line">类型推断：对与以声明并赋值的变量，允许省略类型定义</span><br><span class="line"></span><br><span class="line">定义只读局部变量使用关键字val定义，只能为其赋值一次</span><br><span class="line">val a: Int = 1//立即赋值</span><br><span class="line">val b = 2//自动推断出Int类型</span><br><span class="line">val c: Int //如果没有初始值类型不能省略</span><br><span class="line">c = 3 //明确赋值</span><br><span class="line"></span><br><span class="line">可重新赋值的变量使用var关键字</span><br><span class="line">var x = 5 //自动推断出Int类型</span><br><span class="line">x += 1</span><br><span class="line">顶层变量</span><br><span class="line">val PI = 3.14</span><br><span class="line">var x = 0</span><br><span class="line">fun incre()&#123;</span><br><span class="line">x += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时常量：只能定义在函数之外，因为编译时常量必须在编译时赋值，函数都是在运行时才调用，函数内的变量是在运行时赋值，编译时常量要在这些变量赋值前就已经存在。</p><p>编译时常量只能是常见的基本数据类型：String、Int、Double、Float、Long、Short、Byte、Char、Boolean</p><p>kotlin只提供引用类型这一种数据类型，但是kotlin编译器会在java字节码中改用基本数据类型</p><p>空值和null检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当某个变量的值可以为null的时候，必须在声明处的类型后添加？，来标识该引用可以为空</span><br><span class="line">fun parseInt(str: String): Int?&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型检测与自动类型转换:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is运算符检测一个表达式是否某类型的一个实例。如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显示转换。</span><br><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">if (obj is String) &#123;</span><br><span class="line">// `obj` 在该条件分⽀内⾃动转换成`String`</span><br><span class="line">return obj.length</span><br><span class="line">&#125;</span><br><span class="line">// 在离开类型检测分⽀后，`obj` 仍然是`Any` 类型</span><br><span class="line">return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>for循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;,&quot;kiwifruit&quot;)</span><br><span class="line">for(item in items)&#123;</span><br><span class="line">println(item)</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">for (index in items.indices) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>while循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)</span><br><span class="line">var index = 0</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>when表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun describe(obj: Any): String =</span><br><span class="line">when (obj) &#123;</span><br><span class="line">1 -&gt; &quot;One&quot;</span><br><span class="line">&quot;Hello&quot; -&gt; &quot;Greeting&quot;</span><br><span class="line">is Long -&gt; &quot;Long&quot;</span><br><span class="line">!is String -&gt; &quot;Not a string&quot;</span><br><span class="line">else -&gt; &quot;Unknown&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用区间（range）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">使用in运算符来检测某个数字是否在指定区间内</span><br><span class="line">val x = 10</span><br><span class="line">val y = 9</span><br><span class="line">if (x in 1..y+1) &#123;</span><br><span class="line">println(&quot;fits in range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">检测某个数字是否在指定区间外：</span><br><span class="line">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">if (-1 !in 0..list.lastIndex) &#123;</span><br><span class="line">println(&quot;-1 is out of range&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if (list.size !in list.indices) &#123;</span><br><span class="line">println(&quot;list size is out of valid list indices range, too&quot;)</span><br><span class="line">&#125;</span><br><span class="line">区间迭代：</span><br><span class="line">for (x in 1..5) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">数列迭代：</span><br><span class="line">for (x in 1..10 step 2) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line">for (x in 9 downTo 0 step 3) &#123;</span><br><span class="line">print(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="kotlin小知识点"><a href="#kotlin小知识点" class="headerlink" title="kotlin小知识点"></a>kotlin小知识点</h1><h5 id="强类型语言："><a href="#强类型语言：" class="headerlink" title="强类型语言："></a>强类型语言：</h5><p>​        一旦某一个变量被定义类型，如果不经过强制转换，就永远是该数据类型</p><h5 id="弱类型语言："><a href="#弱类型语言：" class="headerlink" title="弱类型语言："></a>弱类型语言：</h5><p>​        某一个变量被定义类型，该变量可以根据环境变化自动变化。</p><h5 id="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"><a href="#强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。-强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。" class="headerlink" title="强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。"></a>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。 强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</h5><h5 id="动态类型语言："><a href="#动态类型语言：" class="headerlink" title="动态类型语言："></a>动态类型语言：</h5><p>​        动态性语言是指在运行期间才去做数据类型检查的语言，也就是动态类型语言编程时，永远不用给任何变量指定数据类型。该语言会在第一次赋值给变量时，在内部将数据类型记录下来。python、ruby</p><h5 id="静态类型语言："><a href="#静态类型语言：" class="headerlink" title="静态类型语言："></a>静态类型语言：</h5><p>​        数据类型在编译期间检查，也就是在写程序的时候要声明变量的数据类型。</p><h5 id="kotlin中的常量问题？"><a href="#kotlin中的常量问题？" class="headerlink" title="kotlin中的常量问题？"></a><em><u>kotlin中的常量问题？</u></em></h5><h5 id="kotlin是null安全的语言："><a href="#kotlin是null安全的语言：" class="headerlink" title="kotlin是null安全的语言："></a>kotlin是null安全的语言：</h5><p>​        Byte、Short、Int、Long型变量都不能接受null值，如果要存储null值，应该使用Byte？、Short？、Int？、Long？类型（相当于支持null值的对应类型）。</p><p>​        加不加？后缀的另一个区别：普通类型的整形变量将会映射成java的基本类型，带？后缀的整形变量将会映射成基本类型的包装类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">val pm1 = 200;</span><br><span class="line">val pm2 = 200;</span><br><span class="line">println(pm1 == pm2);</span><br><span class="line">println(pm1 === pm2)</span><br><span class="line"></span><br><span class="line">val ob1: Int? = 200</span><br><span class="line">val ob2: Int? = 200</span><br><span class="line">println(ob1 == ob2)</span><br><span class="line">println(ob1 === ob2)</span><br><span class="line"></span><br><span class="line">val  ob3: Int? = 100</span><br><span class="line">val  ob4: Int? = 100</span><br><span class="line">println(ob3 == ob4)</span><br><span class="line">println(ob3 === ob4)</span><br><span class="line">结果如下：</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS服务和参数</title>
      <link href="2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/"/>
      <url>2021/06/10/%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"><a href="#ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。" class="headerlink" title="ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。"></a>ROS服务：服务是节点之间通讯的另一种方式。服务允许节点发送一个请求并获得一个响应。</h2><h1 id="使用rosservice"><a href="#使用rosservice" class="headerlink" title="使用rosservice"></a>使用rosservice</h1><p>rosservice可以很容易通过服务附加到ROS客户端/服务器框架上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rosservice list         输出活跃服务的信息</span><br><span class="line">rosservice call         用给定的参数调用服务</span><br><span class="line">rosservice type         输出服务的类型</span><br><span class="line">rosservice find         按服务的类型查找服务</span><br><span class="line">rosservice uri          输出服务的ROSRPC uri</span><br></pre></td></tr></table></figure><p>rosservice type [service]:进一步查看服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /clear</span><br><span class="line">结果是：std_srvs/Empty</span><br></pre></td></tr></table></figure><p>服务的类型为empty，表明调用这个服务时不需要参数。（它在发出<strong>请求</strong>时不发送数据，在接收<strong>响应</strong>时也不接收数据）</p><p>rosservice call [service] [args]:call命令调用服务，args是给定的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear：</span><br><span class="line">call:表明调用clear服务</span><br></pre></td></tr></table></figure><p>查看spawn（产卵）服务的信息，此服务具有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice type /spawn | rossrv show</span><br></pre></td></tr></table></figure><p>​        spawn服务的参数：name字段是可选的        </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float32 x</span><br><span class="line">float32 y</span><br><span class="line">float32 theta</span><br><span class="line">string name</span><br><span class="line">---</span><br><span class="line">string name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn 2 2 0.2 &quot;&quot;</span><br><span class="line">调用spawn服务，并且需要参数。</span><br><span class="line">clear服务不需要参数</span><br></pre></td></tr></table></figure><h1 id="使用rosparam"><a href="#使用rosparam" class="headerlink" title="使用rosparam"></a>使用rosparam</h1><p><code>rosparam</code>能让我们在ROS[参数服务器（Parameter Server）](<a href="http://wiki.ros.org/Parameter">http://wiki.ros.org/Parameter</a> Server)上存储和操作数据。参数服务器能够存储整型（integer）、浮点（float）、布尔（boolean）、字典（dictionaries）和列表（list）等数据类型。rosparam使用YAML标记语言的语法。一般而言，YAML的表述很自然：<code>1</code>是整型，<code>1.0</code>是浮点型，<code>one</code>是字符串，<code>true</code>是布尔型，<code>[1, 2, 3]</code>是整型组成的列表，<code>&#123;a: b, c: d&#125;</code>是字典。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS话题</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%AF%9D%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="理解ROS话题（乌龟走动幕后的故事）"><a href="#理解ROS话题（乌龟走动幕后的故事）" class="headerlink" title="理解ROS话题（乌龟走动幕后的故事）"></a>理解ROS话题（乌龟走动幕后的故事）</h1><p>roscore：只运行一个roscore就够了。</p><p>乌龟走动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个新终端：roscore</span><br><span class="line">新终端：rosrun turtlesim turtlesim_node</span><br><span class="line">新终端：rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><h2 id="ROS话题："><a href="#ROS话题：" class="headerlink" title="ROS话题："></a>ROS话题：</h2><p>​            turtlesim_node节点和turtle_teleop_key节点之间通过ROS话题相互通信。turtle_teleop_key在话题上发布键盘按下的信息，turtlesim_node订阅该话题以接收消息。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure><p>上述命令之后，rqt_graph会用动态的图显示系统中发生的事情。</p><h2 id="rostopic：rostopic命令工具能获取ROS话题的信息。"><a href="#rostopic：rostopic命令工具能获取ROS话题的信息。" class="headerlink" title="rostopic：rostopic命令工具能获取ROS话题的信息。"></a>rostopic：rostopic命令工具能获取ROS话题的信息。</h2><p>rostopic -h：查看可用的rostopic的子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">        rostopic bw     display bandwidth used by topic</span><br><span class="line">        rostopic delay  display delay of topic from timestamp in header</span><br><span class="line">        rostopic echo   print messages to screen</span><br><span class="line">        rostopic find   find topics by type</span><br><span class="line">        rostopic hz     display publishing rate of topic    </span><br><span class="line">        rostopic info   print information about active topic</span><br><span class="line">        rostopic list   list active topics</span><br><span class="line">        rostopic pub    publish data to topic</span><br><span class="line">        rostopic type   print topic or field type</span><br></pre></td></tr></table></figure><p>rostopic echo [topic]:查看在某个话题上发布的数据。（也就是去订阅了话题）</p><p>rostopic list -h：查看可用的rostopic list子命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -b BAGFILE, --bag=BAGFILE</span><br><span class="line">                        list topics in .bag file</span><br><span class="line">  -v, --verbose         list full details about each topic</span><br><span class="line">  -p                    list only publishers</span><br><span class="line">  -s                    list only subscribers</span><br></pre></td></tr></table></figure><p>rostopic list -v：会列出所有发布者和订阅的主题及其类型的相关信息。</p><h1 id="ROS消息"><a href="#ROS消息" class="headerlink" title="ROS消息"></a>ROS消息</h1><p>话题的通信是通过节点间发送ROS消息实现的。为了使发布者和订阅者进行通信，发布者和订阅者必须发送和接收相同类型的消息。所以话题的类型是由发布在上面的消息的类型决定的。</p><p>rostopic type 【topic】:查看所发布话题的消息类型。    </p><p>​        使用rosmsg show  【geometry_msgs/Twist】查看消息的详细信息。</p><h2 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic:"></a>rostopic:</h2><p>rostopic pub 【topic】【msg_type】【args】:把数据发布到当前某个正在广播的话题上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, 1.8]&#x27;</span><br></pre></td></tr></table></figure><p>rostopic pub:将消息发布到指定的话题。</p><p>-1：让rostopic只发布一条消息，然后退出</p><p>/turtle1/cmd_vel：要发布到的话题的名称</p><p>geometry_msgs/Twist：发布到话题时要使用的消息的类型</p><p>–：两个破折号，用来告诉解析器，之后的参数都不是选项</p><p>如前所述，一个turtlesim/Velocity消息有两个浮点型元素：<code>linear</code>和<code>angular</code>。在本例中，<code>&#39;[2.0, 0.0, 0.0]&#39;</code>表示<code>linear</code>的值为<code>x=2.0</code>, <code>y=0.0</code>, <code>z=0.0</code>，而<code>&#39;[0.0, 0.0, 1.8]&#39;</code>是说<code>angular</code>的值为<code>x=0.0</code>, <code>y=0.0</code>, <code>z=1.8</code>。这些参数实际上使用的是YAML语法，在<a href="http://wiki.ros.org/ROS/YAMLCommandLine">YAML命令行文档</a>中有描述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &#x27;[2.0, 0.0, 0.0]&#x27; &#x27;[0.0, 0.0, -1.8]&#x27;</span><br></pre></td></tr></table></figure><p>turtle以一个稳定的频率为1Hz的指令流才能保持移动状态。我们可以使用<code>rostopic pub -r</code>命令来发布源源不断的命令。</p><p>rostopic hz 【topic】：报告数据发布的速率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic type /turtle1/cmd_vel | rosmsg show</span><br></pre></td></tr></table></figure><p>结合rostopic、type、rosmsg show、命令来获取关于某个话题的更深层次的信息。</p><h1 id="使用rqt-plot"><a href="#使用rqt-plot" class="headerlink" title="使用rqt_plot"></a>使用rqt_plot</h1><p><code>rqt_plot</code>命令可以在滚动时间图上显示发布到某个话题上的数据。这里我们将使用<code>rqt_plot</code>命令来绘制正被发布到<code>/turtle1/pose</code>话题上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解ROS节点</title>
      <link href="2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/"/>
      <url>2021/06/09/%E7%90%86%E8%A7%A3ROS%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p>计算图是一个由ROS进程组成的点对点网络，能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Services）、话题（Topics）、包（Bags）。</p><p>节点：是ROS软件包中的一个可执行文件，可以通过ROS来与其他节点通信。</p><p>​            ROS节点使用ROS客户端与其他节点通信。节点可以发布或订阅话题，也可以提供或使用服务。</p><p>消息：订阅或发布话题时所使用的的ROS数据类型。</p><p>话题：节点可以将消息发布到话题或者通过订阅话题来接收消息。</p><p>主节点：ROS的命名服务，帮助节点发现彼此。</p><p>rosout：相当于stdout/stderr（标准输出、标准错误）</p><p>​                rosout节点，用于收集和记录节点的调试输出，所以总是在运行。</p><p>roscore：主节点+rosout+参数服务器</p><p>​                运行所有ROS程序前需要运行的命令。</p><p>客户端库：ROS客户端库可以让不同编程语言编写的节点进行相互通信</p><p>​                    rospy=python客户端库</p><p>​                    roscpp=c++客户端库</p><p>rosnode:获取接地那信息的ros工具</p><p>​                rosnode list：列出活动的节点</p><p>​                rosnode info：返回某个节点的信息。rosnode info /rosout</p><p>​                rosnode cleanup：尝试清除rosnode列表</p><p>rosrun：运行给定的软件包中的节点</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terminator常用快捷键</title>
      <link href="2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2021/06/08/Terminator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //移动到上面的终端</span><br><span class="line">Alt+Down                        //移动到下面的终端</span><br><span class="line">Alt+Left                        //移动到左边的终端</span><br><span class="line">Alt+Right                       //移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line">Ctrl+Shift+S                    //隐藏/显示滚动条</span><br><span class="line">Ctrl+Shift+F                    //搜索</span><br><span class="line">Ctrl+Shift+C                    //复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V                    //粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+W                    //关闭当前终端</span><br><span class="line">Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭</span><br><span class="line">Ctrl+Shift+X                    //最大化显示当前终端</span><br><span class="line">Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大</span><br><span class="line">Ctrl+Shift+N or Ctrl+Tab        //移动到下一个终端</span><br><span class="line">Ctrl+Shift+P or Ctrl+Shift+Tab  //Crtl+Shift+Tab 移动到之前的一个终端</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="标签之间的操作"><a href="#标签之间的操作" class="headerlink" title="标签之间的操作"></a>标签之间的操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F11                             //全屏开关</span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line">Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置</span><br><span class="line">Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置</span><br><span class="line">Ctrl+Plus (+)                   //增大字体</span><br><span class="line">Ctrl+Minus (-)                  //减小字体</span><br><span class="line">Ctrl+Zero (0)                   //恢复字体到原始大小</span><br><span class="line">Ctrl+Shift+R                    //重置终端状态</span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line">Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端</span><br><span class="line">Super+Shift+G                   //解除绑定</span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line">Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程</span><br><span class="line">Super+i                         //打开一个新窗口，新窗口与原来的窗口使用不同的进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS软件包</title>
      <link href="2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
      <url>2021/06/07/ROS%E8%BD%AF%E4%BB%B6%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="创建ROS软件包"><a href="#创建ROS软件包" class="headerlink" title="创建ROS软件包"></a>创建ROS软件包</h1><ol><li><p>catkin软件包的组成：</p><ol><li>必须有一个符合catkin规范的package.xml文件。</li><li>必须有一个CMakeLists.txt文件</li><li>每个包必须有自己的目录。同一目录下不能嵌套或者多个软件包存在</li></ol></li><li><p>catkin工作空间中的软件包</p><ol><li><p>推荐使用catkin工作空间，也可以单独开发catkin软件包</p></li><li><p>创建软件包之前需要创建工作空间</p></li><li><pre><code>workspace_folder/        -- WORKSPACE  src/                   -- SOURCE SPACE    CMakeLists.txt       -- &#39;Toplevel&#39; CMake file, provided by catkin    package_1/      CMakeLists.txt     -- CMakeLists.txt file for package_1      package.xml        -- Package manifest for package_1    ...    package_n/      CMakeLists.txt     -- CMakeLists.txt file for package_n      package.xml        -- Package manifest for package_n<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 创建catkin软件包（功能包）</span><br><span class="line"></span><br><span class="line">   1. 切换到catkin工作空间中的源文件空间目录</span><br><span class="line"></span><br></pre></td></tr></table></figure> cd ~/catkin_ws/src<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用catkin_create_pkg命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>catkin_create_pkg catkin软件包名 std_msgs rospy roscpp<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      catkin软件包内包含[package.xml](http://wiki.ros.org/catkin/package.xml)文件和一个[CMakeLists.txt](http://wiki.ros.org/catkin/CMakeLists.txt)文件，文件中有执行catkin_create_pkg命令时提供的信息。</span><br><span class="line"></span><br><span class="line">      std_msgs rospy roscpp三个包是依赖。</span><br><span class="line"></span><br><span class="line">4. 包依赖关系</span><br><span class="line"></span><br><span class="line">   1. 一级依赖</span><br><span class="line">   2. 间接依赖</span><br><span class="line"></span><br><span class="line"># 构建ROS软件包</span><br><span class="line"></span><br><span class="line">在catkin工作空间构建ros软件包</span><br><span class="line"></span><br><span class="line">catkin_make:是一个命令行工具，它简化了标准catkin工作流程。你可以认为`catkin_make`是在标准CMake工作流程中依次调用了`cmake`和`make`。</span><br><span class="line"></span><br></pre></td></tr></table></figure>#在catkin工作空间下catkin_make<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">build:构建空间的默认位置，同时cmake和make在这里被调用用来配置和构建软件包。</span><br><span class="line"></span><br><span class="line">devel：开发空间的默认位置，在安装软件包之前，这里存放可执行文件和库。</span><br><span class="line"></span><br><span class="line">src：源码文件</span><br><span class="line"></span><br><span class="line"># 创建ROS工作空间（先于创建ROS软件包）</span><br><span class="line"></span><br></pre></td></tr></table></figure>$ mkdir -p ~/工作空间名/src$ cd ~/catkin_ws/$ catkin_make</code></pre></li></ol></li></ol><p>catkin_make命令：在工作空间第一次运行的时候，会在src目录下创建CMakeLists.txt链接。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS文件系统</title>
      <link href="2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/06/07/ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>软件包（packages）：包是ROS代码的软件组织单元，每个软件包都可以包含程序库、可执行文件、脚本或其他构件。</p><p>Manifests（package.xml）:清单是对软件包的描述，用于定义软件包之间的依赖关系，并记录有关软件包的元信息。如版本、维护者、许可证</p><h1 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h1><p>ROS提供了专门的命令工具来实现ros软件包的查找和导航。</p><ul><li><p>rospack：获取软件包的有关信息。find选项返回软件包所在路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack find roscpp</span><br></pre></td></tr></table></figure><p>结果：/opt/ros/<distro>/share/roscpp</p></li><li><p>roscd:直接切换目录到某个软件包或者软件包集中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd roscpp</span><br><span class="line">roscd roscpp/cmake</span><br></pre></td></tr></table></figure><p>只能切换到那些路径包含在ROS_PACKAGE_PATH环境变量中的软件包。</p></li><li><p>roscd log:进入存储ROS日志文件的目录，如果没有执行过任何ROS程序，系统会报错说该目录不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscd log</span><br></pre></td></tr></table></figure></li><li><p>rosls: 允许直接按软件包的名称执行，而不必输入绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosls roscpp_tutorials</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/03/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="VIM常用命令："><a href="#VIM常用命令：" class="headerlink" title="VIM常用命令："></a>VIM常用命令：</h1><h2 id="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"><a href="#vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。" class="headerlink" title="vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。"></a>vim介绍：共分三种模式，命令模式、输入模式、底线命令模式。</h2><p>命令模式（一般模式）：启动vim就进入了命令模式。此时键盘动作被识别为命令，比如：i切换到输入模式、x删除当前光标所在处的字符、：切换到底线命令模式、u撤回上一步的操作。</p><p>输入模式（编辑模式）：ESC键退出输入模式，切换到命令模式。</p><p>底线命令模式：命令模式下按:（英文）进入底线命令模式。q退出程序、w保存文件、ESC退出底线命令模式。</p><p>搜索替换：命令模式下，（/word，代表向光标之下寻找一个字符串）（？word，代表向光标之上寻找一个字符串），n代表重复前一个搜索动作，N反向搜索的动作。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rosDay1</title>
      <link href="2021/06/03/rosDay1/"/>
      <url>2021/06/03/rosDay1/</url>
      
        <content type="html"><![CDATA[<h1 id="helloworld实现过程（C-）："><a href="#helloworld实现过程（C-）：" class="headerlink" title="helloworld实现过程（C++）："></a>helloworld实现过程（C++）：</h1><p>1.创建工作空间并编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 工作空间名称/src</span><br><span class="line">cd 工作空间</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>首先会创建一个工作空间和一个src子目录，进入工作空间调用catkin_make命令编译。</p><p>2.进入工作空间下的src目录，创建ros功能包并添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src</span><br><span class="line">catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure><p>会在工作空间下生成一个功能包，该功能包依赖于 roscpp、rospy 与 std_msgs，其中roscpp是使用C++实现的库，而rospy则是使用python实现的库，std_msgs是标准消息库，创建ROS功能包时，一般都会依赖这三个库实现。</p><p>3.进入ros功能包下的src目录编辑源文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 工作空间/src/功能包/src</span><br></pre></td></tr></table></figure><p>注意是功能包下的src目录，编辑源文件。</p><p>4.编辑配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">配置文件位置：和功能包下的src平级的</span><br><span class="line">cd 工作空间/src/功能包/CMakeLists.txt</span><br><span class="line">编辑内容如下：</span><br><span class="line">add_executable(步骤3的源文件名</span><br><span class="line">  src/步骤3的源文件名.cpp</span><br><span class="line">)</span><br><span class="line">两个参数：分别修改为如下</span><br><span class="line">1.相当于后边原文件名的别名，可以任意名字，一般建议为原文件名</span><br><span class="line">2：功能包/src/源文件名.cpp</span><br><span class="line"></span><br><span class="line">修改链接库：</span><br><span class="line">target_link_libraries(步骤3的源文件名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line">修改第一个参数：</span><br><span class="line">1.修改为add_executable中的一个参数名（也就是源文件名的别名）</span><br></pre></td></tr></table></figure><p>5.编译执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在工作空间目录下编译</span><br><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行过程：</span><br><span class="line">启动命令：roscore</span><br><span class="line">另外一个终端：</span><br><span class="line">cd 工作空间</span><br><span class="line">source ./devel/setup.bash（作用：把当前工作空间刷新到当前窗口下的环境变量。缺点是：只在当前终端管用）</span><br><span class="line">rosrun 包名 C++节点（源文件的映射名字）</span><br></pre></td></tr></table></figure><p><code>source ~/工作空间/devel/setup.bash</code>可以添加进<code>.bashrc</code>文件，使用上更方便</p><p>添加方式1: 直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容</p><p>添加方式2:<code>echo &quot;source ~/工作空间/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p><h1 id="helloworld实现过程（python）"><a href="#helloworld实现过程（python）" class="headerlink" title="helloworld实现过程（python）"></a>helloworld实现过程（python）</h1><p>1.创建工作空间和功能包（如上cpp过程）</p><h1 id="ROS工作空间目录"><a href="#ROS工作空间目录" class="headerlink" title="ROS工作空间目录"></a>ROS工作空间目录</h1><p>工作空间：是一个存放工程开发相关文件的文件夹</p><ol><li>build:编译空间，编译过程产生的中间文件</li><li>devel：开发空间，可执行文件和相关脚本</li><li>src：代码空间</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/06/02/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="新建文章步骤："><a href="#新建文章步骤：" class="headerlink" title="新建文章步骤："></a>新建文章步骤：</h1><p>1.在你的博客目录下，右键Git Bash Here。输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章的名字&quot;</span><br></pre></td></tr></table></figure><p>2.在博客目录下/source/_posts/文件夹下，会生成”文章的名字.md”文件</p><p>3.在文件中编辑博客内容。hexo发布的文章是Markdown格式的文件。我使用的Typora软件进行编辑的。Markdown语法可以参考如下网址：<a href="http://www.markdown.cn/">语法网址</a>。</p><p>4.给文章添加分类和标签：在md文件中设置tags和categories属性就行了。</p><p>5.hexo s，启动本地服务器进行测试</p><p>6.hexo clean：清楚命令</p><p>hexo g：重新生成</p><p>hexo d：发布命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="2021/06/02/ros/"/>
      <url>2021/06/02/ros/</url>
      
        <content type="html"><![CDATA[<p>机器人操作系统(ROS)是一个用于编写机器人软件的灵活框架。它是一个工具、库和约定的集合，旨在简化跨各种机器人平台创建复杂和健壮的机器人行为的任务。ROS操作系统是目前使用最广泛的开源机器人软件平台，在无人驾驶系统的实现上，ROS是开源框架中的最好的选择。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。</p><span id="more"></span><p>ROS1.0的架构核心是基于message的松耦合、分布式架构。核心概念有：Node、Master、Message、Topic、Services等。因为ROS1.0在设计之初没有考虑到安全问题，所以ROS 1.0框架主要安全风险充分暴露：匿名通信无身份认证、消息明文传输、缺少访问控制等。</p><p>ROS2.0采用DDS替换了ROS1.0的publish-subscribe通信机制，因为DDS本身是有Security安全协议规范的，因此ROS2.0的安全主要基于DDS-Security。</p><p>DDS-Security规范对DDS规范进行了扩展，通过定义服务插件接口(Service Plugin Interface，SPI)体系结构、SPI的一组内置实现以及SPI实施的安全模型，增加了安全增强功能。具体地说，定义了五个SPI：</p><p>身份验证：验证给定域参与者的身份。</p><p>访问控制：对可由验证域参与者执行的与DDS相关的操作实施限制。 </p><p>加密：处理所有必需的加密、签名和散列操作。</p><p>日志记录：提供审计与DDS安全相关的事件的能力。 </p><p>数据标记：提供向数据样本添加标记的功能。</p><p>ROS 2的安全功能目前只使用前三个功能。这是因为为了符合DDS-Security规范，既不需要日志记录，也不需要数据标记，因此并不是所有的DDS实现都支持它们。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 自动驾驶操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/25/hello-world/"/>
      <url>2021/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
